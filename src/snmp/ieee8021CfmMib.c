/*****************************************************************************

 @(#) src/snmp/ieee8021cfmmib.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/ieee8021cfmmib.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "ieee8021CfmMib.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "ieee8021CfmMib";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int ieee8021CfmMib_refresh = 1;
volatile int dot1agCfmStackTable_refresh = 1;
volatile int dot1agCfmDefaultMdTable_refresh = 1;
volatile int dot1agCfmVlanTable_refresh = 1;
volatile int dot1agCfmConfigErrorListTable_refresh = 1;
volatile int dot1agCfmMdTable_refresh = 1;
volatile int dot1agCfmMaNetTable_refresh = 1;
volatile int dot1agCfmMaCompTable_refresh = 1;
volatile int dot1agCfmMaMepListTable_refresh = 1;
volatile int dot1agCfmMepTable_refresh = 1;
volatile int dot1agCfmLtrTable_refresh = 1;
volatile int dot1agCfmMepDbTable_refresh = 1;

/*
 * ieee8021CfmMib_variables_oid: object identifier for ieee8021CfmMib
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid ieee8021CfmMib_variables_oid[8] = { 1, 3, 111, 2, 802, 1, 1, 8 };
oid dot1agCfmVlanTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 3, 1, 1 };
oid dot1agCfmMdTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 5, 2, 1 };
oid dot1agCfmMaNetTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 1, 1 };
oid dot1agCfmMaCompTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 2, 1 };
oid dot1agCfmMaMepListTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 6, 3, 1 };
oid dot1agCfmMepTable_variables_oid[12] = { 1, 3, 111, 2, 802, 1, 1, 8, 1, 7, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid dot1agCfmFaultAlarm_oid[10] = { 1, 3, 111, 2, 802, 1, 1, 8, 0, 1 };

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid dot1agCfmCompliance_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 1, 1 };
oid dot1agCfmStackGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 1 };
oid dot1agCfmDefaultMdGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 2 };
oid dot1agCfmVlanIdGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 3 };
oid dot1agCfmConfigErrorListGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 4 };
oid dot1agCfmMdGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 5 };
oid dot1agCfmMaGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 6 };
oid dot1agCfmMepGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 7 };
oid dot1agCfmMepDbGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 8 };
oid dot1agCfmNotificationsGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 9 };
oid ieee8021CfmMaNetGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 10 };
oid ieee8021CfmDefaultMdDefGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 11 };
oid ieee8021CfmPbbTeExtensionGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 12 };
oid ieee8021CfmPbbTeTrafficBitGroup_oid[11] = { 1, 3, 111, 2, 802, 1, 1, 8, 2, 2, 13 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 ieee8021CfmMib_variables: tree for ieee8021CfmMib
 * This variable defines function callbacks and type return information for the ieee8021CfmMib mib section
 */
struct variable7 ieee8021CfmMib_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   DOT1AGCFMSTACKMDINDEX  1
	{(u_char) DOT1AGCFMSTACKMDINDEX, ASN_UNSIGNED, RONLY, var_dot1agCfmStackTable, 5, {1, 1, 1, 1, 5}},
#define   DOT1AGCFMSTACKMAINDEX  2
	{(u_char) DOT1AGCFMSTACKMAINDEX, ASN_UNSIGNED, RONLY, var_dot1agCfmStackTable, 5, {1, 1, 1, 1, 6}},
#define   DOT1AGCFMSTACKMEPID   3
	{(u_char) DOT1AGCFMSTACKMEPID, ASN_UNSIGNED, RONLY, var_dot1agCfmStackTable, 5, {1, 1, 1, 1, 7}},
#define   DOT1AGCFMSTACKMACADDRESS  4
	{(u_char) DOT1AGCFMSTACKMACADDRESS, ASN_OCTET_STR, RONLY, var_dot1agCfmStackTable, 5, {1, 1, 1, 1, 8}},
#define   DOT1AGCFMDEFAULTMDDEFLEVEL  5
	{(u_char) DOT1AGCFMDEFAULTMDDEFLEVEL, ASN_INTEGER, RWRITE, var_ieee8021CfmMib, 3, {1, 2, 1}},
#define   DOT1AGCFMDEFAULTMDDEFMHFCREATION  6
	{(u_char) DOT1AGCFMDEFAULTMDDEFMHFCREATION, ASN_INTEGER, RWRITE, var_ieee8021CfmMib, 3, {1, 2, 2}},
#define   DOT1AGCFMDEFAULTMDDEFIDPERMISSION  7
	{(u_char) DOT1AGCFMDEFAULTMDDEFIDPERMISSION, ASN_INTEGER, RWRITE, var_ieee8021CfmMib, 3, {1, 2, 3}},
#define   DOT1AGCFMDEFAULTMDSTATUS  8
	{(u_char) DOT1AGCFMDEFAULTMDSTATUS, ASN_INTEGER, RONLY, var_dot1agCfmDefaultMdTable, 5, {1, 2, 4, 1, 3}},
#define   DOT1AGCFMDEFAULTMDLEVEL  9
	{(u_char) DOT1AGCFMDEFAULTMDLEVEL, ASN_INTEGER, RWRITE, var_dot1agCfmDefaultMdTable, 5, {1, 2, 4, 1, 4}},
#define   DOT1AGCFMDEFAULTMDMHFCREATION  10
	{(u_char) DOT1AGCFMDEFAULTMDMHFCREATION, ASN_INTEGER, RWRITE, var_dot1agCfmDefaultMdTable, 5, {1, 2, 4, 1, 5}},
#define   DOT1AGCFMDEFAULTMDIDPERMISSION  11
	{(u_char) DOT1AGCFMDEFAULTMDIDPERMISSION, ASN_INTEGER, RWRITE, var_dot1agCfmDefaultMdTable, 5, {1, 2, 4, 1, 6}},
#define   DOT1AGCFMVLANPRIMARYVID  12
	{(u_char) DOT1AGCFMVLANPRIMARYVID, ASN_INTEGER, RWRITE, var_dot1agCfmVlanTable, 5, {1, 3, 1, 1, 3}},
#define   DOT1AGCFMVLANROWSTATUS  13
	{(u_char) DOT1AGCFMVLANROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmVlanTable, 5, {1, 3, 1, 1, 4}},
#define   DOT1AGCFMCONFIGERRORLISTERRORTYPE  14
	{(u_char) DOT1AGCFMCONFIGERRORLISTERRORTYPE, ASN_OCTET_STR, RONLY, var_dot1agCfmConfigErrorListTable, 5, {1, 4, 1, 1, 3}},
#define   DOT1AGCFMMDTABLENEXTINDEX  15
	{(u_char) DOT1AGCFMMDTABLENEXTINDEX, ASN_UNSIGNED, RONLY, var_ieee8021CfmMib, 3, {1, 5, 1}},
#define   DOT1AGCFMMDFORMAT     16
	{(u_char) DOT1AGCFMMDFORMAT, ASN_INTEGER, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 2}},
#define   DOT1AGCFMMDNAME       17
	{(u_char) DOT1AGCFMMDNAME, ASN_OCTET_STR, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 3}},
#define   DOT1AGCFMMDMDLEVEL    18
	{(u_char) DOT1AGCFMMDMDLEVEL, ASN_INTEGER, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 4}},
#define   DOT1AGCFMMDMHFCREATION  19
	{(u_char) DOT1AGCFMMDMHFCREATION, ASN_INTEGER, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 5}},
#define   DOT1AGCFMMDMHFIDPERMISSION  20
	{(u_char) DOT1AGCFMMDMHFIDPERMISSION, ASN_INTEGER, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 6}},
#define   DOT1AGCFMMDMANEXTINDEX  21
	{(u_char) DOT1AGCFMMDMANEXTINDEX, ASN_UNSIGNED, RONLY, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 7}},
#define   DOT1AGCFMMDROWSTATUS  22
	{(u_char) DOT1AGCFMMDROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMdTable, 5, {1, 5, 2, 1, 8}},
#define   DOT1AGCFMMANETFORMAT  23
	{(u_char) DOT1AGCFMMANETFORMAT, ASN_INTEGER, RWRITE, var_dot1agCfmMaNetTable, 5, {1, 6, 1, 1, 2}},
#define   DOT1AGCFMMANETNAME    24
	{(u_char) DOT1AGCFMMANETNAME, ASN_OCTET_STR, RWRITE, var_dot1agCfmMaNetTable, 5, {1, 6, 1, 1, 3}},
#define   DOT1AGCFMMANETCCMINTERVAL  25
	{(u_char) DOT1AGCFMMANETCCMINTERVAL, ASN_INTEGER, RWRITE, var_dot1agCfmMaNetTable, 5, {1, 6, 1, 1, 4}},
#define   DOT1AGCFMMANETROWSTATUS  26
	{(u_char) DOT1AGCFMMANETROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMaNetTable, 5, {1, 6, 1, 1, 5}},
#define   DOT1AGCFMMACOMPPRIMARYVLANID  27
	{(u_char) DOT1AGCFMMACOMPPRIMARYVLANID, ASN_INTEGER, RWRITE, var_dot1agCfmMaCompTable, 5, {1, 6, 2, 1, 2}},
#define   DOT1AGCFMMACOMPMHFCREATION  28
	{(u_char) DOT1AGCFMMACOMPMHFCREATION, ASN_INTEGER, RWRITE, var_dot1agCfmMaCompTable, 5, {1, 6, 2, 1, 3}},
#define   DOT1AGCFMMACOMPIDPERMISSION  29
	{(u_char) DOT1AGCFMMACOMPIDPERMISSION, ASN_INTEGER, RWRITE, var_dot1agCfmMaCompTable, 5, {1, 6, 2, 1, 4}},
#define   DOT1AGCFMMACOMPNUMBEROFVIDS  30
	{(u_char) DOT1AGCFMMACOMPNUMBEROFVIDS, ASN_UNSIGNED, RWRITE, var_dot1agCfmMaCompTable, 5, {1, 6, 2, 1, 5}},
#define   DOT1AGCFMMACOMPROWSTATUS  31
	{(u_char) DOT1AGCFMMACOMPROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMaCompTable, 5, {1, 6, 2, 1, 6}},
#define   DOT1AGCFMMAMEPLISTROWSTATUS  32
	{(u_char) DOT1AGCFMMAMEPLISTROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMaMepListTable, 5, {1, 6, 3, 1, 2}},
#define   DOT1AGCFMMEPIFINDEX   33
	{(u_char) DOT1AGCFMMEPIFINDEX, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 2}},
#define   DOT1AGCFMMEPDIRECTION  34
	{(u_char) DOT1AGCFMMEPDIRECTION, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 3}},
#define   DOT1AGCFMMEPPRIMARYVID  35
	{(u_char) DOT1AGCFMMEPPRIMARYVID, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 4}},
#define   DOT1AGCFMMEPACTIVE    36
	{(u_char) DOT1AGCFMMEPACTIVE, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 5}},
#define   DOT1AGCFMMEPFNGSTATE  37
	{(u_char) DOT1AGCFMMEPFNGSTATE, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 6}},
#define   DOT1AGCFMMEPCCIENABLED  38
	{(u_char) DOT1AGCFMMEPCCIENABLED, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 7}},
#define   DOT1AGCFMMEPCCMLTMPRIORITY  39
	{(u_char) DOT1AGCFMMEPCCMLTMPRIORITY, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 8}},
#define   DOT1AGCFMMEPMACADDRESS  40
	{(u_char) DOT1AGCFMMEPMACADDRESS, ASN_OCTET_STR, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 9}},
#define   DOT1AGCFMMEPLOWPRDEF  41
	{(u_char) DOT1AGCFMMEPLOWPRDEF, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 10}},
#define   DOT1AGCFMMEPFNGALARMTIME  42
	{(u_char) DOT1AGCFMMEPFNGALARMTIME, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 11}},
#define   DOT1AGCFMMEPFNGRESETTIME  43
	{(u_char) DOT1AGCFMMEPFNGRESETTIME, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 12}},
#define   DOT1AGCFMMEPHIGHESTPRDEFECT  44
	{(u_char) DOT1AGCFMMEPHIGHESTPRDEFECT, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 13}},
#define   DOT1AGCFMMEPDEFECTS   45
	{(u_char) DOT1AGCFMMEPDEFECTS, ASN_OCTET_STR, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 14}},
#define   DOT1AGCFMMEPERRORCCMLASTFAILURE  46
	{(u_char) DOT1AGCFMMEPERRORCCMLASTFAILURE, ASN_OCTET_STR, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 15}},
#define   DOT1AGCFMMEPXCONCCMLASTFAILURE  47
	{(u_char) DOT1AGCFMMEPXCONCCMLASTFAILURE, ASN_OCTET_STR, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 16}},
#define   DOT1AGCFMMEPCCMSEQUENCEERRORS  48
	{(u_char) DOT1AGCFMMEPCCMSEQUENCEERRORS, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 17}},
#define   DOT1AGCFMMEPCCISENTCCMS  49
	{(u_char) DOT1AGCFMMEPCCISENTCCMS, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 18}},
#define   DOT1AGCFMMEPNEXTLBMTRANSID  50
	{(u_char) DOT1AGCFMMEPNEXTLBMTRANSID, ASN_UNSIGNED, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 19}},
#define   DOT1AGCFMMEPLBRIN     51
	{(u_char) DOT1AGCFMMEPLBRIN, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 20}},
#define   DOT1AGCFMMEPLBRINOUTOFORDER  52
	{(u_char) DOT1AGCFMMEPLBRINOUTOFORDER, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 21}},
#define   DOT1AGCFMMEPLBRBADMSDU  53
	{(u_char) DOT1AGCFMMEPLBRBADMSDU, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 22}},
#define   DOT1AGCFMMEPLTMNEXTSEQNUMBER  54
	{(u_char) DOT1AGCFMMEPLTMNEXTSEQNUMBER, ASN_UNSIGNED, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 23}},
#define   DOT1AGCFMMEPUNEXPLTRIN  55
	{(u_char) DOT1AGCFMMEPUNEXPLTRIN, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 24}},
#define   DOT1AGCFMMEPLBROUT    56
	{(u_char) DOT1AGCFMMEPLBROUT, ASN_COUNTER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 25}},
#define   DOT1AGCFMMEPTRANSMITLBMSTATUS  57
	{(u_char) DOT1AGCFMMEPTRANSMITLBMSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 26}},
#define   DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS  58
	{(u_char) DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS, ASN_OCTET_STR, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 27}},
#define   DOT1AGCFMMEPTRANSMITLBMDESTMEPID  59
	{(u_char) DOT1AGCFMMEPTRANSMITLBMDESTMEPID, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 28}},
#define   DOT1AGCFMMEPTRANSMITLBMDESTISMEPID  60
	{(u_char) DOT1AGCFMMEPTRANSMITLBMDESTISMEPID, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 29}},
#define   DOT1AGCFMMEPTRANSMITLBMMESSAGES  61
	{(u_char) DOT1AGCFMMEPTRANSMITLBMMESSAGES, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 30}},
#define   DOT1AGCFMMEPTRANSMITLBMDATATLV  62
	{(u_char) DOT1AGCFMMEPTRANSMITLBMDATATLV, ASN_OCTET_STR, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 31}},
#define   DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY  63
	{(u_char) DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 32}},
#define   DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE  64
	{(u_char) DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 33}},
#define   DOT1AGCFMMEPTRANSMITLBMRESULTOK  65
	{(u_char) DOT1AGCFMMEPTRANSMITLBMRESULTOK, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 34}},
#define   DOT1AGCFMMEPTRANSMITLBMSEQNUMBER  66
	{(u_char) DOT1AGCFMMEPTRANSMITLBMSEQNUMBER, ASN_UNSIGNED, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 35}},
#define   DOT1AGCFMMEPTRANSMITLTMSTATUS  67
	{(u_char) DOT1AGCFMMEPTRANSMITLTMSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 36}},
#define   DOT1AGCFMMEPTRANSMITLTMFLAGS  68
	{(u_char) DOT1AGCFMMEPTRANSMITLTMFLAGS, ASN_OCTET_STR, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 37}},
#define   DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS  69
	{(u_char) DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS, ASN_OCTET_STR, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 38}},
#define   DOT1AGCFMMEPTRANSMITLTMTARGETMEPID  70
	{(u_char) DOT1AGCFMMEPTRANSMITLTMTARGETMEPID, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 39}},
#define   DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID  71
	{(u_char) DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 40}},
#define   DOT1AGCFMMEPTRANSMITLTMTTL  72
	{(u_char) DOT1AGCFMMEPTRANSMITLTMTTL, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 41}},
#define   DOT1AGCFMMEPTRANSMITLTMRESULT  73
	{(u_char) DOT1AGCFMMEPTRANSMITLTMRESULT, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 42}},
#define   DOT1AGCFMMEPTRANSMITLTMSEQNUMBER  74
	{(u_char) DOT1AGCFMMEPTRANSMITLTMSEQNUMBER, ASN_UNSIGNED, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 43}},
#define   DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER  75
	{(u_char) DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER, ASN_OCTET_STR, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 44}},
#define   DOT1AGCFMMEPROWSTATUS  76
	{(u_char) DOT1AGCFMMEPROWSTATUS, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 45}},
#define   DOT1AGCFMMEPPBBTECANREPORTPBBTEPRESENCE  77
	{(u_char) DOT1AGCFMMEPPBBTECANREPORTPBBTEPRESENCE, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 46}},
#define   DOT1AGCFMMEPPBBTETRAFFICMISMATCHDEFECT  78
	{(u_char) DOT1AGCFMMEPPBBTETRAFFICMISMATCHDEFECT, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 47}},
#define   DOT1AGCFMMEPPBBTRANSMITLBMLTMREVERSEVID  79
	{(u_char) DOT1AGCFMMEPPBBTRANSMITLBMLTMREVERSEVID, ASN_UNSIGNED, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 48}},
#define   DOT1AGCFMMEPPBBTEMISMATCHALARM  80
	{(u_char) DOT1AGCFMMEPPBBTEMISMATCHALARM, ASN_INTEGER, RWRITE, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 49}},
#define   DOT1AGCFMMEPPBBTELOCALMISMATCHDEFECT  81
	{(u_char) DOT1AGCFMMEPPBBTELOCALMISMATCHDEFECT, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 50}},
#define   DOT1AGCFMMEPPBBTEMISMATCHSINCERESET  82
	{(u_char) DOT1AGCFMMEPPBBTEMISMATCHSINCERESET, ASN_INTEGER, RONLY, var_dot1agCfmMepTable, 5, {1, 7, 1, 1, 51}},
#define   DOT1AGCFMLTRTTL       83
	{(u_char) DOT1AGCFMLTRTTL, ASN_UNSIGNED, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 3}},
#define   DOT1AGCFMLTRFORWARDED  84
	{(u_char) DOT1AGCFMLTRFORWARDED, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 4}},
#define   DOT1AGCFMLTRTERMINALMEP  85
	{(u_char) DOT1AGCFMLTRTERMINALMEP, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 5}},
#define   DOT1AGCFMLTRLASTEGRESSIDENTIFIER  86
	{(u_char) DOT1AGCFMLTRLASTEGRESSIDENTIFIER, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 6}},
#define   DOT1AGCFMLTRNEXTEGRESSIDENTIFIER  87
	{(u_char) DOT1AGCFMLTRNEXTEGRESSIDENTIFIER, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 7}},
#define   DOT1AGCFMLTRRELAY     88
	{(u_char) DOT1AGCFMLTRRELAY, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 8}},
#define   DOT1AGCFMLTRCHASSISIDSUBTYPE  89
	{(u_char) DOT1AGCFMLTRCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 9}},
#define   DOT1AGCFMLTRCHASSISID  90
	{(u_char) DOT1AGCFMLTRCHASSISID, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 10}},
#define   DOT1AGCFMLTRMANADDRESSDOMAIN  91
	{(u_char) DOT1AGCFMLTRMANADDRESSDOMAIN, ASN_OBJECT_ID, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 11}},
#define   DOT1AGCFMLTRMANADDRESS  92
	{(u_char) DOT1AGCFMLTRMANADDRESS, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 12}},
#define   DOT1AGCFMLTRINGRESS   93
	{(u_char) DOT1AGCFMLTRINGRESS, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 13}},
#define   DOT1AGCFMLTRINGRESSMAC  94
	{(u_char) DOT1AGCFMLTRINGRESSMAC, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 14}},
#define   DOT1AGCFMLTRINGRESSPORTIDSUBTYPE  95
	{(u_char) DOT1AGCFMLTRINGRESSPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 15}},
#define   DOT1AGCFMLTRINGRESSPORTID  96
	{(u_char) DOT1AGCFMLTRINGRESSPORTID, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 16}},
#define   DOT1AGCFMLTREGRESS    97
	{(u_char) DOT1AGCFMLTREGRESS, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 17}},
#define   DOT1AGCFMLTREGRESSMAC  98
	{(u_char) DOT1AGCFMLTREGRESSMAC, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 18}},
#define   DOT1AGCFMLTREGRESSPORTIDSUBTYPE  99
	{(u_char) DOT1AGCFMLTREGRESSPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 19}},
#define   DOT1AGCFMLTREGRESSPORTID  100
	{(u_char) DOT1AGCFMLTREGRESSPORTID, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 20}},
#define   DOT1AGCFMLTRORGANIZATIONSPECIFICTLV  101
	{(u_char) DOT1AGCFMLTRORGANIZATIONSPECIFICTLV, ASN_OCTET_STR, RONLY, var_dot1agCfmLtrTable, 5, {1, 7, 2, 1, 21}},
#define   DOT1AGCFMMEPDBRMEPSTATE  102
	{(u_char) DOT1AGCFMMEPDBRMEPSTATE, ASN_INTEGER, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 2}},
#define   DOT1AGCFMMEPDBRMEPFAILEDOKTIME  103
	{(u_char) DOT1AGCFMMEPDBRMEPFAILEDOKTIME, ASN_TIMETICKS, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 3}},
#define   DOT1AGCFMMEPDBMACADDRESS  104
	{(u_char) DOT1AGCFMMEPDBMACADDRESS, ASN_OCTET_STR, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 4}},
#define   DOT1AGCFMMEPDBRDI     105
	{(u_char) DOT1AGCFMMEPDBRDI, ASN_INTEGER, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 5}},
#define   DOT1AGCFMMEPDBPORTSTATUSTLV  106
	{(u_char) DOT1AGCFMMEPDBPORTSTATUSTLV, ASN_INTEGER, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 6}},
#define   DOT1AGCFMMEPDBINTERFACESTATUSTLV  107
	{(u_char) DOT1AGCFMMEPDBINTERFACESTATUSTLV, ASN_INTEGER, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 7}},
#define   DOT1AGCFMMEPDBCHASSISIDSUBTYPE  108
	{(u_char) DOT1AGCFMMEPDBCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 8}},
#define   DOT1AGCFMMEPDBCHASSISID  109
	{(u_char) DOT1AGCFMMEPDBCHASSISID, ASN_OCTET_STR, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 9}},
#define   DOT1AGCFMMEPDBMANADDRESSDOMAIN  110
	{(u_char) DOT1AGCFMMEPDBMANADDRESSDOMAIN, ASN_OBJECT_ID, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 10}},
#define   DOT1AGCFMMEPDBMANADDRESS  111
	{(u_char) DOT1AGCFMMEPDBMANADDRESS, ASN_OCTET_STR, RONLY, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 11}},
#define   DOT1AGCFMMEPDBRMEPISACTIVE  112
	{(u_char) DOT1AGCFMMEPDBRMEPISACTIVE, ASN_INTEGER, RWRITE, var_dot1agCfmMepDbTable, 5, {1, 7, 3, 1, 12}},
};

/* (L = length of the oidsuffix) */
struct ieee8021CfmMib_data *ieee8021CfmMibStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *dot1agCfmStackTableStorage = NULL;
struct header_complex_index *dot1agCfmDefaultMdTableStorage = NULL;
struct header_complex_index *dot1agCfmVlanTableStorage = NULL;
struct header_complex_index *dot1agCfmConfigErrorListTableStorage = NULL;
struct header_complex_index *dot1agCfmMdTableStorage = NULL;
struct header_complex_index *dot1agCfmMaNetTableStorage = NULL;
struct header_complex_index *dot1agCfmMaCompTableStorage = NULL;
struct header_complex_index *dot1agCfmMaMepListTableStorage = NULL;
struct header_complex_index *dot1agCfmMepTableStorage = NULL;
struct header_complex_index *dot1agCfmLtrTableStorage = NULL;
struct header_complex_index *dot1agCfmMepDbTableStorage = NULL;

void (*ieee8021CfmMibold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void ieee8021CfmMib_loop_handler(int);
void ieee8021CfmMib_fd_handler(int, void *);

/**
 * @fn void init_ieee8021CfmMib(void)
 * @brief ieee8021CfmMib initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (ieee8021CfmMib_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_ieee8021CfmMib(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("ieee8021CfmMib", "init_ieee8021CfmMib: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("ieee8021CfmMib", ieee8021CfmMib_variables, variable7, ieee8021CfmMib_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_ieee8021CfmMib, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("ieee8021CfmMib", parse_ieee8021CfmMib, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmStackTable", parse_dot1agCfmStackTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmDefaultMdTable", parse_dot1agCfmDefaultMdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmVlanTable", parse_dot1agCfmVlanTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmConfigErrorListTable", parse_dot1agCfmConfigErrorListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMdTable", parse_dot1agCfmMdTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMaNetTable", parse_dot1agCfmMaNetTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMaCompTable", parse_dot1agCfmMaCompTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMaMepListTable", parse_dot1agCfmMaMepListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMepTable", parse_dot1agCfmMepTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmLtrTable", parse_dot1agCfmLtrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("dot1agCfmMepDbTable", parse_dot1agCfmMepDbTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_ieee8021CfmMib, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmStackTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmDefaultMdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmVlanTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmConfigErrorListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMdTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMaNetTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMaCompTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMaMepListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMepTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmLtrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_dot1agCfmMepDbTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, ieee8021CfmMib_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, ieee8021CfmMib_fd_handler, (void *) 1);
	}
	ieee8021CfmMibold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &ieee8021CfmMib_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/**
 * @fn void deinit_ieee8021CfmMib(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (ieee8021CfmMib_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_ieee8021CfmMib(void)
{
	DEBUGMSGTL(("ieee8021CfmMib", "deinit_ieee8021CfmMib: deinitializating...  "));
	external_signal_handler[SIGCHLD] = ieee8021CfmMibold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(ieee8021CfmMib_variables_oid, sizeof(ieee8021CfmMib_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("ieee8021CfmMib");
	snmpd_unregister_config_handler("dot1agCfmStackTable");
	snmpd_unregister_config_handler("dot1agCfmDefaultMdTable");
	snmpd_unregister_config_handler("dot1agCfmVlanTable");
	snmpd_unregister_config_handler("dot1agCfmConfigErrorListTable");
	snmpd_unregister_config_handler("dot1agCfmMdTable");
	snmpd_unregister_config_handler("dot1agCfmMaNetTable");
	snmpd_unregister_config_handler("dot1agCfmMaCompTable");
	snmpd_unregister_config_handler("dot1agCfmMaMepListTable");
	snmpd_unregister_config_handler("dot1agCfmMepTable");
	snmpd_unregister_config_handler("dot1agCfmLtrTable");
	snmpd_unregister_config_handler("dot1agCfmMepDbTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

int
term_ieee8021CfmMib(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("ieee8021CfmMib", "term_ieee8021CfmMib: terminating...  "));
	deinit_ieee8021CfmMib();
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return 0;
}

/**
 * @fn struct ieee8021CfmMib_data *ieee8021CfmMib_create(void)
 * @brief create a fresh data structure representing scalars in ieee8021CfmMib.
 *
 * Creates a new ieee8021CfmMib_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in ieee8021CfmMib.
 */
struct ieee8021CfmMib_data *
ieee8021CfmMib_create(void)
{
	struct ieee8021CfmMib_data *StorageNew = SNMP_MALLOC_STRUCT(ieee8021CfmMib_data);

	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->dot1agCfmDefaultMdDefLevel = 0;
		StorageNew->dot1agCfmDefaultMdDefMhfCreation = DOT1AGCFMDEFAULTMDDEFMHFCREATION_DEFMHFNONE;
		StorageNew->dot1agCfmDefaultMdDefIdPermission = DOT1AGCFMDEFAULTMDDEFIDPERMISSION_SENDIDNONE;
		StorageNew->dot1agCfmMdTableNextIndex = 0;

	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	ieee8021CfmMib_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct ieee8021CfmMib_data *ieee8021CfmMib_duplicate(struct ieee8021CfmMib_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct ieee8021CfmMib_data *
ieee8021CfmMib_duplicate(struct ieee8021CfmMib_data *thedata)
{
	struct ieee8021CfmMib_data *StorageNew = SNMP_MALLOC_STRUCT(ieee8021CfmMib_data);

	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmDefaultMdDefLevel = thedata->dot1agCfmDefaultMdDefLevel;
		StorageNew->dot1agCfmDefaultMdDefMhfCreation = thedata->dot1agCfmDefaultMdDefMhfCreation;
		StorageNew->dot1agCfmDefaultMdDefIdPermission = thedata->dot1agCfmDefaultMdDefIdPermission;
		StorageNew->dot1agCfmMdTableNextIndex = thedata->dot1agCfmMdTableNextIndex;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	ieee8021CfmMib_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int ieee8021CfmMib_destroy(struct ieee8021CfmMib_data **thedata)
 * @param thedata pointer to the data structure in ieee8021CfmMib.
 * @brief delete a scalars structure from ieee8021CfmMib.
 *
 * Frees scalars that were previously removed from ieee8021CfmMib.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
ieee8021CfmMib_destroy(struct ieee8021CfmMib_data **thedata)
{
	struct ieee8021CfmMib_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int ieee8021CfmMib_add(struct ieee8021CfmMib_data *thedata)
 * @param thedata the structure representing ieee8021CfmMib scalars.
 * @brief adds node to the ieee8021CfmMib scalar data set.
 *
 * Adds a scalar structure to the ieee8021CfmMib data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
ieee8021CfmMib_add(struct ieee8021CfmMib_data *thedata)
{
	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_add: adding data...  "));
	if (thedata)
		ieee8021CfmMibStorage = thedata;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_ieee8021CfmMib(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for ieee8021CfmMib entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case ieee8021CfmMib).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_ieee8021CfmMib(const char *token, char *line)
{
	size_t tmpsize;
	struct ieee8021CfmMib_data *StorageTmp = ieee8021CfmMib_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_ieee8021CfmMib: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdDefLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdDefMhfCreation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdDefIdPermission, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdTableNextIndex, &tmpsize);
	ieee8021CfmMib_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_ieee8021CfmMib(): stores .conf file entries needed to configure the mib.
 */
int
store_ieee8021CfmMib(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct ieee8021CfmMib_data *StorageTmp;

	DEBUGMSGTL(("ieee8021CfmMib", "store_ieee8021CfmMib: storing data...  "));
	refresh_ieee8021CfmMib(1);
	if ((StorageTmp = ieee8021CfmMibStorage) == NULL) {
		DEBUGMSGTL(("ieee8021CfmMib", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "ieee8021CfmMib ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdDefLevel, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdDefMhfCreation, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdDefIdPermission, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdTableNextIndex, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_ieee8021CfmMib()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	ieee8021CfmMib_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_ieee8021CfmMib(struct 
 * @fn void revert_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_ieee8021CfmMib(struct ieee8021CfmMib_data *StorageTmp, struct ieee8021CfmMib_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_ieee8021CfmMib(StorageOld, NULL);
}

/**
 * @fn void refresh_ieee8021CfmMib(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of ieee8021CfmMib.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_ieee8021CfmMib(int force)
{
	if (ieee8021CfmMibStorage == NULL) {
		struct ieee8021CfmMib_data *StorageNew;

		if ((StorageNew = ieee8021CfmMib_create()) == NULL)
			return;
		ieee8021CfmMibStorage = StorageNew;
		ieee8021CfmMib_refresh = 1;
	}
	if (!force && ieee8021CfmMib_refresh == 0)
		return;
	DEBUGMSGTL(("ieee8021CfmMib", "refresh_ieee8021CfmMib: refreshing...  "));
	/* XXX: Update scalars as required here... */
	ieee8021CfmMib_refresh = 0;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/**
 * @fn u_char * var_ieee8021CfmMib(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in ieee8021CfmMib.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_ieee8021CfmMib(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct ieee8021CfmMib_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_ieee8021CfmMib: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_ieee8021CfmMib(0);
	if ((StorageTmp = ieee8021CfmMibStorage) == NULL) {
		DEBUGMSGTL(("ieee8021CfmMib", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMDEFAULTMDDEFLEVEL:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdDefLevel;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdDefLevel);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdDefLevel;
		break;
	case (u_char) DOT1AGCFMDEFAULTMDDEFMHFCREATION:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdDefMhfCreation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdDefMhfCreation);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdDefMhfCreation;
		break;
	case (u_char) DOT1AGCFMDEFAULTMDDEFIDPERMISSION:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdDefIdPermission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdDefIdPermission);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdDefIdPermission;
		break;
	case (u_char) DOT1AGCFMMDTABLENEXTINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdTableNextIndex);
		rval = (u_char *) &StorageTmp->dot1agCfmMdTableNextIndex;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("ieee8021CfmMib", "found.\n"));
	else
		DEBUGMSGTL(("ieee8021CfmMib", "not found.\n"));
	return (rval);
}

/**
 * @fn struct dot1agCfmStackTable_data *dot1agCfmStackTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmStackTable table.
 *
 * Creates a new dot1agCfmStackTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmStackTable_data *
dot1agCfmStackTable_create(void)
{
	struct dot1agCfmStackTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmStackTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmStackTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmStackMdIndex = 0;
		StorageNew->dot1agCfmStackMaIndex = 0;
		StorageNew->dot1agCfmStackMepId = 0;
		if ((StorageNew->dot1agCfmStackMacAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmStackMacAddressLen = 0;
		StorageNew->dot1agCfmStackMacAddress[StorageNew->dot1agCfmStackMacAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmStackTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmStackTable_data *dot1agCfmStackTable_duplicate(struct dot1agCfmStackTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmStackTable_data *
dot1agCfmStackTable_duplicate(struct dot1agCfmStackTable_data *thedata)
{
	struct dot1agCfmStackTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmStackTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmStackTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmStackTable_id = thedata->dot1agCfmStackTable_id;
		StorageNew->dot1agCfmStackifIndex = thedata->dot1agCfmStackifIndex;
		StorageNew->dot1agCfmStackVlanIdOrNone = thedata->dot1agCfmStackVlanIdOrNone;
		StorageNew->dot1agCfmStackMdLevel = thedata->dot1agCfmStackMdLevel;
		StorageNew->dot1agCfmStackDirection = thedata->dot1agCfmStackDirection;
		StorageNew->dot1agCfmStackMdIndex = thedata->dot1agCfmStackMdIndex;
		StorageNew->dot1agCfmStackMaIndex = thedata->dot1agCfmStackMaIndex;
		StorageNew->dot1agCfmStackMepId = thedata->dot1agCfmStackMepId;
		if (!(StorageNew->dot1agCfmStackMacAddress = malloc(thedata->dot1agCfmStackMacAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmStackMacAddress, thedata->dot1agCfmStackMacAddress, thedata->dot1agCfmStackMacAddressLen);
		StorageNew->dot1agCfmStackMacAddressLen = thedata->dot1agCfmStackMacAddressLen;
		StorageNew->dot1agCfmStackMacAddress[StorageNew->dot1agCfmStackMacAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmStackTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmStackTable_destroy(struct dot1agCfmStackTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmStackTable_destroy(struct dot1agCfmStackTable_data **thedata)
{
	struct dot1agCfmStackTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmStackTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmStackMacAddress);
		StorageDel->dot1agCfmStackMacAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmStackTable_add(struct dot1agCfmStackTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmStackTable table data set.
 *
 * Adds a table row structure to the dot1agCfmStackTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmStackTable_add(struct dot1agCfmStackTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmStackTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmStackifIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmStackifIndex, sizeof(thedata->dot1agCfmStackifIndex));
		/* dot1agCfmStackVlanIdOrNone */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmStackVlanIdOrNone, sizeof(thedata->dot1agCfmStackVlanIdOrNone));
		/* dot1agCfmStackMdLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmStackMdLevel, sizeof(thedata->dot1agCfmStackMdLevel));
		/* dot1agCfmStackDirection */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmStackDirection, sizeof(thedata->dot1agCfmStackDirection));
		header_complex_add_data(&dot1agCfmStackTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmStackTable_del(struct dot1agCfmStackTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmStackTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmStackTable_del(struct dot1agCfmStackTable_data *thedata)
{
	struct dot1agCfmStackTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmStackTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmStackTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmStackTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmStackTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmStackTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmStackTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmStackTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmStackTable_data *StorageTmp = dot1agCfmStackTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmStackTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmStackifIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmStackVlanIdOrNone, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmStackMdLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmStackDirection, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmStackMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmStackMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmStackMepId, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmStackMacAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmStackMacAddress, &StorageTmp->dot1agCfmStackMacAddressLen);
	if (StorageTmp->dot1agCfmStackMacAddress == NULL) {
		config_perror("invalid specification for dot1agCfmStackMacAddress");
		return;
	}
	dot1agCfmStackTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmStackTable(): store configuraiton file for dot1agCfmStackTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmStackTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmStackTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmStackTable: storing data...  "));
	refresh_dot1agCfmStackTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmStackTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmStackTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmStackTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmStackifIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmStackVlanIdOrNone, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmStackMdLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmStackDirection, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmStackMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmStackMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmStackMepId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmStackMacAddress, &StorageTmp->dot1agCfmStackMacAddressLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmDefaultMdTable_data *dot1agCfmDefaultMdTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmDefaultMdTable table.
 *
 * Creates a new dot1agCfmDefaultMdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmDefaultMdTable_data *
dot1agCfmDefaultMdTable_create(void)
{
	struct dot1agCfmDefaultMdTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmDefaultMdTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmDefaultMdTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmDefaultMdStatus = 0;
		StorageNew->dot1agCfmDefaultMdLevel = -1;
		StorageNew->dot1agCfmDefaultMdMhfCreation = DOT1AGCFMDEFAULTMDMHFCREATION_DEFMHFDEFER;
		StorageNew->dot1agCfmDefaultMdIdPermission = DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDDEFER;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmDefaultMdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmDefaultMdTable_data *dot1agCfmDefaultMdTable_duplicate(struct dot1agCfmDefaultMdTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmDefaultMdTable_data *
dot1agCfmDefaultMdTable_duplicate(struct dot1agCfmDefaultMdTable_data *thedata)
{
	struct dot1agCfmDefaultMdTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmDefaultMdTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmDefaultMdTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmDefaultMdTable_id = thedata->dot1agCfmDefaultMdTable_id;
		StorageNew->dot1agCfmDefaultMdComponentId = thedata->dot1agCfmDefaultMdComponentId;
		StorageNew->dot1agCfmDefaultMdPrimaryVid = thedata->dot1agCfmDefaultMdPrimaryVid;
		StorageNew->dot1agCfmDefaultMdStatus = thedata->dot1agCfmDefaultMdStatus;
		StorageNew->dot1agCfmDefaultMdLevel = thedata->dot1agCfmDefaultMdLevel;
		StorageNew->dot1agCfmDefaultMdMhfCreation = thedata->dot1agCfmDefaultMdMhfCreation;
		StorageNew->dot1agCfmDefaultMdIdPermission = thedata->dot1agCfmDefaultMdIdPermission;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmDefaultMdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmDefaultMdTable_destroy(struct dot1agCfmDefaultMdTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmDefaultMdTable_destroy(struct dot1agCfmDefaultMdTable_data **thedata)
{
	struct dot1agCfmDefaultMdTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmDefaultMdTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmDefaultMdTable_add(struct dot1agCfmDefaultMdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmDefaultMdTable table data set.
 *
 * Adds a table row structure to the dot1agCfmDefaultMdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmDefaultMdTable_add(struct dot1agCfmDefaultMdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmDefaultMdTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmDefaultMdComponentId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmDefaultMdComponentId, sizeof(thedata->dot1agCfmDefaultMdComponentId));
		/* dot1agCfmDefaultMdPrimaryVid */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmDefaultMdPrimaryVid, sizeof(thedata->dot1agCfmDefaultMdPrimaryVid));
		header_complex_add_data(&dot1agCfmDefaultMdTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmDefaultMdTable_del(struct dot1agCfmDefaultMdTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmDefaultMdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmDefaultMdTable_del(struct dot1agCfmDefaultMdTable_data *thedata)
{
	struct dot1agCfmDefaultMdTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmDefaultMdTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmDefaultMdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmDefaultMdTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmDefaultMdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmDefaultMdTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmDefaultMdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmDefaultMdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmDefaultMdTable_data *StorageTmp = dot1agCfmDefaultMdTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmDefaultMdTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmDefaultMdComponentId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdPrimaryVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdMhfCreation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmDefaultMdIdPermission, &tmpsize);
	dot1agCfmDefaultMdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmDefaultMdTable(): store configuraiton file for dot1agCfmDefaultMdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmDefaultMdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmDefaultMdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmDefaultMdTable: storing data...  "));
	refresh_dot1agCfmDefaultMdTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmDefaultMdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmDefaultMdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmDefaultMdTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmDefaultMdComponentId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdPrimaryVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdMhfCreation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmDefaultMdIdPermission, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmVlanTable_data *dot1agCfmVlanTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmVlanTable table.
 *
 * Creates a new dot1agCfmVlanTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmVlanTable_data *
dot1agCfmVlanTable_create(void)
{
	struct dot1agCfmVlanTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmVlanTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmVlanTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmVlanPrimaryVid = 0;
		StorageNew->dot1agCfmVlanRowStatus = 0;
		StorageNew->dot1agCfmVlanRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmVlanTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmVlanTable_data *dot1agCfmVlanTable_duplicate(struct dot1agCfmVlanTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmVlanTable_data *
dot1agCfmVlanTable_duplicate(struct dot1agCfmVlanTable_data *thedata)
{
	struct dot1agCfmVlanTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmVlanTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmVlanTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmVlanTable_id = thedata->dot1agCfmVlanTable_id;
		StorageNew->dot1agCfmVlanComponentId = thedata->dot1agCfmVlanComponentId;
		StorageNew->dot1agCfmVlanVid = thedata->dot1agCfmVlanVid;
		StorageNew->dot1agCfmVlanPrimaryVid = thedata->dot1agCfmVlanPrimaryVid;
		StorageNew->dot1agCfmVlanRowStatus = thedata->dot1agCfmVlanRowStatus;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmVlanTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmVlanTable_destroy(struct dot1agCfmVlanTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmVlanTable_destroy(struct dot1agCfmVlanTable_data **thedata)
{
	struct dot1agCfmVlanTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmVlanTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmVlanTable_add(struct dot1agCfmVlanTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmVlanTable table data set.
 *
 * Adds a table row structure to the dot1agCfmVlanTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmVlanTable_add(struct dot1agCfmVlanTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmVlanTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmVlanComponentId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmVlanComponentId, sizeof(thedata->dot1agCfmVlanComponentId));
		/* dot1agCfmVlanVid */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmVlanVid, sizeof(thedata->dot1agCfmVlanVid));
		header_complex_add_data(&dot1agCfmVlanTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmVlanTable_del(struct dot1agCfmVlanTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmVlanTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmVlanTable_del(struct dot1agCfmVlanTable_data *thedata)
{
	struct dot1agCfmVlanTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmVlanTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmVlanTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmVlanTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmVlanTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmVlanTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmVlanTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmVlanTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmVlanTable_data *StorageTmp = dot1agCfmVlanTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmVlanTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmVlanComponentId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmVlanVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmVlanPrimaryVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmVlanRowStatus, &tmpsize);
	dot1agCfmVlanTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmVlanTable(): store configuraiton file for dot1agCfmVlanTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmVlanTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmVlanTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmVlanTable: storing data...  "));
	refresh_dot1agCfmVlanTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmVlanTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmVlanTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmVlanTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmVlanComponentId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmVlanVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmVlanPrimaryVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmVlanRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmConfigErrorListTable_data *dot1agCfmConfigErrorListTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmConfigErrorListTable table.
 *
 * Creates a new dot1agCfmConfigErrorListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmConfigErrorListTable_data *
dot1agCfmConfigErrorListTable_create(void)
{
	struct dot1agCfmConfigErrorListTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmConfigErrorListTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmConfigErrorListTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if (memdup((u_char **) &StorageNew->dot1agCfmConfigErrorListErrorType, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->dot1agCfmConfigErrorListErrorTypeLen = 1;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmConfigErrorListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmConfigErrorListTable_data *dot1agCfmConfigErrorListTable_duplicate(struct dot1agCfmConfigErrorListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmConfigErrorListTable_data *
dot1agCfmConfigErrorListTable_duplicate(struct dot1agCfmConfigErrorListTable_data *thedata)
{
	struct dot1agCfmConfigErrorListTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmConfigErrorListTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmConfigErrorListTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmConfigErrorListTable_id = thedata->dot1agCfmConfigErrorListTable_id;
		StorageNew->dot1agCfmConfigErrorListVid = thedata->dot1agCfmConfigErrorListVid;
		StorageNew->dot1agCfmConfigErrorListIfIndex = thedata->dot1agCfmConfigErrorListIfIndex;
		if (!(StorageNew->dot1agCfmConfigErrorListErrorType = malloc(thedata->dot1agCfmConfigErrorListErrorTypeLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmConfigErrorListErrorType, thedata->dot1agCfmConfigErrorListErrorType, thedata->dot1agCfmConfigErrorListErrorTypeLen);
		StorageNew->dot1agCfmConfigErrorListErrorTypeLen = thedata->dot1agCfmConfigErrorListErrorTypeLen;
		StorageNew->dot1agCfmConfigErrorListErrorType[StorageNew->dot1agCfmConfigErrorListErrorTypeLen] = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmConfigErrorListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmConfigErrorListTable_destroy(struct dot1agCfmConfigErrorListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmConfigErrorListTable_destroy(struct dot1agCfmConfigErrorListTable_data **thedata)
{
	struct dot1agCfmConfigErrorListTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmConfigErrorListTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmConfigErrorListErrorType);
		StorageDel->dot1agCfmConfigErrorListErrorTypeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmConfigErrorListTable_add(struct dot1agCfmConfigErrorListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmConfigErrorListTable table data set.
 *
 * Adds a table row structure to the dot1agCfmConfigErrorListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmConfigErrorListTable_add(struct dot1agCfmConfigErrorListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmConfigErrorListTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmConfigErrorListVid */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmConfigErrorListVid, sizeof(thedata->dot1agCfmConfigErrorListVid));
		/* dot1agCfmConfigErrorListIfIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->dot1agCfmConfigErrorListIfIndex, sizeof(thedata->dot1agCfmConfigErrorListIfIndex));
		header_complex_add_data(&dot1agCfmConfigErrorListTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmConfigErrorListTable_del(struct dot1agCfmConfigErrorListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmConfigErrorListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmConfigErrorListTable_del(struct dot1agCfmConfigErrorListTable_data *thedata)
{
	struct dot1agCfmConfigErrorListTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmConfigErrorListTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmConfigErrorListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmConfigErrorListTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmConfigErrorListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmConfigErrorListTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmConfigErrorListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmConfigErrorListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmConfigErrorListTable_data *StorageTmp = dot1agCfmConfigErrorListTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmConfigErrorListTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmConfigErrorListVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmConfigErrorListIfIndex, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmConfigErrorListErrorType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmConfigErrorListErrorType, &StorageTmp->dot1agCfmConfigErrorListErrorTypeLen);
	if (StorageTmp->dot1agCfmConfigErrorListErrorType == NULL) {
		config_perror("invalid specification for dot1agCfmConfigErrorListErrorType");
		return;
	}
	dot1agCfmConfigErrorListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmConfigErrorListTable(): store configuraiton file for dot1agCfmConfigErrorListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmConfigErrorListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmConfigErrorListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmConfigErrorListTable: storing data...  "));
	refresh_dot1agCfmConfigErrorListTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmConfigErrorListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmConfigErrorListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmConfigErrorListTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmConfigErrorListVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmConfigErrorListIfIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmConfigErrorListErrorType, &StorageTmp->dot1agCfmConfigErrorListErrorTypeLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMdTable_data *dot1agCfmMdTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMdTable table.
 *
 * Creates a new dot1agCfmMdTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMdTable_data *
dot1agCfmMdTable_create(void)
{
	struct dot1agCfmMdTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMdTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMdTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdFormat = DOT1AGCFMMDFORMAT_CHARSTRING;
		if ((StorageNew->dot1agCfmMdName = (uint8_t *) strdup("DEFAULT")) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMdNameLen = strlen("DEFAULT");
		StorageNew->dot1agCfmMdMdLevel = 0;
		StorageNew->dot1agCfmMdMhfCreation = DOT1AGCFMMDMHFCREATION_DEFMHFNONE;
		StorageNew->dot1agCfmMdMhfIdPermission = DOT1AGCFMMDMHFIDPERMISSION_SENDIDNONE;
		StorageNew->dot1agCfmMdMaNextIndex = 0;
		StorageNew->dot1agCfmMdRowStatus = 0;
		StorageNew->dot1agCfmMdRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMdTable_data *dot1agCfmMdTable_duplicate(struct dot1agCfmMdTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMdTable_data *
dot1agCfmMdTable_duplicate(struct dot1agCfmMdTable_data *thedata)
{
	struct dot1agCfmMdTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMdTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMdTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMdTable_id = thedata->dot1agCfmMdTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMdFormat = thedata->dot1agCfmMdFormat;
		if (!(StorageNew->dot1agCfmMdName = malloc(thedata->dot1agCfmMdNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMdName, thedata->dot1agCfmMdName, thedata->dot1agCfmMdNameLen);
		StorageNew->dot1agCfmMdNameLen = thedata->dot1agCfmMdNameLen;
		StorageNew->dot1agCfmMdName[StorageNew->dot1agCfmMdNameLen] = 0;
		StorageNew->dot1agCfmMdMdLevel = thedata->dot1agCfmMdMdLevel;
		StorageNew->dot1agCfmMdMhfCreation = thedata->dot1agCfmMdMhfCreation;
		StorageNew->dot1agCfmMdMhfIdPermission = thedata->dot1agCfmMdMhfIdPermission;
		StorageNew->dot1agCfmMdMaNextIndex = thedata->dot1agCfmMdMaNextIndex;
		StorageNew->dot1agCfmMdRowStatus = thedata->dot1agCfmMdRowStatus;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMdTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMdTable_destroy(struct dot1agCfmMdTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMdTable_destroy(struct dot1agCfmMdTable_data **thedata)
{
	struct dot1agCfmMdTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMdTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmMdName);
		StorageDel->dot1agCfmMdNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMdTable_add(struct dot1agCfmMdTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMdTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMdTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMdTable_add(struct dot1agCfmMdTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMdTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		header_complex_add_data(&dot1agCfmMdTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMdTable_del(struct dot1agCfmMdTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMdTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMdTable_del(struct dot1agCfmMdTable_data *thedata)
{
	struct dot1agCfmMdTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMdTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMdTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMdTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMdTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMdTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMdTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMdTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMdTable_data *StorageTmp = dot1agCfmMdTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMdTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMdFormat, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMdName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMdName, &StorageTmp->dot1agCfmMdNameLen);
	if (StorageTmp->dot1agCfmMdName == NULL) {
		config_perror("invalid specification for dot1agCfmMdName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMdMdLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMdMhfCreation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMdMhfIdPermission, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdMaNextIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMdRowStatus, &tmpsize);
	dot1agCfmMdTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMdTable(): store configuraiton file for dot1agCfmMdTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMdTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMdTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMdTable: storing data...  "));
	refresh_dot1agCfmMdTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMdTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMdTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMdTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMdFormat, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMdName, &StorageTmp->dot1agCfmMdNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMdMdLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMdMhfCreation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMdMhfIdPermission, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdMaNextIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMdRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMaNetTable_data *dot1agCfmMaNetTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMaNetTable table.
 *
 * Creates a new dot1agCfmMaNetTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMaNetTable_data *
dot1agCfmMaNetTable_create(void)
{
	struct dot1agCfmMaNetTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaNetTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaNetTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaNetFormat = 0;
		if ((StorageNew->dot1agCfmMaNetName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMaNetNameLen = 0;
		StorageNew->dot1agCfmMaNetName[StorageNew->dot1agCfmMaNetNameLen] = 0;
		StorageNew->dot1agCfmMaNetCcmInterval = DOT1AGCFMMANETCCMINTERVAL_INTERVAL1S;
		StorageNew->dot1agCfmMaNetRowStatus = 0;
		StorageNew->dot1agCfmMaNetRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMaNetTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMaNetTable_data *dot1agCfmMaNetTable_duplicate(struct dot1agCfmMaNetTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMaNetTable_data *
dot1agCfmMaNetTable_duplicate(struct dot1agCfmMaNetTable_data *thedata)
{
	struct dot1agCfmMaNetTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaNetTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaNetTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMaNetTable_id = thedata->dot1agCfmMaNetTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMaNetFormat = thedata->dot1agCfmMaNetFormat;
		if (!(StorageNew->dot1agCfmMaNetName = malloc(thedata->dot1agCfmMaNetNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMaNetName, thedata->dot1agCfmMaNetName, thedata->dot1agCfmMaNetNameLen);
		StorageNew->dot1agCfmMaNetNameLen = thedata->dot1agCfmMaNetNameLen;
		StorageNew->dot1agCfmMaNetName[StorageNew->dot1agCfmMaNetNameLen] = 0;
		StorageNew->dot1agCfmMaNetCcmInterval = thedata->dot1agCfmMaNetCcmInterval;
		StorageNew->dot1agCfmMaNetRowStatus = thedata->dot1agCfmMaNetRowStatus;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMaNetTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMaNetTable_destroy(struct dot1agCfmMaNetTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMaNetTable_destroy(struct dot1agCfmMaNetTable_data **thedata)
{
	struct dot1agCfmMaNetTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaNetTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmMaNetName);
		StorageDel->dot1agCfmMaNetNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaNetTable_add(struct dot1agCfmMaNetTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMaNetTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMaNetTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMaNetTable_add(struct dot1agCfmMaNetTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaNetTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		header_complex_add_data(&dot1agCfmMaNetTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaNetTable_del(struct dot1agCfmMaNetTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMaNetTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMaNetTable_del(struct dot1agCfmMaNetTable_data *thedata)
{
	struct dot1agCfmMaNetTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaNetTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMaNetTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMaNetTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMaNetTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMaNetTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMaNetTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMaNetTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMaNetTable_data *StorageTmp = dot1agCfmMaNetTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMaNetTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaNetFormat, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMaNetName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMaNetName, &StorageTmp->dot1agCfmMaNetNameLen);
	if (StorageTmp->dot1agCfmMaNetName == NULL) {
		config_perror("invalid specification for dot1agCfmMaNetName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaNetCcmInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaNetRowStatus, &tmpsize);
	dot1agCfmMaNetTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMaNetTable(): store configuraiton file for dot1agCfmMaNetTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMaNetTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMaNetTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMaNetTable: storing data...  "));
	refresh_dot1agCfmMaNetTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMaNetTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMaNetTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMaNetTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaNetFormat, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMaNetName, &StorageTmp->dot1agCfmMaNetNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaNetCcmInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaNetRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMaCompTable_data *dot1agCfmMaCompTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMaCompTable table.
 *
 * Creates a new dot1agCfmMaCompTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMaCompTable_data *
dot1agCfmMaCompTable_create(void)
{
	struct dot1agCfmMaCompTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaCompTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaCompTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaIndex = 0;
		StorageNew->dot1agCfmMaCompPrimaryVlanId = 0;
		StorageNew->dot1agCfmMaCompMhfCreation = DOT1AGCFMMACOMPMHFCREATION_DEFMHFDEFER;
		StorageNew->dot1agCfmMaCompIdPermission = DOT1AGCFMMACOMPIDPERMISSION_SENDIDDEFER;
		StorageNew->dot1agCfmMaCompNumberOfVids = 0;
		StorageNew->dot1agCfmMaCompRowStatus = 0;
		StorageNew->dot1agCfmMaCompRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMaCompTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMaCompTable_data *dot1agCfmMaCompTable_duplicate(struct dot1agCfmMaCompTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMaCompTable_data *
dot1agCfmMaCompTable_duplicate(struct dot1agCfmMaCompTable_data *thedata)
{
	struct dot1agCfmMaCompTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaCompTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaCompTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMaCompTable_id = thedata->dot1agCfmMaCompTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMaComponentId = thedata->dot1agCfmMaComponentId;
		StorageNew->dot1agCfmMaCompPrimaryVlanId = thedata->dot1agCfmMaCompPrimaryVlanId;
		StorageNew->dot1agCfmMaCompMhfCreation = thedata->dot1agCfmMaCompMhfCreation;
		StorageNew->dot1agCfmMaCompIdPermission = thedata->dot1agCfmMaCompIdPermission;
		StorageNew->dot1agCfmMaCompNumberOfVids = thedata->dot1agCfmMaCompNumberOfVids;
		StorageNew->dot1agCfmMaCompRowStatus = thedata->dot1agCfmMaCompRowStatus;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMaCompTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMaCompTable_destroy(struct dot1agCfmMaCompTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMaCompTable_destroy(struct dot1agCfmMaCompTable_data **thedata)
{
	struct dot1agCfmMaCompTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaCompTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaCompTable_add(struct dot1agCfmMaCompTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMaCompTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMaCompTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMaCompTable_add(struct dot1agCfmMaCompTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaCompTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		/* dot1agCfmMaComponentId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaComponentId, sizeof(thedata->dot1agCfmMaComponentId));
		header_complex_add_data(&dot1agCfmMaCompTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaCompTable_del(struct dot1agCfmMaCompTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMaCompTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMaCompTable_del(struct dot1agCfmMaCompTable_data *thedata)
{
	struct dot1agCfmMaCompTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaCompTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMaCompTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMaCompTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMaCompTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMaCompTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMaCompTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMaCompTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMaCompTable_data *StorageTmp = dot1agCfmMaCompTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMaCompTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaComponentId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaCompPrimaryVlanId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaCompMhfCreation, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaCompIdPermission, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaCompNumberOfVids, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaCompRowStatus, &tmpsize);
	dot1agCfmMaCompTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMaCompTable(): store configuraiton file for dot1agCfmMaCompTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMaCompTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMaCompTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMaCompTable: storing data...  "));
	refresh_dot1agCfmMaCompTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMaCompTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMaCompTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMaCompTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaComponentId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaCompPrimaryVlanId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaCompMhfCreation, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaCompIdPermission, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaCompNumberOfVids, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaCompRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMaMepListTable_data *dot1agCfmMaMepListTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMaMepListTable table.
 *
 * Creates a new dot1agCfmMaMepListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMaMepListTable_data *
dot1agCfmMaMepListTable_create(void)
{
	struct dot1agCfmMaMepListTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaMepListTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaMepListTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaIndex = 0;
		StorageNew->dot1agCfmMaMepListRowStatus = 0;
		StorageNew->dot1agCfmMaMepListRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMaMepListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMaMepListTable_data *dot1agCfmMaMepListTable_duplicate(struct dot1agCfmMaMepListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMaMepListTable_data *
dot1agCfmMaMepListTable_duplicate(struct dot1agCfmMaMepListTable_data *thedata)
{
	struct dot1agCfmMaMepListTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMaMepListTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaMepListTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMaMepListTable_id = thedata->dot1agCfmMaMepListTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMaMepListIdentifier = thedata->dot1agCfmMaMepListIdentifier;
		StorageNew->dot1agCfmMaMepListRowStatus = thedata->dot1agCfmMaMepListRowStatus;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMaMepListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMaMepListTable_destroy(struct dot1agCfmMaMepListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMaMepListTable_destroy(struct dot1agCfmMaMepListTable_data **thedata)
{
	struct dot1agCfmMaMepListTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaMepListTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaMepListTable_add(struct dot1agCfmMaMepListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMaMepListTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMaMepListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMaMepListTable_add(struct dot1agCfmMaMepListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaMepListTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		/* dot1agCfmMaMepListIdentifier */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaMepListIdentifier, sizeof(thedata->dot1agCfmMaMepListIdentifier));
		header_complex_add_data(&dot1agCfmMaMepListTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMaMepListTable_del(struct dot1agCfmMaMepListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMaMepListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMaMepListTable_del(struct dot1agCfmMaMepListTable_data *thedata)
{
	struct dot1agCfmMaMepListTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMaMepListTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMaMepListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMaMepListTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMaMepListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMaMepListTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMaMepListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMaMepListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMaMepListTable_data *StorageTmp = dot1agCfmMaMepListTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMaMepListTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaMepListIdentifier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMaMepListRowStatus, &tmpsize);
	dot1agCfmMaMepListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMaMepListTable(): store configuraiton file for dot1agCfmMaMepListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMaMepListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMaMepListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMaMepListTable: storing data...  "));
	refresh_dot1agCfmMaMepListTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMaMepListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMaMepListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMaMepListTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaMepListIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMaMepListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMepTable_data *dot1agCfmMepTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMepTable table.
 *
 * Creates a new dot1agCfmMepTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMepTable_data *
dot1agCfmMepTable_create(void)
{
	struct dot1agCfmMepTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMepTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaIndex = 0;
		StorageNew->dot1agCfmMepIfIndex = 0;
		StorageNew->dot1agCfmMepDirection = 0;
		StorageNew->dot1agCfmMepPrimaryVid = 0;
		StorageNew->dot1agCfmMepActive = TV_FALSE;
		StorageNew->dot1agCfmMepFngState = DOT1AGCFMMEPFNGSTATE_FNGRESET;
		StorageNew->dot1agCfmMepCciEnabled = TV_FALSE;
		StorageNew->dot1agCfmMepCcmLtmPriority = 0;
		if ((StorageNew->dot1agCfmMepMacAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepMacAddressLen = 0;
		StorageNew->dot1agCfmMepMacAddress[StorageNew->dot1agCfmMepMacAddressLen] = 0;
		StorageNew->dot1agCfmMepLowPrDef = DOT1AGCFMMEPLOWPRDEF_MACREMERRXCON;
		StorageNew->dot1agCfmMepFngAlarmTime = 250;
		StorageNew->dot1agCfmMepFngResetTime = 1000;
		StorageNew->dot1agCfmMepHighestPrDefect = 0;
		if (memdup((u_char **) &StorageNew->dot1agCfmMepDefects, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->dot1agCfmMepDefectsLen = 1;
		if ((StorageNew->dot1agCfmMepErrorCcmLastFailure = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepErrorCcmLastFailureLen = 0;
		StorageNew->dot1agCfmMepErrorCcmLastFailure[StorageNew->dot1agCfmMepErrorCcmLastFailureLen] = 0;
		if ((StorageNew->dot1agCfmMepXconCcmLastFailure = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepXconCcmLastFailureLen = 0;
		StorageNew->dot1agCfmMepXconCcmLastFailure[StorageNew->dot1agCfmMepXconCcmLastFailureLen] = 0;
		StorageNew->dot1agCfmMepCcmSequenceErrors = 0;
		StorageNew->dot1agCfmMepCciSentCcms = 0;
		StorageNew->dot1agCfmMepNextLbmTransId = 0;
		StorageNew->dot1agCfmMepLbrIn = 0;
		StorageNew->dot1agCfmMepLbrInOutOfOrder = 0;
		StorageNew->dot1agCfmMepLbrBadMsdu = 0;
		StorageNew->dot1agCfmMepLtmNextSeqNumber = 0;
		StorageNew->dot1agCfmMepUnexpLtrIn = 0;
		StorageNew->dot1agCfmMepLbrOut = 0;
		StorageNew->dot1agCfmMepTransmitLbmStatus = TV_FALSE;
		if ((StorageNew->dot1agCfmMepTransmitLbmDestMacAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepTransmitLbmDestMacAddressLen = 0;
		StorageNew->dot1agCfmMepTransmitLbmDestMacAddress[StorageNew->dot1agCfmMepTransmitLbmDestMacAddressLen] = 0;
		StorageNew->dot1agCfmMepTransmitLbmDestMepId = 0;
		StorageNew->dot1agCfmMepTransmitLbmDestIsMepId = 0;
		StorageNew->dot1agCfmMepTransmitLbmMessages = 1;
		if ((StorageNew->dot1agCfmMepTransmitLbmDataTlv = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepTransmitLbmDataTlvLen = 0;
		StorageNew->dot1agCfmMepTransmitLbmDataTlv[StorageNew->dot1agCfmMepTransmitLbmDataTlvLen] = 0;
		StorageNew->dot1agCfmMepTransmitLbmVlanPriority = 0;
		StorageNew->dot1agCfmMepTransmitLbmVlanDropEnable = TV_FALSE;
		StorageNew->dot1agCfmMepTransmitLbmResultOK = TV_TRUE;
		StorageNew->dot1agCfmMepTransmitLbmSeqNumber = 0;
		StorageNew->dot1agCfmMepTransmitLtmStatus = TV_TRUE;
		if (memdup((u_char **) &StorageNew->dot1agCfmMepTransmitLtmFlags, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->dot1agCfmMepTransmitLtmFlagsLen = 1;
		if ((StorageNew->dot1agCfmMepTransmitLtmTargetMacAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepTransmitLtmTargetMacAddressLen = 0;
		StorageNew->dot1agCfmMepTransmitLtmTargetMacAddress[StorageNew->dot1agCfmMepTransmitLtmTargetMacAddressLen] = 0;
		StorageNew->dot1agCfmMepTransmitLtmTargetMepId = 0;
		StorageNew->dot1agCfmMepTransmitLtmTargetIsMepId = 0;
		StorageNew->dot1agCfmMepTransmitLtmTtl = 64;
		StorageNew->dot1agCfmMepTransmitLtmResult = TV_TRUE;
		StorageNew->dot1agCfmMepTransmitLtmSeqNumber = 0;
		if ((StorageNew->dot1agCfmMepTransmitLtmEgressIdentifier = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepTransmitLtmEgressIdentifierLen = 0;
		StorageNew->dot1agCfmMepTransmitLtmEgressIdentifier[StorageNew->dot1agCfmMepTransmitLtmEgressIdentifierLen] = 0;
		StorageNew->dot1agCfmMepRowStatus = 0;
		StorageNew->dot1agCfmMepPbbTeCanReportPbbTePresence = TV_FALSE;
		StorageNew->dot1agCfmMepPbbTeTrafficMismatchDefect = 0;
		StorageNew->dot1agCfmMepPbbTransmitLbmLtmReverseVid = 0;
		StorageNew->dot1agCfmMepPbbTeMismatchAlarm = TV_FALSE;
		StorageNew->dot1agCfmMepPbbTeLocalMismatchDefect = 0;
		StorageNew->dot1agCfmMepPbbTeMismatchSinceReset = 0;
		StorageNew->dot1agCfmMepRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMepTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMepTable_data *dot1agCfmMepTable_duplicate(struct dot1agCfmMepTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMepTable_data *
dot1agCfmMepTable_duplicate(struct dot1agCfmMepTable_data *thedata)
{
	struct dot1agCfmMepTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMepTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMepTable_id = thedata->dot1agCfmMepTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMepIdentifier = thedata->dot1agCfmMepIdentifier;
		StorageNew->dot1agCfmMepIfIndex = thedata->dot1agCfmMepIfIndex;
		StorageNew->dot1agCfmMepDirection = thedata->dot1agCfmMepDirection;
		StorageNew->dot1agCfmMepPrimaryVid = thedata->dot1agCfmMepPrimaryVid;
		StorageNew->dot1agCfmMepActive = thedata->dot1agCfmMepActive;
		StorageNew->dot1agCfmMepFngState = thedata->dot1agCfmMepFngState;
		StorageNew->dot1agCfmMepCciEnabled = thedata->dot1agCfmMepCciEnabled;
		StorageNew->dot1agCfmMepCcmLtmPriority = thedata->dot1agCfmMepCcmLtmPriority;
		if (!(StorageNew->dot1agCfmMepMacAddress = malloc(thedata->dot1agCfmMepMacAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepMacAddress, thedata->dot1agCfmMepMacAddress, thedata->dot1agCfmMepMacAddressLen);
		StorageNew->dot1agCfmMepMacAddressLen = thedata->dot1agCfmMepMacAddressLen;
		StorageNew->dot1agCfmMepMacAddress[StorageNew->dot1agCfmMepMacAddressLen] = 0;
		StorageNew->dot1agCfmMepLowPrDef = thedata->dot1agCfmMepLowPrDef;
		StorageNew->dot1agCfmMepFngAlarmTime = thedata->dot1agCfmMepFngAlarmTime;
		StorageNew->dot1agCfmMepFngResetTime = thedata->dot1agCfmMepFngResetTime;
		StorageNew->dot1agCfmMepHighestPrDefect = thedata->dot1agCfmMepHighestPrDefect;
		if (!(StorageNew->dot1agCfmMepDefects = malloc(thedata->dot1agCfmMepDefectsLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepDefects, thedata->dot1agCfmMepDefects, thedata->dot1agCfmMepDefectsLen);
		StorageNew->dot1agCfmMepDefectsLen = thedata->dot1agCfmMepDefectsLen;
		StorageNew->dot1agCfmMepDefects[StorageNew->dot1agCfmMepDefectsLen] = 0;
		if (!(StorageNew->dot1agCfmMepErrorCcmLastFailure = malloc(thedata->dot1agCfmMepErrorCcmLastFailureLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepErrorCcmLastFailure, thedata->dot1agCfmMepErrorCcmLastFailure, thedata->dot1agCfmMepErrorCcmLastFailureLen);
		StorageNew->dot1agCfmMepErrorCcmLastFailureLen = thedata->dot1agCfmMepErrorCcmLastFailureLen;
		StorageNew->dot1agCfmMepErrorCcmLastFailure[StorageNew->dot1agCfmMepErrorCcmLastFailureLen] = 0;
		if (!(StorageNew->dot1agCfmMepXconCcmLastFailure = malloc(thedata->dot1agCfmMepXconCcmLastFailureLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepXconCcmLastFailure, thedata->dot1agCfmMepXconCcmLastFailure, thedata->dot1agCfmMepXconCcmLastFailureLen);
		StorageNew->dot1agCfmMepXconCcmLastFailureLen = thedata->dot1agCfmMepXconCcmLastFailureLen;
		StorageNew->dot1agCfmMepXconCcmLastFailure[StorageNew->dot1agCfmMepXconCcmLastFailureLen] = 0;
		StorageNew->dot1agCfmMepCcmSequenceErrors = thedata->dot1agCfmMepCcmSequenceErrors;
		StorageNew->dot1agCfmMepCciSentCcms = thedata->dot1agCfmMepCciSentCcms;
		StorageNew->dot1agCfmMepNextLbmTransId = thedata->dot1agCfmMepNextLbmTransId;
		StorageNew->dot1agCfmMepLbrIn = thedata->dot1agCfmMepLbrIn;
		StorageNew->dot1agCfmMepLbrInOutOfOrder = thedata->dot1agCfmMepLbrInOutOfOrder;
		StorageNew->dot1agCfmMepLbrBadMsdu = thedata->dot1agCfmMepLbrBadMsdu;
		StorageNew->dot1agCfmMepLtmNextSeqNumber = thedata->dot1agCfmMepLtmNextSeqNumber;
		StorageNew->dot1agCfmMepUnexpLtrIn = thedata->dot1agCfmMepUnexpLtrIn;
		StorageNew->dot1agCfmMepLbrOut = thedata->dot1agCfmMepLbrOut;
		StorageNew->dot1agCfmMepTransmitLbmStatus = thedata->dot1agCfmMepTransmitLbmStatus;
		if (!(StorageNew->dot1agCfmMepTransmitLbmDestMacAddress = malloc(thedata->dot1agCfmMepTransmitLbmDestMacAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepTransmitLbmDestMacAddress, thedata->dot1agCfmMepTransmitLbmDestMacAddress, thedata->dot1agCfmMepTransmitLbmDestMacAddressLen);
		StorageNew->dot1agCfmMepTransmitLbmDestMacAddressLen = thedata->dot1agCfmMepTransmitLbmDestMacAddressLen;
		StorageNew->dot1agCfmMepTransmitLbmDestMacAddress[StorageNew->dot1agCfmMepTransmitLbmDestMacAddressLen] = 0;
		StorageNew->dot1agCfmMepTransmitLbmDestMepId = thedata->dot1agCfmMepTransmitLbmDestMepId;
		StorageNew->dot1agCfmMepTransmitLbmDestIsMepId = thedata->dot1agCfmMepTransmitLbmDestIsMepId;
		StorageNew->dot1agCfmMepTransmitLbmMessages = thedata->dot1agCfmMepTransmitLbmMessages;
		if (!(StorageNew->dot1agCfmMepTransmitLbmDataTlv = malloc(thedata->dot1agCfmMepTransmitLbmDataTlvLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepTransmitLbmDataTlv, thedata->dot1agCfmMepTransmitLbmDataTlv, thedata->dot1agCfmMepTransmitLbmDataTlvLen);
		StorageNew->dot1agCfmMepTransmitLbmDataTlvLen = thedata->dot1agCfmMepTransmitLbmDataTlvLen;
		StorageNew->dot1agCfmMepTransmitLbmDataTlv[StorageNew->dot1agCfmMepTransmitLbmDataTlvLen] = 0;
		StorageNew->dot1agCfmMepTransmitLbmVlanPriority = thedata->dot1agCfmMepTransmitLbmVlanPriority;
		StorageNew->dot1agCfmMepTransmitLbmVlanDropEnable = thedata->dot1agCfmMepTransmitLbmVlanDropEnable;
		StorageNew->dot1agCfmMepTransmitLbmResultOK = thedata->dot1agCfmMepTransmitLbmResultOK;
		StorageNew->dot1agCfmMepTransmitLbmSeqNumber = thedata->dot1agCfmMepTransmitLbmSeqNumber;
		StorageNew->dot1agCfmMepTransmitLtmStatus = thedata->dot1agCfmMepTransmitLtmStatus;
		if (!(StorageNew->dot1agCfmMepTransmitLtmFlags = malloc(thedata->dot1agCfmMepTransmitLtmFlagsLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepTransmitLtmFlags, thedata->dot1agCfmMepTransmitLtmFlags, thedata->dot1agCfmMepTransmitLtmFlagsLen);
		StorageNew->dot1agCfmMepTransmitLtmFlagsLen = thedata->dot1agCfmMepTransmitLtmFlagsLen;
		StorageNew->dot1agCfmMepTransmitLtmFlags[StorageNew->dot1agCfmMepTransmitLtmFlagsLen] = 0;
		if (!(StorageNew->dot1agCfmMepTransmitLtmTargetMacAddress = malloc(thedata->dot1agCfmMepTransmitLtmTargetMacAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepTransmitLtmTargetMacAddress, thedata->dot1agCfmMepTransmitLtmTargetMacAddress, thedata->dot1agCfmMepTransmitLtmTargetMacAddressLen);
		StorageNew->dot1agCfmMepTransmitLtmTargetMacAddressLen = thedata->dot1agCfmMepTransmitLtmTargetMacAddressLen;
		StorageNew->dot1agCfmMepTransmitLtmTargetMacAddress[StorageNew->dot1agCfmMepTransmitLtmTargetMacAddressLen] = 0;
		StorageNew->dot1agCfmMepTransmitLtmTargetMepId = thedata->dot1agCfmMepTransmitLtmTargetMepId;
		StorageNew->dot1agCfmMepTransmitLtmTargetIsMepId = thedata->dot1agCfmMepTransmitLtmTargetIsMepId;
		StorageNew->dot1agCfmMepTransmitLtmTtl = thedata->dot1agCfmMepTransmitLtmTtl;
		StorageNew->dot1agCfmMepTransmitLtmResult = thedata->dot1agCfmMepTransmitLtmResult;
		StorageNew->dot1agCfmMepTransmitLtmSeqNumber = thedata->dot1agCfmMepTransmitLtmSeqNumber;
		if (!(StorageNew->dot1agCfmMepTransmitLtmEgressIdentifier = malloc(thedata->dot1agCfmMepTransmitLtmEgressIdentifierLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepTransmitLtmEgressIdentifier, thedata->dot1agCfmMepTransmitLtmEgressIdentifier, thedata->dot1agCfmMepTransmitLtmEgressIdentifierLen);
		StorageNew->dot1agCfmMepTransmitLtmEgressIdentifierLen = thedata->dot1agCfmMepTransmitLtmEgressIdentifierLen;
		StorageNew->dot1agCfmMepTransmitLtmEgressIdentifier[StorageNew->dot1agCfmMepTransmitLtmEgressIdentifierLen] = 0;
		StorageNew->dot1agCfmMepRowStatus = thedata->dot1agCfmMepRowStatus;
		StorageNew->dot1agCfmMepPbbTeCanReportPbbTePresence = thedata->dot1agCfmMepPbbTeCanReportPbbTePresence;
		StorageNew->dot1agCfmMepPbbTeTrafficMismatchDefect = thedata->dot1agCfmMepPbbTeTrafficMismatchDefect;
		StorageNew->dot1agCfmMepPbbTransmitLbmLtmReverseVid = thedata->dot1agCfmMepPbbTransmitLbmLtmReverseVid;
		StorageNew->dot1agCfmMepPbbTeMismatchAlarm = thedata->dot1agCfmMepPbbTeMismatchAlarm;
		StorageNew->dot1agCfmMepPbbTeLocalMismatchDefect = thedata->dot1agCfmMepPbbTeLocalMismatchDefect;
		StorageNew->dot1agCfmMepPbbTeMismatchSinceReset = thedata->dot1agCfmMepPbbTeMismatchSinceReset;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMepTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMepTable_destroy(struct dot1agCfmMepTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMepTable_destroy(struct dot1agCfmMepTable_data **thedata)
{
	struct dot1agCfmMepTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmMepMacAddress);
		StorageDel->dot1agCfmMepMacAddressLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepDefects);
		StorageDel->dot1agCfmMepDefectsLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepErrorCcmLastFailure);
		StorageDel->dot1agCfmMepErrorCcmLastFailureLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepXconCcmLastFailure);
		StorageDel->dot1agCfmMepXconCcmLastFailureLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepTransmitLbmDestMacAddress);
		StorageDel->dot1agCfmMepTransmitLbmDestMacAddressLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepTransmitLbmDataTlv);
		StorageDel->dot1agCfmMepTransmitLbmDataTlvLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepTransmitLtmFlags);
		StorageDel->dot1agCfmMepTransmitLtmFlagsLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepTransmitLtmTargetMacAddress);
		StorageDel->dot1agCfmMepTransmitLtmTargetMacAddressLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepTransmitLtmEgressIdentifier);
		StorageDel->dot1agCfmMepTransmitLtmEgressIdentifierLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMepTable_add(struct dot1agCfmMepTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMepTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMepTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMepTable_add(struct dot1agCfmMepTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		/* dot1agCfmMepIdentifier */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMepIdentifier, sizeof(thedata->dot1agCfmMepIdentifier));
		header_complex_add_data(&dot1agCfmMepTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMepTable_del(struct dot1agCfmMepTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMepTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMepTable_del(struct dot1agCfmMepTable_data *thedata)
{
	struct dot1agCfmMepTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMepTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMepTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMepTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMepTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMepTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMepTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMepTable_data *StorageTmp = dot1agCfmMepTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMepTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepIfIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDirection, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepPrimaryVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepActive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepFngState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepCciEnabled, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepCcmLtmPriority, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepMacAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepMacAddress, &StorageTmp->dot1agCfmMepMacAddressLen);
	if (StorageTmp->dot1agCfmMepMacAddress == NULL) {
		config_perror("invalid specification for dot1agCfmMepMacAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepLowPrDef, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepFngAlarmTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepFngResetTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepHighestPrDefect, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepDefects);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepDefects, &StorageTmp->dot1agCfmMepDefectsLen);
	if (StorageTmp->dot1agCfmMepDefects == NULL) {
		config_perror("invalid specification for dot1agCfmMepDefects");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmMepErrorCcmLastFailure);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepErrorCcmLastFailure, &StorageTmp->dot1agCfmMepErrorCcmLastFailureLen);
	if (StorageTmp->dot1agCfmMepErrorCcmLastFailure == NULL) {
		config_perror("invalid specification for dot1agCfmMepErrorCcmLastFailure");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmMepXconCcmLastFailure);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepXconCcmLastFailure, &StorageTmp->dot1agCfmMepXconCcmLastFailureLen);
	if (StorageTmp->dot1agCfmMepXconCcmLastFailure == NULL) {
		config_perror("invalid specification for dot1agCfmMepXconCcmLastFailure");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepCcmSequenceErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepCciSentCcms, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepNextLbmTransId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepLbrIn, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepLbrInOutOfOrder, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepLbrBadMsdu, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepLtmNextSeqNumber, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepUnexpLtrIn, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->dot1agCfmMepLbrOut, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmStatus, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress, &StorageTmp->dot1agCfmMepTransmitLbmDestMacAddressLen);
	if (StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress == NULL) {
		config_perror("invalid specification for dot1agCfmMepTransmitLbmDestMacAddress");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepTransmitLbmDestMepId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmMessages, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDataTlv);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepTransmitLbmDataTlv, &StorageTmp->dot1agCfmMepTransmitLbmDataTlvLen);
	if (StorageTmp->dot1agCfmMepTransmitLbmDataTlv == NULL) {
		config_perror("invalid specification for dot1agCfmMepTransmitLbmDataTlv");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmVlanPriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLbmResultOK, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepTransmitLbmSeqNumber, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLtmStatus, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmFlags);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepTransmitLtmFlags, &StorageTmp->dot1agCfmMepTransmitLtmFlagsLen);
	if (StorageTmp->dot1agCfmMepTransmitLtmFlags == NULL) {
		config_perror("invalid specification for dot1agCfmMepTransmitLtmFlags");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress, &StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddressLen);
	if (StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress == NULL) {
		config_perror("invalid specification for dot1agCfmMepTransmitLtmTargetMacAddress");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepTransmitLtmTargetMepId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepTransmitLtmTtl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepTransmitLtmResult, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepTransmitLtmSeqNumber, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier, &StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifierLen);
	if (StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier == NULL) {
		config_perror("invalid specification for dot1agCfmMepTransmitLtmEgressIdentifier");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepRowStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepPbbTeTrafficMismatchDefect, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepPbbTeMismatchAlarm, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepPbbTeLocalMismatchDefect, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepPbbTeMismatchSinceReset, &tmpsize);
	dot1agCfmMepTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMepTable(): store configuraiton file for dot1agCfmMepTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMepTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMepTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMepTable: storing data...  "));
	refresh_dot1agCfmMepTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMepTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMepTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMepTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepIfIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDirection, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepPrimaryVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepActive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepFngState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepCciEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepCcmLtmPriority, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepMacAddress, &StorageTmp->dot1agCfmMepMacAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepLowPrDef, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepFngAlarmTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepFngResetTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepHighestPrDefect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepDefects, &StorageTmp->dot1agCfmMepDefectsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepErrorCcmLastFailure, &StorageTmp->dot1agCfmMepErrorCcmLastFailureLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepXconCcmLastFailure, &StorageTmp->dot1agCfmMepXconCcmLastFailureLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepCcmSequenceErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepCciSentCcms, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepNextLbmTransId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepLbrIn, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepLbrInOutOfOrder, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepLbrBadMsdu, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepLtmNextSeqNumber, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepUnexpLtrIn, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->dot1agCfmMepLbrOut, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress, &StorageTmp->dot1agCfmMepTransmitLbmDestMacAddressLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepTransmitLbmDestMepId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmMessages, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepTransmitLbmDataTlv, &StorageTmp->dot1agCfmMepTransmitLbmDataTlvLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmVlanPriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLbmResultOK, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepTransmitLbmSeqNumber, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLtmStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepTransmitLtmFlags, &StorageTmp->dot1agCfmMepTransmitLtmFlagsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress, &StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddressLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepTransmitLtmTargetMepId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepTransmitLtmTtl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepTransmitLtmResult, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepTransmitLtmSeqNumber, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier, &StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifierLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepRowStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepPbbTeTrafficMismatchDefect, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepPbbTeMismatchAlarm, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepPbbTeLocalMismatchDefect, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepPbbTeMismatchSinceReset, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmLtrTable_data *dot1agCfmLtrTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmLtrTable table.
 *
 * Creates a new dot1agCfmLtrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmLtrTable_data *
dot1agCfmLtrTable_create(void)
{
	struct dot1agCfmLtrTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmLtrTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmLtrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaIndex = 0;
		StorageNew->dot1agCfmMepIdentifier = 0;
		StorageNew->dot1agCfmLtrTtl = 0;
		StorageNew->dot1agCfmLtrForwarded = 0;
		StorageNew->dot1agCfmLtrTerminalMep = 0;
		if ((StorageNew->dot1agCfmLtrLastEgressIdentifier = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrLastEgressIdentifierLen = 0;
		StorageNew->dot1agCfmLtrLastEgressIdentifier[StorageNew->dot1agCfmLtrLastEgressIdentifierLen] = 0;
		if ((StorageNew->dot1agCfmLtrNextEgressIdentifier = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrNextEgressIdentifierLen = 0;
		StorageNew->dot1agCfmLtrNextEgressIdentifier[StorageNew->dot1agCfmLtrNextEgressIdentifierLen] = 0;
		StorageNew->dot1agCfmLtrRelay = 0;
		StorageNew->dot1agCfmLtrChassisIdSubtype = 0;
		if ((StorageNew->dot1agCfmLtrChassisId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrChassisIdLen = 0;
		StorageNew->dot1agCfmLtrChassisId[StorageNew->dot1agCfmLtrChassisIdLen] = 0;
		if ((StorageNew->dot1agCfmLtrManAddressDomain = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrManAddressDomainLen = 2;
		if ((StorageNew->dot1agCfmLtrManAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrManAddressLen = 0;
		StorageNew->dot1agCfmLtrManAddress[StorageNew->dot1agCfmLtrManAddressLen] = 0;
		StorageNew->dot1agCfmLtrIngress = 0;
		if ((StorageNew->dot1agCfmLtrIngressMac = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrIngressMacLen = 0;
		StorageNew->dot1agCfmLtrIngressMac[StorageNew->dot1agCfmLtrIngressMacLen] = 0;
		StorageNew->dot1agCfmLtrIngressPortIdSubtype = 0;
		if ((StorageNew->dot1agCfmLtrIngressPortId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrIngressPortIdLen = 0;
		StorageNew->dot1agCfmLtrIngressPortId[StorageNew->dot1agCfmLtrIngressPortIdLen] = 0;
		StorageNew->dot1agCfmLtrEgress = 0;
		if ((StorageNew->dot1agCfmLtrEgressMac = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrEgressMacLen = 0;
		StorageNew->dot1agCfmLtrEgressMac[StorageNew->dot1agCfmLtrEgressMacLen] = 0;
		StorageNew->dot1agCfmLtrEgressPortIdSubtype = 0;
		if ((StorageNew->dot1agCfmLtrEgressPortId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrEgressPortIdLen = 0;
		StorageNew->dot1agCfmLtrEgressPortId[StorageNew->dot1agCfmLtrEgressPortIdLen] = 0;
		if ((StorageNew->dot1agCfmLtrOrganizationSpecificTlv = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmLtrOrganizationSpecificTlvLen = 0;
		StorageNew->dot1agCfmLtrOrganizationSpecificTlv[StorageNew->dot1agCfmLtrOrganizationSpecificTlvLen] = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmLtrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmLtrTable_data *dot1agCfmLtrTable_duplicate(struct dot1agCfmLtrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmLtrTable_data *
dot1agCfmLtrTable_duplicate(struct dot1agCfmLtrTable_data *thedata)
{
	struct dot1agCfmLtrTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmLtrTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmLtrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmLtrTable_id = thedata->dot1agCfmLtrTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMepIdentifier = thedata->dot1agCfmMepIdentifier;
		StorageNew->dot1agCfmLtrSeqNumber = thedata->dot1agCfmLtrSeqNumber;
		StorageNew->dot1agCfmLtrReceiveOrder = thedata->dot1agCfmLtrReceiveOrder;
		StorageNew->dot1agCfmLtrTtl = thedata->dot1agCfmLtrTtl;
		StorageNew->dot1agCfmLtrForwarded = thedata->dot1agCfmLtrForwarded;
		StorageNew->dot1agCfmLtrTerminalMep = thedata->dot1agCfmLtrTerminalMep;
		if (!(StorageNew->dot1agCfmLtrLastEgressIdentifier = malloc(thedata->dot1agCfmLtrLastEgressIdentifierLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrLastEgressIdentifier, thedata->dot1agCfmLtrLastEgressIdentifier, thedata->dot1agCfmLtrLastEgressIdentifierLen);
		StorageNew->dot1agCfmLtrLastEgressIdentifierLen = thedata->dot1agCfmLtrLastEgressIdentifierLen;
		StorageNew->dot1agCfmLtrLastEgressIdentifier[StorageNew->dot1agCfmLtrLastEgressIdentifierLen] = 0;
		if (!(StorageNew->dot1agCfmLtrNextEgressIdentifier = malloc(thedata->dot1agCfmLtrNextEgressIdentifierLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrNextEgressIdentifier, thedata->dot1agCfmLtrNextEgressIdentifier, thedata->dot1agCfmLtrNextEgressIdentifierLen);
		StorageNew->dot1agCfmLtrNextEgressIdentifierLen = thedata->dot1agCfmLtrNextEgressIdentifierLen;
		StorageNew->dot1agCfmLtrNextEgressIdentifier[StorageNew->dot1agCfmLtrNextEgressIdentifierLen] = 0;
		StorageNew->dot1agCfmLtrRelay = thedata->dot1agCfmLtrRelay;
		StorageNew->dot1agCfmLtrChassisIdSubtype = thedata->dot1agCfmLtrChassisIdSubtype;
		if (!(StorageNew->dot1agCfmLtrChassisId = malloc(thedata->dot1agCfmLtrChassisIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrChassisId, thedata->dot1agCfmLtrChassisId, thedata->dot1agCfmLtrChassisIdLen);
		StorageNew->dot1agCfmLtrChassisIdLen = thedata->dot1agCfmLtrChassisIdLen;
		StorageNew->dot1agCfmLtrChassisId[StorageNew->dot1agCfmLtrChassisIdLen] = 0;
		if (!(StorageNew->dot1agCfmLtrManAddressDomain = snmp_duplicate_objid(thedata->dot1agCfmLtrManAddressDomain, thedata->dot1agCfmLtrManAddressDomainLen / sizeof(oid))))
			goto destroy;
		StorageNew->dot1agCfmLtrManAddressDomainLen = thedata->dot1agCfmLtrManAddressDomainLen;
		if (!(StorageNew->dot1agCfmLtrManAddress = malloc(thedata->dot1agCfmLtrManAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrManAddress, thedata->dot1agCfmLtrManAddress, thedata->dot1agCfmLtrManAddressLen);
		StorageNew->dot1agCfmLtrManAddressLen = thedata->dot1agCfmLtrManAddressLen;
		StorageNew->dot1agCfmLtrManAddress[StorageNew->dot1agCfmLtrManAddressLen] = 0;
		StorageNew->dot1agCfmLtrIngress = thedata->dot1agCfmLtrIngress;
		if (!(StorageNew->dot1agCfmLtrIngressMac = malloc(thedata->dot1agCfmLtrIngressMacLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrIngressMac, thedata->dot1agCfmLtrIngressMac, thedata->dot1agCfmLtrIngressMacLen);
		StorageNew->dot1agCfmLtrIngressMacLen = thedata->dot1agCfmLtrIngressMacLen;
		StorageNew->dot1agCfmLtrIngressMac[StorageNew->dot1agCfmLtrIngressMacLen] = 0;
		StorageNew->dot1agCfmLtrIngressPortIdSubtype = thedata->dot1agCfmLtrIngressPortIdSubtype;
		if (!(StorageNew->dot1agCfmLtrIngressPortId = malloc(thedata->dot1agCfmLtrIngressPortIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrIngressPortId, thedata->dot1agCfmLtrIngressPortId, thedata->dot1agCfmLtrIngressPortIdLen);
		StorageNew->dot1agCfmLtrIngressPortIdLen = thedata->dot1agCfmLtrIngressPortIdLen;
		StorageNew->dot1agCfmLtrIngressPortId[StorageNew->dot1agCfmLtrIngressPortIdLen] = 0;
		StorageNew->dot1agCfmLtrEgress = thedata->dot1agCfmLtrEgress;
		if (!(StorageNew->dot1agCfmLtrEgressMac = malloc(thedata->dot1agCfmLtrEgressMacLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrEgressMac, thedata->dot1agCfmLtrEgressMac, thedata->dot1agCfmLtrEgressMacLen);
		StorageNew->dot1agCfmLtrEgressMacLen = thedata->dot1agCfmLtrEgressMacLen;
		StorageNew->dot1agCfmLtrEgressMac[StorageNew->dot1agCfmLtrEgressMacLen] = 0;
		StorageNew->dot1agCfmLtrEgressPortIdSubtype = thedata->dot1agCfmLtrEgressPortIdSubtype;
		if (!(StorageNew->dot1agCfmLtrEgressPortId = malloc(thedata->dot1agCfmLtrEgressPortIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrEgressPortId, thedata->dot1agCfmLtrEgressPortId, thedata->dot1agCfmLtrEgressPortIdLen);
		StorageNew->dot1agCfmLtrEgressPortIdLen = thedata->dot1agCfmLtrEgressPortIdLen;
		StorageNew->dot1agCfmLtrEgressPortId[StorageNew->dot1agCfmLtrEgressPortIdLen] = 0;
		if (!(StorageNew->dot1agCfmLtrOrganizationSpecificTlv = malloc(thedata->dot1agCfmLtrOrganizationSpecificTlvLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmLtrOrganizationSpecificTlv, thedata->dot1agCfmLtrOrganizationSpecificTlv, thedata->dot1agCfmLtrOrganizationSpecificTlvLen);
		StorageNew->dot1agCfmLtrOrganizationSpecificTlvLen = thedata->dot1agCfmLtrOrganizationSpecificTlvLen;
		StorageNew->dot1agCfmLtrOrganizationSpecificTlv[StorageNew->dot1agCfmLtrOrganizationSpecificTlvLen] = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmLtrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmLtrTable_destroy(struct dot1agCfmLtrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmLtrTable_destroy(struct dot1agCfmLtrTable_data **thedata)
{
	struct dot1agCfmLtrTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmLtrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmLtrLastEgressIdentifier);
		StorageDel->dot1agCfmLtrLastEgressIdentifierLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrNextEgressIdentifier);
		StorageDel->dot1agCfmLtrNextEgressIdentifierLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrChassisId);
		StorageDel->dot1agCfmLtrChassisIdLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrManAddressDomain);
		StorageDel->dot1agCfmLtrManAddressDomainLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrManAddress);
		StorageDel->dot1agCfmLtrManAddressLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrIngressMac);
		StorageDel->dot1agCfmLtrIngressMacLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrIngressPortId);
		StorageDel->dot1agCfmLtrIngressPortIdLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrEgressMac);
		StorageDel->dot1agCfmLtrEgressMacLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrEgressPortId);
		StorageDel->dot1agCfmLtrEgressPortIdLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmLtrOrganizationSpecificTlv);
		StorageDel->dot1agCfmLtrOrganizationSpecificTlvLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmLtrTable_add(struct dot1agCfmLtrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmLtrTable table data set.
 *
 * Adds a table row structure to the dot1agCfmLtrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmLtrTable_add(struct dot1agCfmLtrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmLtrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		/* dot1agCfmMepIdentifier */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMepIdentifier, sizeof(thedata->dot1agCfmMepIdentifier));
		/* dot1agCfmLtrSeqNumber */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmLtrSeqNumber, sizeof(thedata->dot1agCfmLtrSeqNumber));
		/* dot1agCfmLtrReceiveOrder */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmLtrReceiveOrder, sizeof(thedata->dot1agCfmLtrReceiveOrder));
		header_complex_add_data(&dot1agCfmLtrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmLtrTable_del(struct dot1agCfmLtrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmLtrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmLtrTable_del(struct dot1agCfmLtrTable_data *thedata)
{
	struct dot1agCfmLtrTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmLtrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmLtrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmLtrTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmLtrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmLtrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmLtrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmLtrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmLtrTable_data *StorageTmp = dot1agCfmLtrTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmLtrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmLtrSeqNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmLtrReceiveOrder, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmLtrTtl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrForwarded, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrTerminalMep, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrLastEgressIdentifier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrLastEgressIdentifier, &StorageTmp->dot1agCfmLtrLastEgressIdentifierLen);
	if (StorageTmp->dot1agCfmLtrLastEgressIdentifier == NULL) {
		config_perror("invalid specification for dot1agCfmLtrLastEgressIdentifier");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmLtrNextEgressIdentifier);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrNextEgressIdentifier, &StorageTmp->dot1agCfmLtrNextEgressIdentifierLen);
	if (StorageTmp->dot1agCfmLtrNextEgressIdentifier == NULL) {
		config_perror("invalid specification for dot1agCfmLtrNextEgressIdentifier");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrRelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrChassisIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrChassisId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrChassisId, &StorageTmp->dot1agCfmLtrChassisIdLen);
	if (StorageTmp->dot1agCfmLtrChassisId == NULL) {
		config_perror("invalid specification for dot1agCfmLtrChassisId");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmLtrManAddressDomain);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->dot1agCfmLtrManAddressDomain, &StorageTmp->dot1agCfmLtrManAddressDomainLen);
	if (StorageTmp->dot1agCfmLtrManAddressDomain == NULL) {
		config_perror("invalid specification for dot1agCfmLtrManAddressDomain");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmLtrManAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrManAddress, &StorageTmp->dot1agCfmLtrManAddressLen);
	if (StorageTmp->dot1agCfmLtrManAddress == NULL) {
		config_perror("invalid specification for dot1agCfmLtrManAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrIngress, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrIngressMac);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrIngressMac, &StorageTmp->dot1agCfmLtrIngressMacLen);
	if (StorageTmp->dot1agCfmLtrIngressMac == NULL) {
		config_perror("invalid specification for dot1agCfmLtrIngressMac");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrIngressPortIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrIngressPortId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrIngressPortId, &StorageTmp->dot1agCfmLtrIngressPortIdLen);
	if (StorageTmp->dot1agCfmLtrIngressPortId == NULL) {
		config_perror("invalid specification for dot1agCfmLtrIngressPortId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrEgress, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrEgressMac);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrEgressMac, &StorageTmp->dot1agCfmLtrEgressMacLen);
	if (StorageTmp->dot1agCfmLtrEgressMac == NULL) {
		config_perror("invalid specification for dot1agCfmLtrEgressMac");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmLtrEgressPortIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmLtrEgressPortId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrEgressPortId, &StorageTmp->dot1agCfmLtrEgressPortIdLen);
	if (StorageTmp->dot1agCfmLtrEgressPortId == NULL) {
		config_perror("invalid specification for dot1agCfmLtrEgressPortId");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmLtrOrganizationSpecificTlv);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmLtrOrganizationSpecificTlv, &StorageTmp->dot1agCfmLtrOrganizationSpecificTlvLen);
	if (StorageTmp->dot1agCfmLtrOrganizationSpecificTlv == NULL) {
		config_perror("invalid specification for dot1agCfmLtrOrganizationSpecificTlv");
		return;
	}
	dot1agCfmLtrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmLtrTable(): store configuraiton file for dot1agCfmLtrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmLtrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmLtrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmLtrTable: storing data...  "));
	refresh_dot1agCfmLtrTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmLtrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmLtrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmLtrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmLtrSeqNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmLtrReceiveOrder, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmLtrTtl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrForwarded, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrTerminalMep, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrLastEgressIdentifier, &StorageTmp->dot1agCfmLtrLastEgressIdentifierLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrNextEgressIdentifier, &StorageTmp->dot1agCfmLtrNextEgressIdentifierLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrRelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrChassisIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrChassisId, &StorageTmp->dot1agCfmLtrChassisIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->dot1agCfmLtrManAddressDomain, &StorageTmp->dot1agCfmLtrManAddressDomainLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrManAddress, &StorageTmp->dot1agCfmLtrManAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrIngress, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrIngressMac, &StorageTmp->dot1agCfmLtrIngressMacLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrIngressPortIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrIngressPortId, &StorageTmp->dot1agCfmLtrIngressPortIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrEgress, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrEgressMac, &StorageTmp->dot1agCfmLtrEgressMacLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmLtrEgressPortIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrEgressPortId, &StorageTmp->dot1agCfmLtrEgressPortIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmLtrOrganizationSpecificTlv, &StorageTmp->dot1agCfmLtrOrganizationSpecificTlvLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct dot1agCfmMepDbTable_data *dot1agCfmMepDbTable_create(void)
 * @brief create a fresh data structure representing a new row in the dot1agCfmMepDbTable table.
 *
 * Creates a new dot1agCfmMepDbTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct dot1agCfmMepDbTable_data *
dot1agCfmMepDbTable_create(void)
{
	struct dot1agCfmMepDbTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMepDbTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepDbTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->dot1agCfmMdIndex = 0;
		StorageNew->dot1agCfmMaIndex = 0;
		StorageNew->dot1agCfmMepIdentifier = 0;
		StorageNew->dot1agCfmMepDbRMepState = 0;
		StorageNew->dot1agCfmMepDbRMepFailedOkTime = 0;
		if ((StorageNew->dot1agCfmMepDbMacAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepDbMacAddressLen = 0;
		StorageNew->dot1agCfmMepDbMacAddress[StorageNew->dot1agCfmMepDbMacAddressLen] = 0;
		StorageNew->dot1agCfmMepDbRdi = 0;
		StorageNew->dot1agCfmMepDbPortStatusTlv = DOT1AGCFMMEPDBPORTSTATUSTLV_PSNOPORTSTATETLV;
		StorageNew->dot1agCfmMepDbInterfaceStatusTlv = DOT1AGCFMMEPDBINTERFACESTATUSTLV_ISNOINTERFACESTATUSTLV;
		StorageNew->dot1agCfmMepDbChassisIdSubtype = 0;
		if ((StorageNew->dot1agCfmMepDbChassisId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepDbChassisIdLen = 0;
		StorageNew->dot1agCfmMepDbChassisId[StorageNew->dot1agCfmMepDbChassisIdLen] = 0;
		if ((StorageNew->dot1agCfmMepDbManAddressDomain = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepDbManAddressDomainLen = 2;
		if ((StorageNew->dot1agCfmMepDbManAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->dot1agCfmMepDbManAddressLen = 0;
		StorageNew->dot1agCfmMepDbManAddress[StorageNew->dot1agCfmMepDbManAddressLen] = 0;
		StorageNew->dot1agCfmMepDbRMepIsActive = 0;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	dot1agCfmMepDbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct dot1agCfmMepDbTable_data *dot1agCfmMepDbTable_duplicate(struct dot1agCfmMepDbTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct dot1agCfmMepDbTable_data *
dot1agCfmMepDbTable_duplicate(struct dot1agCfmMepDbTable_data *thedata)
{
	struct dot1agCfmMepDbTable_data *StorageNew = SNMP_MALLOC_STRUCT(dot1agCfmMepDbTable_data);

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepDbTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->dot1agCfmMepDbTable_id = thedata->dot1agCfmMepDbTable_id;
		StorageNew->dot1agCfmMdIndex = thedata->dot1agCfmMdIndex;
		StorageNew->dot1agCfmMaIndex = thedata->dot1agCfmMaIndex;
		StorageNew->dot1agCfmMepIdentifier = thedata->dot1agCfmMepIdentifier;
		StorageNew->dot1agCfmMepDbRMepIdentifier = thedata->dot1agCfmMepDbRMepIdentifier;
		StorageNew->dot1agCfmMepDbRMepState = thedata->dot1agCfmMepDbRMepState;
		StorageNew->dot1agCfmMepDbRMepFailedOkTime = thedata->dot1agCfmMepDbRMepFailedOkTime;
		if (!(StorageNew->dot1agCfmMepDbMacAddress = malloc(thedata->dot1agCfmMepDbMacAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepDbMacAddress, thedata->dot1agCfmMepDbMacAddress, thedata->dot1agCfmMepDbMacAddressLen);
		StorageNew->dot1agCfmMepDbMacAddressLen = thedata->dot1agCfmMepDbMacAddressLen;
		StorageNew->dot1agCfmMepDbMacAddress[StorageNew->dot1agCfmMepDbMacAddressLen] = 0;
		StorageNew->dot1agCfmMepDbRdi = thedata->dot1agCfmMepDbRdi;
		StorageNew->dot1agCfmMepDbPortStatusTlv = thedata->dot1agCfmMepDbPortStatusTlv;
		StorageNew->dot1agCfmMepDbInterfaceStatusTlv = thedata->dot1agCfmMepDbInterfaceStatusTlv;
		StorageNew->dot1agCfmMepDbChassisIdSubtype = thedata->dot1agCfmMepDbChassisIdSubtype;
		if (!(StorageNew->dot1agCfmMepDbChassisId = malloc(thedata->dot1agCfmMepDbChassisIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepDbChassisId, thedata->dot1agCfmMepDbChassisId, thedata->dot1agCfmMepDbChassisIdLen);
		StorageNew->dot1agCfmMepDbChassisIdLen = thedata->dot1agCfmMepDbChassisIdLen;
		StorageNew->dot1agCfmMepDbChassisId[StorageNew->dot1agCfmMepDbChassisIdLen] = 0;
		if (!(StorageNew->dot1agCfmMepDbManAddressDomain = snmp_duplicate_objid(thedata->dot1agCfmMepDbManAddressDomain, thedata->dot1agCfmMepDbManAddressDomainLen / sizeof(oid))))
			goto destroy;
		StorageNew->dot1agCfmMepDbManAddressDomainLen = thedata->dot1agCfmMepDbManAddressDomainLen;
		if (!(StorageNew->dot1agCfmMepDbManAddress = malloc(thedata->dot1agCfmMepDbManAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->dot1agCfmMepDbManAddress, thedata->dot1agCfmMepDbManAddress, thedata->dot1agCfmMepDbManAddressLen);
		StorageNew->dot1agCfmMepDbManAddressLen = thedata->dot1agCfmMepDbManAddressLen;
		StorageNew->dot1agCfmMepDbManAddress[StorageNew->dot1agCfmMepDbManAddressLen] = 0;
		StorageNew->dot1agCfmMepDbRMepIsActive = thedata->dot1agCfmMepDbRMepIsActive;
	}
      done:
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	dot1agCfmMepDbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int dot1agCfmMepDbTable_destroy(struct dot1agCfmMepDbTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
dot1agCfmMepDbTable_destroy(struct dot1agCfmMepDbTable_data **thedata)
{
	struct dot1agCfmMepDbTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepDbTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->dot1agCfmMepDbMacAddress);
		StorageDel->dot1agCfmMepDbMacAddressLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepDbChassisId);
		StorageDel->dot1agCfmMepDbChassisIdLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepDbManAddressDomain);
		StorageDel->dot1agCfmMepDbManAddressDomainLen = 0;
		SNMP_FREE(StorageDel->dot1agCfmMepDbManAddress);
		StorageDel->dot1agCfmMepDbManAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMepDbTable_add(struct dot1agCfmMepDbTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the dot1agCfmMepDbTable table data set.
 *
 * Adds a table row structure to the dot1agCfmMepDbTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
dot1agCfmMepDbTable_add(struct dot1agCfmMepDbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepDbTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* dot1agCfmMdIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMdIndex, sizeof(thedata->dot1agCfmMdIndex));
		/* dot1agCfmMaIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMaIndex, sizeof(thedata->dot1agCfmMaIndex));
		/* dot1agCfmMepIdentifier */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMepIdentifier, sizeof(thedata->dot1agCfmMepIdentifier));
		/* dot1agCfmMepDbRMepIdentifier */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->dot1agCfmMepDbRMepIdentifier, sizeof(thedata->dot1agCfmMepDbRMepIdentifier));
		header_complex_add_data(&dot1agCfmMepDbTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int dot1agCfmMepDbTable_del(struct dot1agCfmMepDbTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the dot1agCfmMepDbTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
dot1agCfmMepDbTable_del(struct dot1agCfmMepDbTable_data *thedata)
{
	struct dot1agCfmMepDbTable_data *StorageDel;

	DEBUGMSGTL(("ieee8021CfmMib", "dot1agCfmMepDbTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(dot1agCfmMepDbTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&dot1agCfmMepDbTableStorage, hciptr);
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_dot1agCfmMepDbTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for dot1agCfmMepDbTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case dot1agCfmMepDbTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_dot1agCfmMepDbTable(const char *token, char *line)
{
	size_t tmpsize;
	struct dot1agCfmMepDbTable_data *StorageTmp = dot1agCfmMepDbTable_create();

	DEBUGMSGTL(("ieee8021CfmMib", "parse_dot1agCfmMepDbTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->dot1agCfmMepDbRMepIdentifier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbRMepState, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->dot1agCfmMepDbRMepFailedOkTime, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepDbMacAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepDbMacAddress, &StorageTmp->dot1agCfmMepDbMacAddressLen);
	if (StorageTmp->dot1agCfmMepDbMacAddress == NULL) {
		config_perror("invalid specification for dot1agCfmMepDbMacAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbRdi, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbPortStatusTlv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbInterfaceStatusTlv, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbChassisIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->dot1agCfmMepDbChassisId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepDbChassisId, &StorageTmp->dot1agCfmMepDbChassisIdLen);
	if (StorageTmp->dot1agCfmMepDbChassisId == NULL) {
		config_perror("invalid specification for dot1agCfmMepDbChassisId");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmMepDbManAddressDomain);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->dot1agCfmMepDbManAddressDomain, &StorageTmp->dot1agCfmMepDbManAddressDomainLen);
	if (StorageTmp->dot1agCfmMepDbManAddressDomain == NULL) {
		config_perror("invalid specification for dot1agCfmMepDbManAddressDomain");
		return;
	}
	SNMP_FREE(StorageTmp->dot1agCfmMepDbManAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->dot1agCfmMepDbManAddress, &StorageTmp->dot1agCfmMepDbManAddressLen);
	if (StorageTmp->dot1agCfmMepDbManAddress == NULL) {
		config_perror("invalid specification for dot1agCfmMepDbManAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->dot1agCfmMepDbRMepIsActive, &tmpsize);
	dot1agCfmMepDbTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/*
 * store_dot1agCfmMepDbTable(): store configuraiton file for dot1agCfmMepDbTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_dot1agCfmMepDbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct dot1agCfmMepDbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("ieee8021CfmMib", "store_dot1agCfmMepDbTable: storing data...  "));
	refresh_dot1agCfmMepDbTable(1);
	(void) tmpsize;
	for (hcindex = dot1agCfmMepDbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct dot1agCfmMepDbTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "dot1agCfmMepDbTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMdIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMaIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->dot1agCfmMepDbRMepIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbRMepState, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->dot1agCfmMepDbRMepFailedOkTime, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepDbMacAddress, &StorageTmp->dot1agCfmMepDbMacAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbRdi, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbPortStatusTlv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbInterfaceStatusTlv, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbChassisIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepDbChassisId, &StorageTmp->dot1agCfmMepDbChassisIdLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->dot1agCfmMepDbManAddressDomain, &StorageTmp->dot1agCfmMepDbManAddressDomainLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->dot1agCfmMepDbManAddress, &StorageTmp->dot1agCfmMepDbManAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->dot1agCfmMepDbRMepIsActive, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmStackTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmStackTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, struct dot1agCfmStackTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmStackTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmStackTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmStackTable_data *
refresh_dot1agCfmStackTable_row(struct dot1agCfmStackTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmStackTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmStackTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmStackTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmStackTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmStackTable(int force)
{
	if (!force && dot1agCfmStackTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmStackTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmStackTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmStackTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmStackTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmStackTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmStackTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmStackTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmStackTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmStackTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMSTACKMDINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmStackMdIndex);
		rval = (u_char *) &StorageTmp->dot1agCfmStackMdIndex;
		break;
	case (u_char) DOT1AGCFMSTACKMAINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmStackMaIndex);
		rval = (u_char *) &StorageTmp->dot1agCfmStackMaIndex;
		break;
	case (u_char) DOT1AGCFMSTACKMEPID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmStackMepId);
		rval = (u_char *) &StorageTmp->dot1agCfmStackMepId;
		break;
	case (u_char) DOT1AGCFMSTACKMACADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmStackMacAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmStackMacAddress;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmDefaultMdTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmDefaultMdTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, struct dot1agCfmDefaultMdTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmDefaultMdTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmDefaultMdTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmDefaultMdTable_data *
refresh_dot1agCfmDefaultMdTable_row(struct dot1agCfmDefaultMdTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmDefaultMdTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmDefaultMdTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmDefaultMdTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmDefaultMdTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmDefaultMdTable(int force)
{
	if (!force && dot1agCfmDefaultMdTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmDefaultMdTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmDefaultMdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmDefaultMdTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmDefaultMdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmDefaultMdTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmDefaultMdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmDefaultMdTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmDefaultMdTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmDefaultMdTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMDEFAULTMDSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdStatus;
		break;
	case (u_char) DOT1AGCFMDEFAULTMDLEVEL:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdLevel;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdLevel);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdLevel;
		break;
	case (u_char) DOT1AGCFMDEFAULTMDMHFCREATION:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdMhfCreation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdMhfCreation);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdMhfCreation;
		break;
	case (u_char) DOT1AGCFMDEFAULTMDIDPERMISSION:	/* ReadWrite */
		*write_method = write_dot1agCfmDefaultMdIdPermission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmDefaultMdIdPermission);
		rval = (u_char *) &StorageTmp->dot1agCfmDefaultMdIdPermission;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmVlanTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmVlanTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, struct dot1agCfmVlanTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmVlanTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmVlanTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmVlanTable_data *
refresh_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmVlanTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmVlanTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmVlanTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmVlanTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmVlanTable(int force)
{
	if (!force && dot1agCfmVlanTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmVlanTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmVlanTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmVlanTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmVlanTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmVlanTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmVlanTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmVlanTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmVlanTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmVlanTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMVLANPRIMARYVID:	/* Create */
		*write_method = write_dot1agCfmVlanPrimaryVid;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmVlanPrimaryVid);
		rval = (u_char *) &StorageTmp->dot1agCfmVlanPrimaryVid;
		break;
	case (u_char) DOT1AGCFMVLANROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmVlanRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmVlanRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmVlanRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmConfigErrorListTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmConfigErrorListTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, struct dot1agCfmConfigErrorListTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmConfigErrorListTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmConfigErrorListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmConfigErrorListTable_data *
refresh_dot1agCfmConfigErrorListTable_row(struct dot1agCfmConfigErrorListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmConfigErrorListTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmConfigErrorListTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmConfigErrorListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmConfigErrorListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmConfigErrorListTable(int force)
{
	if (!force && dot1agCfmConfigErrorListTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmConfigErrorListTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmConfigErrorListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmConfigErrorListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmConfigErrorListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmConfigErrorListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmConfigErrorListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmConfigErrorListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmConfigErrorListTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmConfigErrorListTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMCONFIGERRORLISTERRORTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmConfigErrorListErrorTypeLen;
		rval = (u_char *) StorageTmp->dot1agCfmConfigErrorListErrorType;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMdTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMdTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, struct dot1agCfmMdTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMdTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMdTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMdTable_data *
refresh_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMdTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMdTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMdTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMdTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMdTable(int force)
{
	if (!force && dot1agCfmMdTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMdTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMdTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMdTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMdTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMdTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMdTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMdTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMdTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMDFORMAT:	/* Create */
		*write_method = write_dot1agCfmMdFormat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdFormat);
		rval = (u_char *) &StorageTmp->dot1agCfmMdFormat;
		break;
	case (u_char) DOT1AGCFMMDNAME:	/* Create */
		*write_method = write_dot1agCfmMdName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMdNameLen;
		rval = (u_char *) StorageTmp->dot1agCfmMdName;
		break;
	case (u_char) DOT1AGCFMMDMDLEVEL:	/* Create */
		*write_method = write_dot1agCfmMdMdLevel;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdMdLevel);
		rval = (u_char *) &StorageTmp->dot1agCfmMdMdLevel;
		break;
	case (u_char) DOT1AGCFMMDMHFCREATION:	/* Create */
		*write_method = write_dot1agCfmMdMhfCreation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdMhfCreation);
		rval = (u_char *) &StorageTmp->dot1agCfmMdMhfCreation;
		break;
	case (u_char) DOT1AGCFMMDMHFIDPERMISSION:	/* Create */
		*write_method = write_dot1agCfmMdMhfIdPermission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdMhfIdPermission);
		rval = (u_char *) &StorageTmp->dot1agCfmMdMhfIdPermission;
		break;
	case (u_char) DOT1AGCFMMDMANEXTINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdMaNextIndex);
		rval = (u_char *) &StorageTmp->dot1agCfmMdMaNextIndex;
		break;
	case (u_char) DOT1AGCFMMDROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmMdRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMdRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMdRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMaNetTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMaNetTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, struct dot1agCfmMaNetTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMaNetTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMaNetTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMaNetTable_data *
refresh_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMaNetTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMaNetTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMaNetTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMaNetTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMaNetTable(int force)
{
	if (!force && dot1agCfmMaNetTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMaNetTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMaNetTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMaNetTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMaNetTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMaNetTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMaNetTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMaNetTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMaNetTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMaNetTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMANETFORMAT:	/* Create */
		*write_method = write_dot1agCfmMaNetFormat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaNetFormat);
		rval = (u_char *) &StorageTmp->dot1agCfmMaNetFormat;
		break;
	case (u_char) DOT1AGCFMMANETNAME:	/* Create */
		*write_method = write_dot1agCfmMaNetName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMaNetNameLen;
		rval = (u_char *) StorageTmp->dot1agCfmMaNetName;
		break;
	case (u_char) DOT1AGCFMMANETCCMINTERVAL:	/* Create */
		*write_method = write_dot1agCfmMaNetCcmInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaNetCcmInterval);
		rval = (u_char *) &StorageTmp->dot1agCfmMaNetCcmInterval;
		break;
	case (u_char) DOT1AGCFMMANETROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmMaNetRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaNetRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMaNetRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMaCompTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMaCompTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, struct dot1agCfmMaCompTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMaCompTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMaCompTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMaCompTable_data *
refresh_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMaCompTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMaCompTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMaCompTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMaCompTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMaCompTable(int force)
{
	if (!force && dot1agCfmMaCompTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMaCompTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMaCompTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMaCompTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMaCompTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMaCompTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMaCompTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMaCompTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMaCompTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMACOMPPRIMARYVLANID:	/* Create */
		*write_method = write_dot1agCfmMaCompPrimaryVlanId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaCompPrimaryVlanId);
		rval = (u_char *) &StorageTmp->dot1agCfmMaCompPrimaryVlanId;
		break;
	case (u_char) DOT1AGCFMMACOMPMHFCREATION:	/* Create */
		*write_method = write_dot1agCfmMaCompMhfCreation;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaCompMhfCreation);
		rval = (u_char *) &StorageTmp->dot1agCfmMaCompMhfCreation;
		break;
	case (u_char) DOT1AGCFMMACOMPIDPERMISSION:	/* Create */
		*write_method = write_dot1agCfmMaCompIdPermission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaCompIdPermission);
		rval = (u_char *) &StorageTmp->dot1agCfmMaCompIdPermission;
		break;
	case (u_char) DOT1AGCFMMACOMPNUMBEROFVIDS:	/* Create */
		*write_method = write_dot1agCfmMaCompNumberOfVids;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaCompNumberOfVids);
		rval = (u_char *) &StorageTmp->dot1agCfmMaCompNumberOfVids;
		break;
	case (u_char) DOT1AGCFMMACOMPROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmMaCompRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaCompRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMaCompRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMaMepListTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMaMepListTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, struct dot1agCfmMaMepListTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMaMepListTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMaMepListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMaMepListTable_data *
refresh_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMaMepListTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMaMepListTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMaMepListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMaMepListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMaMepListTable(int force)
{
	if (!force && dot1agCfmMaMepListTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMaMepListTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMaMepListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMaMepListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMaMepListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMaMepListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMaMepListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMaMepListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMaMepListTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMaMepListTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMAMEPLISTROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmMaMepListRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMaMepListRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMaMepListRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMepTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMepTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, struct dot1agCfmMepTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMepTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMepTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMepTable_data *
refresh_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMepTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMepTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMepTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMepTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMepTable(int force)
{
	if (!force && dot1agCfmMepTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMepTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMepTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMepTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMepTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMepTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMepTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMepTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMepTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMEPIFINDEX:	/* Create */
		*write_method = write_dot1agCfmMepIfIndex;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepIfIndex);
		rval = (u_char *) &StorageTmp->dot1agCfmMepIfIndex;
		break;
	case (u_char) DOT1AGCFMMEPDIRECTION:	/* Create */
		*write_method = write_dot1agCfmMepDirection;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDirection);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDirection;
		break;
	case (u_char) DOT1AGCFMMEPPRIMARYVID:	/* Create */
		*write_method = write_dot1agCfmMepPrimaryVid;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPrimaryVid);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPrimaryVid;
		break;
	case (u_char) DOT1AGCFMMEPACTIVE:	/* Create */
		*write_method = write_dot1agCfmMepActive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepActive);
		rval = (u_char *) &StorageTmp->dot1agCfmMepActive;
		break;
	case (u_char) DOT1AGCFMMEPFNGSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepFngState);
		rval = (u_char *) &StorageTmp->dot1agCfmMepFngState;
		break;
	case (u_char) DOT1AGCFMMEPCCIENABLED:	/* Create */
		*write_method = write_dot1agCfmMepCciEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepCciEnabled);
		rval = (u_char *) &StorageTmp->dot1agCfmMepCciEnabled;
		break;
	case (u_char) DOT1AGCFMMEPCCMLTMPRIORITY:	/* Create */
		*write_method = write_dot1agCfmMepCcmLtmPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepCcmLtmPriority);
		rval = (u_char *) &StorageTmp->dot1agCfmMepCcmLtmPriority;
		break;
	case (u_char) DOT1AGCFMMEPMACADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepMacAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepMacAddress;
		break;
	case (u_char) DOT1AGCFMMEPLOWPRDEF:	/* Create */
		*write_method = write_dot1agCfmMepLowPrDef;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLowPrDef);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLowPrDef;
		break;
	case (u_char) DOT1AGCFMMEPFNGALARMTIME:	/* Create */
		*write_method = write_dot1agCfmMepFngAlarmTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepFngAlarmTime);
		rval = (u_char *) &StorageTmp->dot1agCfmMepFngAlarmTime;
		break;
	case (u_char) DOT1AGCFMMEPFNGRESETTIME:	/* Create */
		*write_method = write_dot1agCfmMepFngResetTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepFngResetTime);
		rval = (u_char *) &StorageTmp->dot1agCfmMepFngResetTime;
		break;
	case (u_char) DOT1AGCFMMEPHIGHESTPRDEFECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepHighestPrDefect);
		rval = (u_char *) &StorageTmp->dot1agCfmMepHighestPrDefect;
		break;
	case (u_char) DOT1AGCFMMEPDEFECTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepDefectsLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepDefects;
		break;
	case (u_char) DOT1AGCFMMEPERRORCCMLASTFAILURE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepErrorCcmLastFailureLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepErrorCcmLastFailure;
		break;
	case (u_char) DOT1AGCFMMEPXCONCCMLASTFAILURE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepXconCcmLastFailureLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepXconCcmLastFailure;
		break;
	case (u_char) DOT1AGCFMMEPCCMSEQUENCEERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepCcmSequenceErrors);
		rval = (u_char *) &StorageTmp->dot1agCfmMepCcmSequenceErrors;
		break;
	case (u_char) DOT1AGCFMMEPCCISENTCCMS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepCciSentCcms);
		rval = (u_char *) &StorageTmp->dot1agCfmMepCciSentCcms;
		break;
	case (u_char) DOT1AGCFMMEPNEXTLBMTRANSID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepNextLbmTransId);
		rval = (u_char *) &StorageTmp->dot1agCfmMepNextLbmTransId;
		break;
	case (u_char) DOT1AGCFMMEPLBRIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLbrIn);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLbrIn;
		break;
	case (u_char) DOT1AGCFMMEPLBRINOUTOFORDER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLbrInOutOfOrder);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLbrInOutOfOrder;
		break;
	case (u_char) DOT1AGCFMMEPLBRBADMSDU:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLbrBadMsdu);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLbrBadMsdu;
		break;
	case (u_char) DOT1AGCFMMEPLTMNEXTSEQNUMBER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLtmNextSeqNumber);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLtmNextSeqNumber;
		break;
	case (u_char) DOT1AGCFMMEPUNEXPLTRIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepUnexpLtrIn);
		rval = (u_char *) &StorageTmp->dot1agCfmMepUnexpLtrIn;
		break;
	case (u_char) DOT1AGCFMMEPLBROUT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepLbrOut);
		rval = (u_char *) &StorageTmp->dot1agCfmMepLbrOut;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMSTATUS:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmStatus;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMDESTMACADDRESS:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmDestMacAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepTransmitLbmDestMacAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMDESTMEPID:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmDestMepId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmDestMepId);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmDestMepId;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMDESTISMEPID:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmDestIsMepId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMMESSAGES:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmMessages;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmMessages);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmMessages;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMDATATLV:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmDataTlv;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepTransmitLbmDataTlvLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepTransmitLbmDataTlv;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMVLANPRIORITY:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmVlanPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmVlanPriority);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmVlanPriority;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMVLANDROPENABLE:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLbmVlanDropEnable;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMRESULTOK:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmResultOK);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmResultOK;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLBMSEQNUMBER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLbmSeqNumber);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLbmSeqNumber;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMSTATUS:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmStatus;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMFLAGS:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmFlags;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepTransmitLtmFlagsLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepTransmitLtmFlags;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMTARGETMACADDRESS:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmTargetMacAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMTARGETMEPID:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmTargetMepId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmTargetMepId);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmTargetMepId;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMTARGETISMEPID:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmTargetIsMepId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMTTL:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmTtl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmTtl);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmTtl;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMRESULT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmResult);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmResult;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMSEQNUMBER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepTransmitLtmSeqNumber);
		rval = (u_char *) &StorageTmp->dot1agCfmMepTransmitLtmSeqNumber;
		break;
	case (u_char) DOT1AGCFMMEPTRANSMITLTMEGRESSIDENTIFIER:	/* Create */
		*write_method = write_dot1agCfmMepTransmitLtmEgressIdentifier;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifierLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier;
		break;
	case (u_char) DOT1AGCFMMEPROWSTATUS:	/* Create */
		*write_method = write_dot1agCfmMepRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepRowStatus);
		rval = (u_char *) &StorageTmp->dot1agCfmMepRowStatus;
		break;
	case (u_char) DOT1AGCFMMEPPBBTECANREPORTPBBTEPRESENCE:	/* Create */
		*write_method = write_dot1agCfmMepPbbTeCanReportPbbTePresence;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence;
		break;
	case (u_char) DOT1AGCFMMEPPBBTETRAFFICMISMATCHDEFECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTeTrafficMismatchDefect);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTeTrafficMismatchDefect;
		break;
	case (u_char) DOT1AGCFMMEPPBBTRANSMITLBMLTMREVERSEVID:	/* Create */
		*write_method = write_dot1agCfmMepPbbTransmitLbmLtmReverseVid;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid;
		break;
	case (u_char) DOT1AGCFMMEPPBBTEMISMATCHALARM:	/* Create */
		*write_method = write_dot1agCfmMepPbbTeMismatchAlarm;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTeMismatchAlarm);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTeMismatchAlarm;
		break;
	case (u_char) DOT1AGCFMMEPPBBTELOCALMISMATCHDEFECT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTeLocalMismatchDefect);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTeLocalMismatchDefect;
		break;
	case (u_char) DOT1AGCFMMEPPBBTEMISMATCHSINCERESET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepPbbTeMismatchSinceReset);
		rval = (u_char *) &StorageTmp->dot1agCfmMepPbbTeMismatchSinceReset;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmLtrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmLtrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, struct dot1agCfmLtrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmLtrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmLtrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmLtrTable_data *
refresh_dot1agCfmLtrTable_row(struct dot1agCfmLtrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmLtrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmLtrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmLtrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmLtrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmLtrTable(int force)
{
	if (!force && dot1agCfmLtrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmLtrTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmLtrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmLtrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmLtrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmLtrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmLtrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmLtrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmLtrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmLtrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMLTRTTL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrTtl);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrTtl;
		break;
	case (u_char) DOT1AGCFMLTRFORWARDED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrForwarded);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrForwarded;
		break;
	case (u_char) DOT1AGCFMLTRTERMINALMEP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrTerminalMep);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrTerminalMep;
		break;
	case (u_char) DOT1AGCFMLTRLASTEGRESSIDENTIFIER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrLastEgressIdentifierLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrLastEgressIdentifier;
		break;
	case (u_char) DOT1AGCFMLTRNEXTEGRESSIDENTIFIER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrNextEgressIdentifierLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrNextEgressIdentifier;
		break;
	case (u_char) DOT1AGCFMLTRRELAY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrRelay);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrRelay;
		break;
	case (u_char) DOT1AGCFMLTRCHASSISIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrChassisIdSubtype);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrChassisIdSubtype;
		break;
	case (u_char) DOT1AGCFMLTRCHASSISID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrChassisIdLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrChassisId;
		break;
	case (u_char) DOT1AGCFMLTRMANADDRESSDOMAIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrManAddressDomainLen * sizeof(oid);
		rval = (u_char *) StorageTmp->dot1agCfmLtrManAddressDomain;
		break;
	case (u_char) DOT1AGCFMLTRMANADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrManAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrManAddress;
		break;
	case (u_char) DOT1AGCFMLTRINGRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrIngress);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrIngress;
		break;
	case (u_char) DOT1AGCFMLTRINGRESSMAC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrIngressMacLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrIngressMac;
		break;
	case (u_char) DOT1AGCFMLTRINGRESSPORTIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrIngressPortIdSubtype);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrIngressPortIdSubtype;
		break;
	case (u_char) DOT1AGCFMLTRINGRESSPORTID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrIngressPortIdLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrIngressPortId;
		break;
	case (u_char) DOT1AGCFMLTREGRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrEgress);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrEgress;
		break;
	case (u_char) DOT1AGCFMLTREGRESSMAC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrEgressMacLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrEgressMac;
		break;
	case (u_char) DOT1AGCFMLTREGRESSPORTIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmLtrEgressPortIdSubtype);
		rval = (u_char *) &StorageTmp->dot1agCfmLtrEgressPortIdSubtype;
		break;
	case (u_char) DOT1AGCFMLTREGRESSPORTID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrEgressPortIdLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrEgressPortId;
		break;
	case (u_char) DOT1AGCFMLTRORGANIZATIONSPECIFICTLV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmLtrOrganizationSpecificTlvLen;
		rval = (u_char *) StorageTmp->dot1agCfmLtrOrganizationSpecificTlv;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_dot1agCfmMepDbTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	dot1agCfmMepDbTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, struct dot1agCfmMepDbTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_dot1agCfmMepDbTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the dot1agCfmMepDbTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct dot1agCfmMepDbTable_data *
refresh_dot1agCfmMepDbTable_row(struct dot1agCfmMepDbTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->dot1agCfmMepDbTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->dot1agCfmMepDbTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_dot1agCfmMepDbTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the dot1agCfmMepDbTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_dot1agCfmMepDbTable(int force)
{
	if (!force && dot1agCfmMepDbTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	dot1agCfmMepDbTable_refresh = 0;
}

/**
 * @fn u_char *var_dot1agCfmMepDbTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in dot1agCfmMepDbTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_ieee8021CfmMib above.
 */
u_char *
var_dot1agCfmMepDbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct dot1agCfmMepDbTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("ieee8021CfmMib", "var_dot1agCfmMepDbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_dot1agCfmMepDbTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(dot1agCfmMepDbTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_dot1agCfmMepDbTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) DOT1AGCFMMEPDBRMEPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbRMepState);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbRMepState;
		break;
	case (u_char) DOT1AGCFMMEPDBRMEPFAILEDOKTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbRMepFailedOkTime);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbRMepFailedOkTime;
		break;
	case (u_char) DOT1AGCFMMEPDBMACADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepDbMacAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepDbMacAddress;
		break;
	case (u_char) DOT1AGCFMMEPDBRDI:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbRdi);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbRdi;
		break;
	case (u_char) DOT1AGCFMMEPDBPORTSTATUSTLV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbPortStatusTlv);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbPortStatusTlv;
		break;
	case (u_char) DOT1AGCFMMEPDBINTERFACESTATUSTLV:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbInterfaceStatusTlv);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbInterfaceStatusTlv;
		break;
	case (u_char) DOT1AGCFMMEPDBCHASSISIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbChassisIdSubtype);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbChassisIdSubtype;
		break;
	case (u_char) DOT1AGCFMMEPDBCHASSISID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepDbChassisIdLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepDbChassisId;
		break;
	case (u_char) DOT1AGCFMMEPDBMANADDRESSDOMAIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepDbManAddressDomainLen * sizeof(oid);
		rval = (u_char *) StorageTmp->dot1agCfmMepDbManAddressDomain;
		break;
	case (u_char) DOT1AGCFMMEPDBMANADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->dot1agCfmMepDbManAddressLen;
		rval = (u_char *) StorageTmp->dot1agCfmMepDbManAddress;
		break;
	case (u_char) DOT1AGCFMMEPDBRMEPISACTIVE:	/* ReadWrite */
		*write_method = write_dot1agCfmMepDbRMepIsActive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->dot1agCfmMepDbRMepIsActive);
		rval = (u_char *) &StorageTmp->dot1agCfmMepDbRMepIsActive;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_dot1agCfmDefaultMdLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmDefaultMdLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmDefaultMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdLevel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmDefaultMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdLevel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdLevel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value -1 */
		/* Note: ranges -1..7 */
		if ((-1 > set_value || set_value > 7)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdLevel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old = dot1agCfmDefaultMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmDefaultMdTable_rsvs++;
		StorageTmp->dot1agCfmDefaultMdLevel = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmDefaultMdTable_tsts == 0)
				if ((ret = check_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdLevel for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
				if ((ret = update_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
			StorageTmp->dot1agCfmDefaultMdTable_rsvs = 0;
			StorageTmp->dot1agCfmDefaultMdTable_tsts = 0;
			StorageTmp->dot1agCfmDefaultMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
			revert_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdLevel = StorageOld->dot1agCfmDefaultMdLevel;
		if (--StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmDefaultMdMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmDefaultMdMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmDefaultMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdMhfCreation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmDefaultMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdMhfCreation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdMhfCreation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value defMHFdefer */
		switch (set_value) {
		case DOT1AGCFMDEFAULTMDMHFCREATION_DEFMHFNONE:
		case DOT1AGCFMDEFAULTMDMHFCREATION_DEFMHFDEFAULT:
		case DOT1AGCFMDEFAULTMDMHFCREATION_DEFMHFEXPLICIT:
		case DOT1AGCFMDEFAULTMDMHFCREATION_DEFMHFDEFER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdMhfCreation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old = dot1agCfmDefaultMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmDefaultMdTable_rsvs++;
		StorageTmp->dot1agCfmDefaultMdMhfCreation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmDefaultMdTable_tsts == 0)
				if ((ret = check_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdMhfCreation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
				if ((ret = update_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
			StorageTmp->dot1agCfmDefaultMdTable_rsvs = 0;
			StorageTmp->dot1agCfmDefaultMdTable_tsts = 0;
			StorageTmp->dot1agCfmDefaultMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
			revert_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdMhfCreation = StorageOld->dot1agCfmDefaultMdMhfCreation;
		if (--StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmDefaultMdIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmDefaultMdIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmDefaultMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdIdPermission entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmDefaultMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdIdPermission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdIdPermission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sendIdDefer */
		switch (set_value) {
		case DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDNONE:
		case DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDCHASSIS:
		case DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDMANAGE:
		case DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDCHASSISMANAGE:
		case DOT1AGCFMDEFAULTMDIDPERMISSION_SENDIDDEFER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdIdPermission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old = dot1agCfmDefaultMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmDefaultMdTable_rsvs++;
		StorageTmp->dot1agCfmDefaultMdIdPermission = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmDefaultMdTable_tsts == 0)
				if ((ret = check_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdIdPermission for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
				if ((ret = update_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmDefaultMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) != NULL) {
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
			StorageTmp->dot1agCfmDefaultMdTable_rsvs = 0;
			StorageTmp->dot1agCfmDefaultMdTable_tsts = 0;
			StorageTmp->dot1agCfmDefaultMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmDefaultMdTable_sets == 0)
			revert_dot1agCfmDefaultMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmDefaultMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdIdPermission = StorageOld->dot1agCfmDefaultMdIdPermission;
		if (--StorageTmp->dot1agCfmDefaultMdTable_rsvs == 0)
			dot1agCfmDefaultMdTable_destroy(&StorageTmp->dot1agCfmDefaultMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmVlanPrimaryVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmVlanPrimaryVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmVlanTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmVlanPrimaryVid entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmVlanTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmVlanRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanPrimaryVid: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanPrimaryVid not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanPrimaryVid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..4094 */
		if ((1 > set_value || set_value > 4094)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanPrimaryVid: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) == NULL)
			if (StorageTmp->dot1agCfmVlanTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old = dot1agCfmVlanTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmVlanTable_rsvs++;
		StorageTmp->dot1agCfmVlanPrimaryVid = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmVlanTable_tsts == 0)
				if ((ret = check_dot1agCfmVlanTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmVlanTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmVlanPrimaryVid for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmVlanTable_sets == 0)
				if ((ret = update_dot1agCfmVlanTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmVlanTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) != NULL) {
			dot1agCfmVlanTable_destroy(&StorageTmp->dot1agCfmVlanTable_old);
			StorageTmp->dot1agCfmVlanTable_rsvs = 0;
			StorageTmp->dot1agCfmVlanTable_tsts = 0;
			StorageTmp->dot1agCfmVlanTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmVlanTable_sets == 0)
			revert_dot1agCfmVlanTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmVlanPrimaryVid = StorageOld->dot1agCfmVlanPrimaryVid;
		if (--StorageTmp->dot1agCfmVlanTable_rsvs == 0)
			dot1agCfmVlanTable_destroy(&StorageTmp->dot1agCfmVlanTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMdFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdFormat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMdRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdFormat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value charString */
		switch (set_value) {
		case DOT1AGCFMMDFORMAT_NONE:
		case DOT1AGCFMMDFORMAT_DNSLIKENAME:
		case DOT1AGCFMMDFORMAT_MACADDRESSANDUINT:
		case DOT1AGCFMMDFORMAT_CHARSTRING:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdFormat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMdTable_rsvs++;
		StorageTmp->dot1agCfmMdFormat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMdTable_tsts == 0)
				if ((ret = check_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMdFormat for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMdTable_sets == 0)
				if ((ret = update_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			StorageTmp->dot1agCfmMdTable_rsvs = 0;
			StorageTmp->dot1agCfmMdTable_tsts = 0;
			StorageTmp->dot1agCfmMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMdTable_sets == 0)
			revert_dot1agCfmMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMdFormat = StorageOld->dot1agCfmMdFormat;
		if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMdName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMdRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..43 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 43))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"DEFAULT\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMdTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMdName);
		StorageTmp->dot1agCfmMdName = string;
		StorageTmp->dot1agCfmMdNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMdTable_tsts == 0)
				if ((ret = check_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMdName for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMdTable_sets == 0)
				if ((ret = update_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			StorageTmp->dot1agCfmMdTable_rsvs = 0;
			StorageTmp->dot1agCfmMdTable_tsts = 0;
			StorageTmp->dot1agCfmMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMdTable_sets == 0)
			revert_dot1agCfmMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMdName != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMdName);
			StorageTmp->dot1agCfmMdName = StorageOld->dot1agCfmMdName;
			StorageTmp->dot1agCfmMdNameLen = StorageOld->dot1agCfmMdNameLen;
			StorageOld->dot1agCfmMdName = NULL;
			StorageOld->dot1agCfmMdNameLen = 0;
		}
		if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdMdLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMdMdLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdMdLevel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMdRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMdLevel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMdLevel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMdLevel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..7 */
		if ((0 > set_value || set_value > 7)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMdLevel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMdTable_rsvs++;
		StorageTmp->dot1agCfmMdMdLevel = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMdTable_tsts == 0)
				if ((ret = check_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMdMdLevel for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMdTable_sets == 0)
				if ((ret = update_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			StorageTmp->dot1agCfmMdTable_rsvs = 0;
			StorageTmp->dot1agCfmMdTable_tsts = 0;
			StorageTmp->dot1agCfmMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMdTable_sets == 0)
			revert_dot1agCfmMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMdMdLevel = StorageOld->dot1agCfmMdMdLevel;
		if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMdMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdMhfCreation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMdRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfCreation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfCreation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfCreation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value defMHFnone */
		switch (set_value) {
		case DOT1AGCFMMDMHFCREATION_DEFMHFNONE:
		case DOT1AGCFMMDMHFCREATION_DEFMHFDEFAULT:
		case DOT1AGCFMMDMHFCREATION_DEFMHFEXPLICIT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfCreation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMdTable_rsvs++;
		StorageTmp->dot1agCfmMdMhfCreation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMdTable_tsts == 0)
				if ((ret = check_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMdMhfCreation for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMdTable_sets == 0)
				if ((ret = update_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			StorageTmp->dot1agCfmMdTable_rsvs = 0;
			StorageTmp->dot1agCfmMdTable_tsts = 0;
			StorageTmp->dot1agCfmMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMdTable_sets == 0)
			revert_dot1agCfmMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMdMhfCreation = StorageOld->dot1agCfmMdMhfCreation;
		if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdMhfIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMdMhfIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdMhfIdPermission entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMdRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfIdPermission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfIdPermission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfIdPermission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sendIdNone */
		switch (set_value) {
		case DOT1AGCFMMDMHFIDPERMISSION_SENDIDNONE:
		case DOT1AGCFMMDMHFIDPERMISSION_SENDIDCHASSIS:
		case DOT1AGCFMMDMHFIDPERMISSION_SENDIDMANAGE:
		case DOT1AGCFMMDMHFIDPERMISSION_SENDIDCHASSISMANAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdMhfIdPermission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMdTable_rsvs++;
		StorageTmp->dot1agCfmMdMhfIdPermission = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMdTable_tsts == 0)
				if ((ret = check_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMdMhfIdPermission for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMdTable_sets == 0)
				if ((ret = update_dot1agCfmMdTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMdTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			StorageTmp->dot1agCfmMdTable_rsvs = 0;
			StorageTmp->dot1agCfmMdTable_tsts = 0;
			StorageTmp->dot1agCfmMdTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMdTable_sets == 0)
			revert_dot1agCfmMdTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMdMhfIdPermission = StorageOld->dot1agCfmMdMhfIdPermission;
		if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
			dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaNetFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaNetFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaNetTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaNetFormat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaNetTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaNetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetFormat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DOT1AGCFMMANETFORMAT_PRIMARYVID:
		case DOT1AGCFMMANETFORMAT_CHARSTRING:
		case DOT1AGCFMMANETFORMAT_UNSIGNEDINT16:
		case DOT1AGCFMMANETFORMAT_RFC2865VPNID:
		case DOT1AGCFMMANETFORMAT_ICCFORMAT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetFormat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old = dot1agCfmMaNetTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaNetTable_rsvs++;
		StorageTmp->dot1agCfmMaNetFormat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaNetTable_tsts == 0)
				if ((ret = check_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaNetFormat for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaNetTable_sets == 0)
				if ((ret = update_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
			StorageTmp->dot1agCfmMaNetTable_rsvs = 0;
			StorageTmp->dot1agCfmMaNetTable_tsts = 0;
			StorageTmp->dot1agCfmMaNetTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaNetTable_sets == 0)
			revert_dot1agCfmMaNetTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaNetFormat = StorageOld->dot1agCfmMaNetFormat;
		if (--StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaNetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaNetName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaNetTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaNetName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaNetTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaNetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..45 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 45))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old = dot1agCfmMaNetTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaNetTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMaNetName);
		StorageTmp->dot1agCfmMaNetName = string;
		StorageTmp->dot1agCfmMaNetNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaNetTable_tsts == 0)
				if ((ret = check_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaNetName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaNetTable_sets == 0)
				if ((ret = update_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
			StorageTmp->dot1agCfmMaNetTable_rsvs = 0;
			StorageTmp->dot1agCfmMaNetTable_tsts = 0;
			StorageTmp->dot1agCfmMaNetTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaNetTable_sets == 0)
			revert_dot1agCfmMaNetTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMaNetName != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMaNetName);
			StorageTmp->dot1agCfmMaNetName = StorageOld->dot1agCfmMaNetName;
			StorageTmp->dot1agCfmMaNetNameLen = StorageOld->dot1agCfmMaNetNameLen;
			StorageOld->dot1agCfmMaNetName = NULL;
			StorageOld->dot1agCfmMaNetNameLen = 0;
		}
		if (--StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaNetCcmInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaNetCcmInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaNetTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaNetCcmInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaNetTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaNetRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetCcmInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetCcmInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetCcmInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value interval1s */
		switch (set_value) {
		case DOT1AGCFMMANETCCMINTERVAL_INTERVALINVALID:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL300HZ:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL10MS:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL100MS:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL1S:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL10S:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL1MIN:
		case DOT1AGCFMMANETCCMINTERVAL_INTERVAL10MIN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetCcmInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old = dot1agCfmMaNetTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaNetTable_rsvs++;
		StorageTmp->dot1agCfmMaNetCcmInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaNetTable_tsts == 0)
				if ((ret = check_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaNetCcmInterval for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaNetTable_sets == 0)
				if ((ret = update_dot1agCfmMaNetTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaNetTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
			StorageTmp->dot1agCfmMaNetTable_rsvs = 0;
			StorageTmp->dot1agCfmMaNetTable_tsts = 0;
			StorageTmp->dot1agCfmMaNetTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaNetTable_sets == 0)
			revert_dot1agCfmMaNetTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaNetCcmInterval = StorageOld->dot1agCfmMaNetCcmInterval;
		if (--StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
			dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaCompPrimaryVlanId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaCompPrimaryVlanId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaCompPrimaryVlanId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaCompTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaCompRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompPrimaryVlanId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompPrimaryVlanId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompPrimaryVlanId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..0 1..4094 */
		if (set_value != 0 && (1 > set_value || set_value > 4094)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompPrimaryVlanId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old = dot1agCfmMaCompTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaCompTable_rsvs++;
		StorageTmp->dot1agCfmMaCompPrimaryVlanId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaCompTable_tsts == 0)
				if ((ret = check_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaCompPrimaryVlanId for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaCompTable_sets == 0)
				if ((ret = update_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
			StorageTmp->dot1agCfmMaCompTable_rsvs = 0;
			StorageTmp->dot1agCfmMaCompTable_tsts = 0;
			StorageTmp->dot1agCfmMaCompTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaCompTable_sets == 0)
			revert_dot1agCfmMaCompTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaCompPrimaryVlanId = StorageOld->dot1agCfmMaCompPrimaryVlanId;
		if (--StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaCompMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaCompMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaCompMhfCreation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaCompTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaCompRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompMhfCreation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompMhfCreation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompMhfCreation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value defMHFdefer */
		switch (set_value) {
		case DOT1AGCFMMACOMPMHFCREATION_DEFMHFNONE:
		case DOT1AGCFMMACOMPMHFCREATION_DEFMHFDEFAULT:
		case DOT1AGCFMMACOMPMHFCREATION_DEFMHFEXPLICIT:
		case DOT1AGCFMMACOMPMHFCREATION_DEFMHFDEFER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompMhfCreation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old = dot1agCfmMaCompTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaCompTable_rsvs++;
		StorageTmp->dot1agCfmMaCompMhfCreation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaCompTable_tsts == 0)
				if ((ret = check_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaCompMhfCreation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaCompTable_sets == 0)
				if ((ret = update_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
			StorageTmp->dot1agCfmMaCompTable_rsvs = 0;
			StorageTmp->dot1agCfmMaCompTable_tsts = 0;
			StorageTmp->dot1agCfmMaCompTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaCompTable_sets == 0)
			revert_dot1agCfmMaCompTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaCompMhfCreation = StorageOld->dot1agCfmMaCompMhfCreation;
		if (--StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaCompIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaCompIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaCompIdPermission entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaCompTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaCompRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompIdPermission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompIdPermission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompIdPermission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sendIdDefer */
		switch (set_value) {
		case DOT1AGCFMMACOMPIDPERMISSION_SENDIDNONE:
		case DOT1AGCFMMACOMPIDPERMISSION_SENDIDCHASSIS:
		case DOT1AGCFMMACOMPIDPERMISSION_SENDIDMANAGE:
		case DOT1AGCFMMACOMPIDPERMISSION_SENDIDCHASSISMANAGE:
		case DOT1AGCFMMACOMPIDPERMISSION_SENDIDDEFER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompIdPermission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old = dot1agCfmMaCompTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaCompTable_rsvs++;
		StorageTmp->dot1agCfmMaCompIdPermission = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaCompTable_tsts == 0)
				if ((ret = check_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaCompIdPermission for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaCompTable_sets == 0)
				if ((ret = update_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
			StorageTmp->dot1agCfmMaCompTable_rsvs = 0;
			StorageTmp->dot1agCfmMaCompTable_tsts = 0;
			StorageTmp->dot1agCfmMaCompTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaCompTable_sets == 0)
			revert_dot1agCfmMaCompTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaCompIdPermission = StorageOld->dot1agCfmMaCompIdPermission;
		if (--StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaCompNumberOfVids(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMaCompNumberOfVids(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaCompNumberOfVids entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMaCompTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMaCompRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompNumberOfVids: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompNumberOfVids not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompNumberOfVids: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			if (StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old = dot1agCfmMaCompTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMaCompTable_rsvs++;
		StorageTmp->dot1agCfmMaCompNumberOfVids = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMaCompTable_tsts == 0)
				if ((ret = check_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMaCompNumberOfVids for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMaCompTable_sets == 0)
				if ((ret = update_dot1agCfmMaCompTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMaCompTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
			StorageTmp->dot1agCfmMaCompTable_rsvs = 0;
			StorageTmp->dot1agCfmMaCompTable_tsts = 0;
			StorageTmp->dot1agCfmMaCompTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMaCompTable_sets == 0)
			revert_dot1agCfmMaCompTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMaCompNumberOfVids = StorageOld->dot1agCfmMaCompNumberOfVids;
		if (--StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
			dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepIfIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepIfIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepIfIndex entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepIfIndex: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepIfIndex not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepIfIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepIfIndex: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepIfIndex = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepIfIndex for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepIfIndex = StorageOld->dot1agCfmMepIfIndex;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepDirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepDirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepDirection entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDirection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case DOT1AGCFMMEPDIRECTION_DOWN:
		case DOT1AGCFMMEPDIRECTION_UP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDirection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepDirection = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepDirection for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepDirection = StorageOld->dot1agCfmMepDirection;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepPrimaryVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepPrimaryVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepPrimaryVid entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPrimaryVid: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPrimaryVid not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPrimaryVid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPrimaryVid: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepPrimaryVid = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepPrimaryVid for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepPrimaryVid = StorageOld->dot1agCfmMepPrimaryVid;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepActive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepActive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepActive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepActive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepActive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepActive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepActive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepActive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepActive for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepActive = StorageOld->dot1agCfmMepActive;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepCciEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepCciEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepCciEnabled entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCciEnabled: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCciEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCciEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCciEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepCciEnabled = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepCciEnabled for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepCciEnabled = StorageOld->dot1agCfmMepCciEnabled;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepCcmLtmPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepCcmLtmPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepCcmLtmPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCcmLtmPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCcmLtmPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCcmLtmPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..7 */
		if ((0 > set_value || set_value > 7)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepCcmLtmPriority: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepCcmLtmPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepCcmLtmPriority for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepCcmLtmPriority = StorageOld->dot1agCfmMepCcmLtmPriority;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepLowPrDef(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepLowPrDef(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepLowPrDef entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepLowPrDef: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepLowPrDef not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepLowPrDef: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value macRemErrXcon */
		switch (set_value) {
		case DOT1AGCFMMEPLOWPRDEF_ALLDEF:
		case DOT1AGCFMMEPLOWPRDEF_MACREMERRXCON:
		case DOT1AGCFMMEPLOWPRDEF_REMERRXCON:
		case DOT1AGCFMMEPLOWPRDEF_ERRXCON:
		case DOT1AGCFMMEPLOWPRDEF_XCON:
		case DOT1AGCFMMEPLOWPRDEF_NOXCON:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepLowPrDef: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepLowPrDef = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepLowPrDef for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepLowPrDef = StorageOld->dot1agCfmMepLowPrDef;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepFngAlarmTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepFngAlarmTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepFngAlarmTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngAlarmTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngAlarmTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngAlarmTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 250..1000 */
		if ((250 > set_value || set_value > 1000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngAlarmTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepFngAlarmTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepFngAlarmTime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepFngAlarmTime = StorageOld->dot1agCfmMepFngAlarmTime;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepFngResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepFngResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepFngResetTime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngResetTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges 250..1000 */
		if ((250 > set_value || set_value > 1000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepFngResetTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepFngResetTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepFngResetTime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepFngResetTime = StorageOld->dot1agCfmMepFngResetTime;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmStatus = StorageOld->dot1agCfmMepTransmitLbmStatus;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmDestMacAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmDestMacAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmDestMacAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMacAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMacAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 6..6 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 6)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMacAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress);
		StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress = string;
		StorageTmp->dot1agCfmMepTransmitLbmDestMacAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMepTransmitLbmDestMacAddress != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress);
			StorageTmp->dot1agCfmMepTransmitLbmDestMacAddress = StorageOld->dot1agCfmMepTransmitLbmDestMacAddress;
			StorageTmp->dot1agCfmMepTransmitLbmDestMacAddressLen = StorageOld->dot1agCfmMepTransmitLbmDestMacAddressLen;
			StorageOld->dot1agCfmMepTransmitLbmDestMacAddress = NULL;
			StorageOld->dot1agCfmMepTransmitLbmDestMacAddressLen = 0;
		}
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmDestMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmDestMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmDestMepId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMepId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMepId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMepId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..8191 */
		if ((0 > set_value || set_value > 8191)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestMepId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmDestMepId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmDestMepId for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmDestMepId = StorageOld->dot1agCfmMepTransmitLbmDestMepId;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmDestIsMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmDestIsMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmDestIsMepId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestIsMepId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestIsMepId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestIsMepId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDestIsMepId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmDestIsMepId = StorageOld->dot1agCfmMepTransmitLbmDestIsMepId;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmMessages(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmMessages(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmMessages entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmMessages: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmMessages not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmMessages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* Note: ranges 1..1024 */
		if ((1 > set_value || set_value > 1024)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmMessages: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmMessages = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmMessages for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmMessages = StorageOld->dot1agCfmMepTransmitLbmMessages;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmDataTlv(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmDataTlv(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmDataTlv entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDataTlv: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDataTlv not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmDataTlv: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDataTlv);
		StorageTmp->dot1agCfmMepTransmitLbmDataTlv = string;
		StorageTmp->dot1agCfmMepTransmitLbmDataTlvLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmDataTlv for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMepTransmitLbmDataTlv != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLbmDataTlv);
			StorageTmp->dot1agCfmMepTransmitLbmDataTlv = StorageOld->dot1agCfmMepTransmitLbmDataTlv;
			StorageTmp->dot1agCfmMepTransmitLbmDataTlvLen = StorageOld->dot1agCfmMepTransmitLbmDataTlvLen;
			StorageOld->dot1agCfmMepTransmitLbmDataTlv = NULL;
			StorageOld->dot1agCfmMepTransmitLbmDataTlvLen = 0;
		}
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmVlanPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmVlanPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmVlanPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanPriority not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..7 */
		if ((0 > set_value || set_value > 7)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanPriority: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmVlanPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmVlanPriority for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmVlanPriority = StorageOld->dot1agCfmMepTransmitLbmVlanPriority;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLbmVlanDropEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLbmVlanDropEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLbmVlanDropEnable entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanDropEnable: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanDropEnable not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanDropEnable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLbmVlanDropEnable: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLbmVlanDropEnable = StorageOld->dot1agCfmMepTransmitLbmVlanDropEnable;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLtmStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmStatus for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLtmStatus = StorageOld->dot1agCfmMepTransmitLtmStatus;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmFlags(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmFlags entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmFlags: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmFlags not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmFlags: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmFlags: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { useFDBonly } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmFlags);
		StorageTmp->dot1agCfmMepTransmitLtmFlags = string;
		StorageTmp->dot1agCfmMepTransmitLtmFlagsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmFlags for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMepTransmitLtmFlags != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmFlags);
			StorageTmp->dot1agCfmMepTransmitLtmFlags = StorageOld->dot1agCfmMepTransmitLtmFlags;
			StorageTmp->dot1agCfmMepTransmitLtmFlagsLen = StorageOld->dot1agCfmMepTransmitLtmFlagsLen;
			StorageOld->dot1agCfmMepTransmitLtmFlags = NULL;
			StorageOld->dot1agCfmMepTransmitLtmFlagsLen = 0;
		}
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmTargetMacAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmTargetMacAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmTargetMacAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMacAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMacAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 6..6 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 6)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMacAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress);
		StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress = string;
		StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMepTransmitLtmTargetMacAddress != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress);
			StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddress = StorageOld->dot1agCfmMepTransmitLtmTargetMacAddress;
			StorageTmp->dot1agCfmMepTransmitLtmTargetMacAddressLen = StorageOld->dot1agCfmMepTransmitLtmTargetMacAddressLen;
			StorageOld->dot1agCfmMepTransmitLtmTargetMacAddress = NULL;
			StorageOld->dot1agCfmMepTransmitLtmTargetMacAddressLen = 0;
		}
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmTargetMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmTargetMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmTargetMepId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMepId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMepId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMepId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..8191 */
		if ((0 > set_value || set_value > 8191)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetMepId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLtmTargetMepId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmTargetMepId for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLtmTargetMepId = StorageOld->dot1agCfmMepTransmitLtmTargetMepId;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmTargetIsMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmTargetIsMepId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmTargetIsMepId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetIsMepId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetIsMepId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetIsMepId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTargetIsMepId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLtmTargetIsMepId = StorageOld->dot1agCfmMepTransmitLtmTargetIsMepId;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmTtl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmTtl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmTtl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTtl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTtl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTtl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 64 */
		/* Note: ranges 0..255 */
		if ((0 > set_value || set_value > 255)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmTtl: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepTransmitLtmTtl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmTtl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepTransmitLtmTtl = StorageOld->dot1agCfmMepTransmitLtmTtl;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepTransmitLtmEgressIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepTransmitLtmEgressIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepTransmitLtmEgressIdentifier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmEgressIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmEgressIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 8..8 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 8)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepTransmitLtmEgressIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier);
		StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier = string;
		StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifierLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		if (StorageOld->dot1agCfmMepTransmitLtmEgressIdentifier != NULL) {
			SNMP_FREE(StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier);
			StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifier = StorageOld->dot1agCfmMepTransmitLtmEgressIdentifier;
			StorageTmp->dot1agCfmMepTransmitLtmEgressIdentifierLen = StorageOld->dot1agCfmMepTransmitLtmEgressIdentifierLen;
			StorageOld->dot1agCfmMepTransmitLtmEgressIdentifier = NULL;
			StorageOld->dot1agCfmMepTransmitLtmEgressIdentifierLen = 0;
		}
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepPbbTeCanReportPbbTePresence(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepPbbTeCanReportPbbTePresence(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepPbbTeCanReportPbbTePresence entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeCanReportPbbTePresence: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeCanReportPbbTePresence not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeCanReportPbbTePresence: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeCanReportPbbTePresence: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepPbbTeCanReportPbbTePresence = StorageOld->dot1agCfmMepPbbTeCanReportPbbTePresence;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepPbbTransmitLbmLtmReverseVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepPbbTransmitLbmLtmReverseVid(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepPbbTransmitLbmLtmReverseVid entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTransmitLbmLtmReverseVid: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTransmitLbmLtmReverseVid not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTransmitLbmLtmReverseVid: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..4094 4096..-1 */
		if ((1 > set_value || set_value > 4094) && (4096 > set_value || set_value > -1)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTransmitLbmLtmReverseVid: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid for you to use, and you have just been asked to do something with it.  Note that 
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepPbbTransmitLbmLtmReverseVid = StorageOld->dot1agCfmMepPbbTransmitLbmLtmReverseVid;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepPbbTeMismatchAlarm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepPbbTeMismatchAlarm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepPbbTeMismatchAlarm entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->dot1agCfmMepRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeMismatchAlarm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeMismatchAlarm not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeMismatchAlarm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepPbbTeMismatchAlarm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepTable_rsvs++;
		StorageTmp->dot1agCfmMepPbbTeMismatchAlarm = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepTable_tsts == 0)
				if ((ret = check_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepPbbTeMismatchAlarm for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepTable_sets == 0)
				if ((ret = update_dot1agCfmMepTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			StorageTmp->dot1agCfmMepTable_rsvs = 0;
			StorageTmp->dot1agCfmMepTable_tsts = 0;
			StorageTmp->dot1agCfmMepTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepTable_sets == 0)
			revert_dot1agCfmMepTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepPbbTeMismatchAlarm = StorageOld->dot1agCfmMepPbbTeMismatchAlarm;
		if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
			dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepDbRMepIsActive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_dot1agCfmMepDbRMepIsActive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepDbTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 13;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepDbRMepIsActive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(dot1agCfmMepDbTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDbRMepIsActive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDbRMepIsActive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepDbRMepIsActive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) == NULL)
			if (StorageTmp->dot1agCfmMepDbTable_rsvs == 0)
				if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old = dot1agCfmMepDbTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->dot1agCfmMepDbTable_rsvs++;
		StorageTmp->dot1agCfmMepDbRMepIsActive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->dot1agCfmMepDbTable_tsts == 0)
				if ((ret = check_dot1agCfmMepDbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepDbTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmMepDbRMepIsActive for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->dot1agCfmMepDbTable_sets == 0)
				if ((ret = update_dot1agCfmMepDbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->dot1agCfmMepDbTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) != NULL) {
			dot1agCfmMepDbTable_destroy(&StorageTmp->dot1agCfmMepDbTable_old);
			StorageTmp->dot1agCfmMepDbTable_rsvs = 0;
			StorageTmp->dot1agCfmMepDbTable_tsts = 0;
			StorageTmp->dot1agCfmMepDbTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->dot1agCfmMepDbTable_sets == 0)
			revert_dot1agCfmMepDbTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->dot1agCfmMepDbTable_old) == NULL)
			break;
		StorageTmp->dot1agCfmMepDbRMepIsActive = StorageOld->dot1agCfmMepDbRMepIsActive;
		if (--StorageTmp->dot1agCfmMepDbTable_rsvs == 0)
			dot1agCfmMepDbTable_destroy(&StorageTmp->dot1agCfmMepDbTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmDefaultMdDefLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_dot1agCfmDefaultMdDefLevel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct ieee8021CfmMib_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdDefLevel entering action=%d...  \n", action));
	if ((StorageTmp = ieee8021CfmMibStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefLevel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefLevel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..7 */
		if ((0 > set_value || set_value > 7)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefLevel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			if (StorageTmp->ieee8021CfmMib_rsvs == 0)
				if ((StorageOld = StorageTmp->ieee8021CfmMib_old = ieee8021CfmMib_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->ieee8021CfmMib_rsvs++;
		StorageTmp->dot1agCfmDefaultMdDefLevel = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->ieee8021CfmMib_tsts == 0)
				if ((ret = check_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdDefLevel for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->ieee8021CfmMib_sets == 0)
				if ((ret = update_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
			StorageTmp->ieee8021CfmMib_rsvs = 0;
			StorageTmp->ieee8021CfmMib_tsts = 0;
			StorageTmp->ieee8021CfmMib_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->ieee8021CfmMib_tsts == 0)
			revert_ieee8021CfmMib(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdDefLevel = StorageOld->dot1agCfmDefaultMdDefLevel;
		if (--StorageTmp->ieee8021CfmMib_rsvs == 0)
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmDefaultMdDefMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_dot1agCfmDefaultMdDefMhfCreation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct ieee8021CfmMib_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdDefMhfCreation entering action=%d...  \n", action));
	if ((StorageTmp = ieee8021CfmMibStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefMhfCreation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefMhfCreation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value defMHFnone */
		switch (set_value) {
		case DOT1AGCFMDEFAULTMDDEFMHFCREATION_DEFMHFNONE:
		case DOT1AGCFMDEFAULTMDDEFMHFCREATION_DEFMHFDEFAULT:
		case DOT1AGCFMDEFAULTMDDEFMHFCREATION_DEFMHFEXPLICIT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefMhfCreation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			if (StorageTmp->ieee8021CfmMib_rsvs == 0)
				if ((StorageOld = StorageTmp->ieee8021CfmMib_old = ieee8021CfmMib_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->ieee8021CfmMib_rsvs++;
		StorageTmp->dot1agCfmDefaultMdDefMhfCreation = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->ieee8021CfmMib_tsts == 0)
				if ((ret = check_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdDefMhfCreation for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->ieee8021CfmMib_sets == 0)
				if ((ret = update_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
			StorageTmp->ieee8021CfmMib_rsvs = 0;
			StorageTmp->ieee8021CfmMib_tsts = 0;
			StorageTmp->ieee8021CfmMib_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->ieee8021CfmMib_tsts == 0)
			revert_ieee8021CfmMib(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdDefMhfCreation = StorageOld->dot1agCfmDefaultMdDefMhfCreation;
		if (--StorageTmp->ieee8021CfmMib_rsvs == 0)
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmDefaultMdDefIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_dot1agCfmDefaultMdDefIdPermission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct ieee8021CfmMib_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmDefaultMdDefIdPermission entering action=%d...  \n", action));
	if ((StorageTmp = ieee8021CfmMibStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefIdPermission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefIdPermission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sendIdNone */
		switch (set_value) {
		case DOT1AGCFMDEFAULTMDDEFIDPERMISSION_SENDIDNONE:
		case DOT1AGCFMDEFAULTMDDEFIDPERMISSION_SENDIDCHASSIS:
		case DOT1AGCFMDEFAULTMDDEFIDPERMISSION_SENDIDMANAGE:
		case DOT1AGCFMDEFAULTMDDEFIDPERMISSION_SENDIDCHASSISMANAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmDefaultMdDefIdPermission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			if (StorageTmp->ieee8021CfmMib_rsvs == 0)
				if ((StorageOld = StorageTmp->ieee8021CfmMib_old = ieee8021CfmMib_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->ieee8021CfmMib_rsvs++;
		StorageTmp->dot1agCfmDefaultMdDefIdPermission = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->ieee8021CfmMib_tsts == 0)
				if ((ret = check_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->dot1agCfmDefaultMdDefIdPermission for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->ieee8021CfmMib_sets == 0)
				if ((ret = update_ieee8021CfmMib(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->ieee8021CfmMib_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) != NULL) {
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
			StorageTmp->ieee8021CfmMib_rsvs = 0;
			StorageTmp->ieee8021CfmMib_tsts = 0;
			StorageTmp->ieee8021CfmMib_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->ieee8021CfmMib_tsts == 0)
			revert_ieee8021CfmMib(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->ieee8021CfmMib_old) == NULL)
			break;
		StorageTmp->dot1agCfmDefaultMdDefIdPermission = StorageOld->dot1agCfmDefaultMdDefIdPermission;
		if (--StorageTmp->ieee8021CfmMib_rsvs == 0)
			ieee8021CfmMib_destroy(&StorageTmp->ieee8021CfmMib_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmVlanTable_row(struct dot1agCfmVlanTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmMdTable_row(struct dot1agCfmMdTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmMaNetTable_row(struct dot1agCfmMaNetTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmMaCompTable_row(struct dot1agCfmMaCompTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmMaMepListTable_row(struct dot1agCfmMaMepListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_dot1agCfmMepTable_row(struct dot1agCfmMepTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmVlanRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmVlanRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmVlanTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmVlanTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmVlanRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmVlanTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmVlanRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmVlanComponentId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmVlanVid */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmVlanComponentId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmVlanComponentId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmVlanComponentId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmVlanVid */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmVlanVid: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..4094 */
			if ((1 > (long) *vp->val.integer || (long) *vp->val.integer > 4094)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmVlanVid: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmVlanTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmVlanTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmVlanComponentId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmVlanVid = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmVlanTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmVlanRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmVlanTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) == NULL)
				if (StorageTmp->dot1agCfmVlanTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old = dot1agCfmVlanTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmVlanTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmVlanTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmVlanTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmVlanTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmVlanRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmVlanTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmVlanRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmVlanTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmVlanRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmVlanTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmVlanRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmVlanTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmVlanRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmVlanTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmVlanRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmVlanTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmVlanTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmVlanRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmVlanRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmVlanRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) != NULL) {
				dot1agCfmVlanTable_destroy(&StorageTmp->dot1agCfmVlanTable_old);
				StorageTmp->dot1agCfmVlanTable_rsvs = 0;
				StorageTmp->dot1agCfmVlanTable_tsts = 0;
				StorageTmp->dot1agCfmVlanTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmVlanTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmVlanTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmVlanRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmVlanTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmVlanRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmVlanTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmVlanTable_del(StorageNew);
				dot1agCfmVlanTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmVlanTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmVlanTable_rsvs == 0)
				dot1agCfmVlanTable_destroy(&StorageTmp->dot1agCfmVlanTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmVlanTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMdRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmMdRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMdTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmMdTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMdRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmMdTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMdRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmMdIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmMdIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmMdTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmMdTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmMdIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmMdTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmMdRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmMdTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
				if (StorageTmp->dot1agCfmMdTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmMdTable_old = dot1agCfmMdTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmMdTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmMdTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmMdTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmMdTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmMdRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmMdTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMdRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMdTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMdRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMdTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmMdRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmMdTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMdRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmMdTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMdRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmMdTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmMdTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmMdRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmMdRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmMdRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) != NULL) {
				dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
				StorageTmp->dot1agCfmMdTable_rsvs = 0;
				StorageTmp->dot1agCfmMdTable_tsts = 0;
				StorageTmp->dot1agCfmMdTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmMdTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmMdTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmMdRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmMdTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmMdRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmMdTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmMdTable_del(StorageNew);
				dot1agCfmMdTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmMdTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmMdTable_rsvs == 0)
				dot1agCfmMdTable_destroy(&StorageTmp->dot1agCfmMdTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmMdTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaNetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmMaNetRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaNetTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmMaNetTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaNetRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmMaNetTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaNetRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmMdIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmMdIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmMaNetTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmMaNetTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmMdIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmMaNetTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmMaNetRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmMaNetTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
				if (StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old = dot1agCfmMaNetTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmMaNetTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmMaNetTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmMaNetTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmMaNetTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmMaNetRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmMaNetTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaNetRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaNetTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaNetRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaNetTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmMaNetRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmMaNetTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaNetRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmMaNetTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaNetRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmMaNetTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmMaNetTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmMaNetRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmMaNetRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmMaNetRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) != NULL) {
				dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
				StorageTmp->dot1agCfmMaNetTable_rsvs = 0;
				StorageTmp->dot1agCfmMaNetTable_tsts = 0;
				StorageTmp->dot1agCfmMaNetTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmMaNetTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmMaNetTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmMaNetRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmMaNetTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmMaNetRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmMaNetTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmMaNetTable_del(StorageNew);
				dot1agCfmMaNetTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmMaNetTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmMaNetTable_rsvs == 0)
				dot1agCfmMaNetTable_destroy(&StorageTmp->dot1agCfmMaNetTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmMaNetTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaCompRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmMaCompRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaCompTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmMaCompTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaCompRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmMaCompTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaCompRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmMdIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaComponentId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmMdIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaComponentId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaComponentId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaComponentId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmMaCompTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmMaCompTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmMdIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaComponentId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmMaCompTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmMaCompRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmMaCompTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
				if (StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old = dot1agCfmMaCompTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmMaCompTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmMaCompTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmMaCompTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmMaCompTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmMaCompRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmMaCompTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaCompRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaCompTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaCompRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaCompTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmMaCompRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmMaCompTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaCompRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmMaCompTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaCompRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmMaCompTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmMaCompTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmMaCompRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmMaCompRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmMaCompRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) != NULL) {
				dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
				StorageTmp->dot1agCfmMaCompTable_rsvs = 0;
				StorageTmp->dot1agCfmMaCompTable_tsts = 0;
				StorageTmp->dot1agCfmMaCompTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmMaCompTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmMaCompTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmMaCompRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmMaCompTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmMaCompRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmMaCompTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmMaCompTable_del(StorageNew);
				dot1agCfmMaCompTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmMaCompTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmMaCompTable_rsvs == 0)
				dot1agCfmMaCompTable_destroy(&StorageTmp->dot1agCfmMaCompTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmMaCompTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMaMepListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmMaMepListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMaMepListTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmMaMepListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMaMepListRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmMaMepListTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaMepListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMaMepListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmMdIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaMepListIdentifier */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmMdIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaMepListIdentifier */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaMepListIdentifier: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..8191 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 8191)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaMepListIdentifier: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmMaMepListTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmMaMepListTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmMdIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaMepListIdentifier = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmMaMepListTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmMaMepListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmMaMepListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmMaMepListTable_old) == NULL)
				if (StorageTmp->dot1agCfmMaMepListTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmMaMepListTable_old = dot1agCfmMaMepListTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmMaMepListTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmMaMepListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmMaMepListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmMaMepListTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmMaMepListRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmMaMepListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaMepListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaMepListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMaMepListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMaMepListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmMaMepListRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmMaMepListTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaMepListRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmMaMepListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMaMepListRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmMaMepListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmMaMepListTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmMaMepListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmMaMepListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmMaMepListRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmMaMepListTable_old) != NULL) {
				dot1agCfmMaMepListTable_destroy(&StorageTmp->dot1agCfmMaMepListTable_old);
				StorageTmp->dot1agCfmMaMepListTable_rsvs = 0;
				StorageTmp->dot1agCfmMaMepListTable_tsts = 0;
				StorageTmp->dot1agCfmMaMepListTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmMaMepListTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmMaMepListTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmMaMepListRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmMaMepListTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmMaMepListRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmMaMepListTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmMaMepListTable_del(StorageNew);
				dot1agCfmMaMepListTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmMaMepListTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmMaMepListTable_rsvs == 0)
				dot1agCfmMaMepListTable_destroy(&StorageTmp->dot1agCfmMaMepListTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmMaMepListTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_dot1agCfmMepRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_dot1agCfmMepRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct dot1agCfmMepTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct dot1agCfmMepTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 13;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("ieee8021CfmMib", "write_dot1agCfmMepRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(dot1agCfmMepTableStorage, NULL, &name[13], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to dot1agCfmMepRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* dot1agCfmMdIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMaIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* dot1agCfmMepIdentifier */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[13]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* dot1agCfmMdIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMdIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMaIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMaIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* dot1agCfmMepIdentifier */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMepIdentifier: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..8191 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 8191)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index dot1agCfmMepIdentifier: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = dot1agCfmMepTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->dot1agCfmMepTable_rsvs = 1;
			vp = vars;
			StorageNew->dot1agCfmMdIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMaIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->dot1agCfmMepIdentifier = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&dot1agCfmMepTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->dot1agCfmMepRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->dot1agCfmMepTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
				if (StorageTmp->dot1agCfmMepTable_rsvs == 0)
					if ((StorageOld = StorageTmp->dot1agCfmMepTable_old = dot1agCfmMepTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->dot1agCfmMepTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->dot1agCfmMepTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				dot1agCfmMepTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_dot1agCfmMepTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->dot1agCfmMepRowStatus != RS_ACTIVE)
				if ((ret = can_act_dot1agCfmMepTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMepRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMepTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->dot1agCfmMepRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_dot1agCfmMepTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->dot1agCfmMepRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_dot1agCfmMepTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMepRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_dot1agCfmMepTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->dot1agCfmMepRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_dot1agCfmMepTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_dot1agCfmMepTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->dot1agCfmMepRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->dot1agCfmMepRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->dot1agCfmMepRowStatus = set_value;
			if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) != NULL) {
				dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
				StorageTmp->dot1agCfmMepTable_rsvs = 0;
				StorageTmp->dot1agCfmMepTable_tsts = 0;
				StorageTmp->dot1agCfmMepTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			dot1agCfmMepTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_dot1agCfmMepTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->dot1agCfmMepRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_dot1agCfmMepTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->dot1agCfmMepRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_dot1agCfmMepTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				dot1agCfmMepTable_del(StorageNew);
				dot1agCfmMepTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->dot1agCfmMepTable_old) == NULL)
				break;
			if (--StorageTmp->dot1agCfmMepTable_rsvs == 0)
				dot1agCfmMepTable_destroy(&StorageTmp->dot1agCfmMepTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				dot1agCfmMepTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_dot1agCfmFaultAlarm_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("ieee8021CfmMib", "send_dot1agCfmFaultAlarm_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = dot1agCfmFaultAlarm_oid;
	trap.val_len = sizeof(dot1agCfmFaultAlarm_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/**
 * @fn void ieee8021CfmMib_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
ieee8021CfmMib_loop_handler(int sig)
{
	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (ieee8021CfmMibold_signal_handler != NULL)
		(*ieee8021CfmMibold_signal_handler) (sig);
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
}

/**
 * @fn void ieee8021CfmMib_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
ieee8021CfmMib_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("ieee8021CfmMib", "ieee8021CfmMib_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("ieee8021CfmMib", "done.\n"));
	return;
}
