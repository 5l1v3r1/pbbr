/*****************************************************************************

 @(#) src/snmp/isismib.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/isismib.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "isisMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "isisMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int isisMIB_refresh = 1;
volatile int isisManAreaAddrTable_refresh = 1;
volatile int isisAreaAddrTable_refresh = 1;
volatile int isisSummAddrTable_refresh = 1;
volatile int isisRedistributeAddrTable_refresh = 1;
volatile int isisRouterTable_refresh = 1;
volatile int isisSysLevelTable_refresh = 1;
volatile int isisCircTable_refresh = 1;
volatile int isisCircLevelTable_refresh = 1;
volatile int isisSystemCounterTable_refresh = 1;
volatile int isisCircuitCounterTable_refresh = 1;
volatile int isisPacketCounterTable_refresh = 1;
volatile int isisISAdjTable_refresh = 1;
volatile int isisISAdjAreaAddrTable_refresh = 1;
volatile int isisISAdjIPAddrTable_refresh = 1;
volatile int isisISAdjProtSuppTable_refresh = 1;
volatile int isisRATable_refresh = 1;
volatile int isisIPRATable_refresh = 1;
volatile int isisLSPSummaryTable_refresh = 1;
volatile int isisLSPTLVTable_refresh = 1;

/*
 * isisMIB_variables_oid: object identifier for isisMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid isisMIB_variables_oid[7] = { 1, 3, 6, 1, 2, 1, 138 };
oid isisManAreaAddrTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 1, 2, 1 };
oid isisSummAddrTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 1, 4, 1 };
oid isisRedistributeAddrTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 1, 5, 1 };
oid isisCircTable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 3, 2, 1 };
oid isisRATable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 7, 1, 1 };
oid isisIPRATable_variables_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 8, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid isisDatabaseOverload_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 1 };
oid isisManualAddressDrops_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 2 };
oid isisCorruptedLSPDetected_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 3 };
oid isisAttemptToExceedMaxSequence_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 4 };
oid isisIDLenMismatch_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 5 };
oid isisMaxAreaAddressesMismatch_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 6 };
oid isisOwnLSPPurge_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 7 };
oid isisSequenceNumberSkip_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 8 };
oid isisAuthenticationTypeFailure_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 9 };
oid isisAuthenticationFailure_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 10 };
oid isisVersionSkew_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 11 };
oid isisAreaMismatch_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 12 };
oid isisRejectedAdjacency_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 13 };
oid isisLSPTooLargeToPropagate_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 14 };
oid isisOrigLSPBuffSizeMismatch_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 15 };
oid isisProtocolsSupportedMismatch_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 16 };
oid isisAdjacencyChange_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 17 };
oid isisLSPErrorDetected_oid[9] = { 1, 3, 6, 1, 2, 1, 138, 0, 18 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid isisNotificationSysLevelIndex_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 1 };
oid isisNotificationCircIfIndex_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 2 };
oid isisPduLspId_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 3 };
oid isisPduFragment_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 4 };
oid isisPduFieldLen_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 5 };
oid isisPduMaxAreaAddress_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 6 };
oid isisPduProtocolVersion_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 7 };
oid isisPduLspSize_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 8 };
oid isisPduOriginatingBufferSize_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 9 };
oid isisPduBufferSize_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 10 };
oid isisPduProtocolsSupported_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 11 };
oid isisAdjState_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 12 };
oid isisErrorOffset_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 13 };
oid isisErrorTLVType_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 14 };
oid isisNotificationAreaAddress_oid[11] = { 1, 3, 6, 1, 2, 1, 138, 1, 10, 1, 15 };

/*
 * Other oids defined in this MIB.
 */
oid isisCompliance_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 1, 1 };
oid isisAdvancedCompliance_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 1, 2 };
oid isisReadOnlyCompliance_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 1, 3 };
oid isisSystemGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 1 };
oid isisCircuitGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 2 };
oid isisISAdjGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 3 };
oid isisNotificationObjectGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 4 };
oid isisNotificationGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 5 };
oid isisISPDUCounterGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 6 };
oid isisRATableGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 7 };
oid isisISIPRADestGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 8 };
oid isisLSPGroup_oid[10] = { 1, 3, 6, 1, 2, 1, 138, 2, 2, 9 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 isisMIB_variables: tree for isisMIB
 * This variable defines function callbacks and type return information for the isisMIB mib section
 */
struct variable7 isisMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   ISISSYSVERSION        1
	{(u_char) ISISSYSVERSION, ASN_INTEGER, RONLY, var_isisMIB, 4, {1, 1, 1, 1}},
#define   ISISSYSLEVELTYPE      2
	{(u_char) ISISSYSLEVELTYPE, ASN_INTEGER, RWRITE, var_isisMIB, 4, {1, 1, 1, 2}},
#define   ISISSYSID             3
	{(u_char) ISISSYSID, ASN_OCTET_STR, RWRITE, var_isisMIB, 4, {1, 1, 1, 3}},
#define   ISISSYSMAXPATHSPLITS  4
	{(u_char) ISISSYSMAXPATHSPLITS, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 4}},
#define   ISISSYSMAXLSPGENINT   5
	{(u_char) ISISSYSMAXLSPGENINT, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 5}},
#define   ISISSYSPOLLESHELLORATE  6
	{(u_char) ISISSYSPOLLESHELLORATE, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 6}},
#define   ISISSYSWAITTIME       7
	{(u_char) ISISSYSWAITTIME, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 7}},
#define   ISISSYSADMINSTATE     8
	{(u_char) ISISSYSADMINSTATE, ASN_INTEGER, RWRITE, var_isisMIB, 4, {1, 1, 1, 8}},
#define   ISISSYSL2TOL1LEAKING  9
	{(u_char) ISISSYSL2TOL1LEAKING, ASN_INTEGER, RWRITE, var_isisMIB, 4, {1, 1, 1, 9}},
#define   ISISSYSMAXAGE         10
	{(u_char) ISISSYSMAXAGE, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 10}},
#define   ISISSYSRECEIVELSPBUFFERSIZE  11
	{(u_char) ISISSYSRECEIVELSPBUFFERSIZE, ASN_UNSIGNED, RWRITE, var_isisMIB, 4, {1, 1, 1, 11}},
#define   ISISSYSPROTSUPPORTED  12
	{(u_char) ISISSYSPROTSUPPORTED, ASN_OCTET_STR, RONLY, var_isisMIB, 4, {1, 1, 1, 12}},
#define   ISISSYSNOTIFICATIONENABLE  13
	{(u_char) ISISSYSNOTIFICATIONENABLE, ASN_INTEGER, RWRITE, var_isisMIB, 4, {1, 1, 1, 13}},
#define   ISISMANAREAADDREXISTSTATE  14
	{(u_char) ISISMANAREAADDREXISTSTATE, ASN_INTEGER, RWRITE, var_isisManAreaAddrTable, 5, {1, 1, 2, 1, 2}},
#define   ISISSUMMADDREXISTSTATE  16
	{(u_char) ISISSUMMADDREXISTSTATE, ASN_INTEGER, RWRITE, var_isisSummAddrTable, 5, {1, 1, 4, 1, 4}},
#define   ISISSUMMADDRMETRIC    17
	{(u_char) ISISSUMMADDRMETRIC, ASN_UNSIGNED, RWRITE, var_isisSummAddrTable, 5, {1, 1, 4, 1, 5}},
#define   ISISSUMMADDRFULLMETRIC  18
	{(u_char) ISISSUMMADDRFULLMETRIC, ASN_UNSIGNED, RWRITE, var_isisSummAddrTable, 5, {1, 1, 4, 1, 6}},
#define   ISISREDISTRIBUTEADDREXISTSTATE  19
	{(u_char) ISISREDISTRIBUTEADDREXISTSTATE, ASN_INTEGER, RWRITE, var_isisRedistributeAddrTable, 5, {1, 1, 5, 1, 4}},
#define   ISISROUTERHOSTNAME    20
	{(u_char) ISISROUTERHOSTNAME, ASN_OCTET_STR, RONLY, var_isisRouterTable, 5, {1, 1, 6, 1, 3}},
#define   ISISROUTERID          21
	{(u_char) ISISROUTERID, ASN_UNSIGNED, RONLY, var_isisRouterTable, 5, {1, 1, 6, 1, 4}},
#define   ISISSYSLEVELORIGLSPBUFFSIZE  22
	{(u_char) ISISSYSLEVELORIGLSPBUFFSIZE, ASN_UNSIGNED, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 2}},
#define   ISISSYSLEVELMINLSPGENINT  23
	{(u_char) ISISSYSLEVELMINLSPGENINT, ASN_UNSIGNED, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 3}},
#define   ISISSYSLEVELSTATE     24
	{(u_char) ISISSYSLEVELSTATE, ASN_INTEGER, RONLY, var_isisSysLevelTable, 5, {1, 2, 1, 1, 4}},
#define   ISISSYSLEVELSETOVERLOAD  25
	{(u_char) ISISSYSLEVELSETOVERLOAD, ASN_INTEGER, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 5}},
#define   ISISSYSLEVELSETOVERLOADUNTIL  26
	{(u_char) ISISSYSLEVELSETOVERLOADUNTIL, ASN_UNSIGNED, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 6}},
#define   ISISSYSLEVELMETRICSTYLE  27
	{(u_char) ISISSYSLEVELMETRICSTYLE, ASN_INTEGER, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 7}},
#define   ISISSYSLEVELSPFCONSIDERS  28
	{(u_char) ISISSYSLEVELSPFCONSIDERS, ASN_INTEGER, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 8}},
#define   ISISSYSLEVELTEENABLED  29
	{(u_char) ISISSYSLEVELTEENABLED, ASN_INTEGER, RWRITE, var_isisSysLevelTable, 5, {1, 2, 1, 1, 9}},
#define   ISISNEXTCIRCINDEX     30
	{(u_char) ISISNEXTCIRCINDEX, ASN_UNSIGNED, RONLY, var_isisMIB, 3, {1, 3, 1}},
#define   ISISCIRCIFINDEX       31
	{(u_char) ISISCIRCIFINDEX, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 2}},
#define   ISISCIRCADMINSTATE    32
	{(u_char) ISISCIRCADMINSTATE, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 3}},
#define   ISISCIRCEXISTSTATE    33
	{(u_char) ISISCIRCEXISTSTATE, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 4}},
#define   ISISCIRCTYPE          34
	{(u_char) ISISCIRCTYPE, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 5}},
#define   ISISCIRCEXTDOMAIN     35
	{(u_char) ISISCIRCEXTDOMAIN, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 6}},
#define   ISISCIRCLEVELTYPE     36
	{(u_char) ISISCIRCLEVELTYPE, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 7}},
#define   ISISCIRCPASSIVECIRCUIT  37
	{(u_char) ISISCIRCPASSIVECIRCUIT, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 8}},
#define   ISISCIRCMESHGROUPENABLED  38
	{(u_char) ISISCIRCMESHGROUPENABLED, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 9}},
#define   ISISCIRCMESHGROUP     39
	{(u_char) ISISCIRCMESHGROUP, ASN_UNSIGNED, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 10}},
#define   ISISCIRCSMALLHELLOS   40
	{(u_char) ISISCIRCSMALLHELLOS, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 11}},
#define   ISISCIRCLASTUPTIME    41
	{(u_char) ISISCIRCLASTUPTIME, ASN_TIMETICKS, RONLY, var_isisCircTable, 5, {1, 3, 2, 1, 12}},
#define   ISISCIRC3WAYENABLED   42
	{(u_char) ISISCIRC3WAYENABLED, ASN_INTEGER, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 13}},
#define   ISISCIRCEXTENDEDCIRCID  43
	{(u_char) ISISCIRCEXTENDEDCIRCID, ASN_UNSIGNED, RWRITE, var_isisCircTable, 5, {1, 3, 2, 1, 14}},
#define   ISISCIRCLEVELMETRIC   44
	{(u_char) ISISCIRCLEVELMETRIC, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 2}},
#define   ISISCIRCLEVELWIDEMETRIC  45
	{(u_char) ISISCIRCLEVELWIDEMETRIC, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 3}},
#define   ISISCIRCLEVELISPRIORITY  46
	{(u_char) ISISCIRCLEVELISPRIORITY, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 4}},
#define   ISISCIRCLEVELIDOCTET  47
	{(u_char) ISISCIRCLEVELIDOCTET, ASN_UNSIGNED, RONLY, var_isisCircLevelTable, 5, {1, 4, 1, 1, 5}},
#define   ISISCIRCLEVELID       48
	{(u_char) ISISCIRCLEVELID, ASN_OCTET_STR, RONLY, var_isisCircLevelTable, 5, {1, 4, 1, 1, 6}},
#define   ISISCIRCLEVELDESIS    49
	{(u_char) ISISCIRCLEVELDESIS, ASN_OCTET_STR, RONLY, var_isisCircLevelTable, 5, {1, 4, 1, 1, 7}},
#define   ISISCIRCLEVELHELLOMULTIPLIER  50
	{(u_char) ISISCIRCLEVELHELLOMULTIPLIER, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 8}},
#define   ISISCIRCLEVELHELLOTIMER  51
	{(u_char) ISISCIRCLEVELHELLOTIMER, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 9}},
#define   ISISCIRCLEVELDRHELLOTIMER  52
	{(u_char) ISISCIRCLEVELDRHELLOTIMER, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 10}},
#define   ISISCIRCLEVELLSPTHROTTLE  53
	{(u_char) ISISCIRCLEVELLSPTHROTTLE, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 11}},
#define   ISISCIRCLEVELMINLSPRETRANSINT  54
	{(u_char) ISISCIRCLEVELMINLSPRETRANSINT, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 12}},
#define   ISISCIRCLEVELCSNPINTERVAL  55
	{(u_char) ISISCIRCLEVELCSNPINTERVAL, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 13}},
#define   ISISCIRCLEVELPARTSNPINTERVAL  56
	{(u_char) ISISCIRCLEVELPARTSNPINTERVAL, ASN_UNSIGNED, RWRITE, var_isisCircLevelTable, 5, {1, 4, 1, 1, 14}},
#define   ISISSYSSTATCORRLSPS   57
	{(u_char) ISISSYSSTATCORRLSPS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 2}},
#define   ISISSYSSTATAUTHTYPEFAILS  58
	{(u_char) ISISSYSSTATAUTHTYPEFAILS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 3}},
#define   ISISSYSSTATAUTHFAILS  59
	{(u_char) ISISSYSSTATAUTHFAILS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 4}},
#define   ISISSYSSTATLSPDBASEOLOADS  60
	{(u_char) ISISSYSSTATLSPDBASEOLOADS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 5}},
#define   ISISSYSSTATMANADDRDROPFROMAREAS  61
	{(u_char) ISISSYSSTATMANADDRDROPFROMAREAS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 6}},
#define   ISISSYSSTATATTMPTTOEXMAXSEQNUMS  62
	{(u_char) ISISSYSSTATATTMPTTOEXMAXSEQNUMS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 7}},
#define   ISISSYSSTATSEQNUMSKIPS  63
	{(u_char) ISISSYSSTATSEQNUMSKIPS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 8}},
#define   ISISSYSSTATOWNLSPPURGES  64
	{(u_char) ISISSYSSTATOWNLSPPURGES, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 9}},
#define   ISISSYSSTATIDFIELDLENMISMATCHES  65
	{(u_char) ISISSYSSTATIDFIELDLENMISMATCHES, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 10}},
#define   ISISSYSSTATPARTCHANGES  66
	{(u_char) ISISSYSSTATPARTCHANGES, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 11}},
#define   ISISSYSSTATSPFRUNS    67
	{(u_char) ISISSYSSTATSPFRUNS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 12}},
#define   ISISSYSSTATLSPERRORS  68
	{(u_char) ISISSYSSTATLSPERRORS, ASN_COUNTER, RONLY, var_isisSystemCounterTable, 5, {1, 5, 1, 1, 13}},
#define   ISISCIRCADJCHANGES    69
	{(u_char) ISISCIRCADJCHANGES, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 2}},
#define   ISISCIRCNUMADJ        70
	{(u_char) ISISCIRCNUMADJ, ASN_UNSIGNED, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 3}},
#define   ISISCIRCINITFAILS     71
	{(u_char) ISISCIRCINITFAILS, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 4}},
#define   ISISCIRCREJADJS       72
	{(u_char) ISISCIRCREJADJS, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 5}},
#define   ISISCIRCIDFIELDLENMISMATCHES  73
	{(u_char) ISISCIRCIDFIELDLENMISMATCHES, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 6}},
#define   ISISCIRCMAXAREAADDRMISMATCHES  74
	{(u_char) ISISCIRCMAXAREAADDRMISMATCHES, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 7}},
#define   ISISCIRCAUTHTYPEFAILS  75
	{(u_char) ISISCIRCAUTHTYPEFAILS, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 8}},
#define   ISISCIRCAUTHFAILS     76
	{(u_char) ISISCIRCAUTHFAILS, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 9}},
#define   ISISCIRCLANDESISCHANGES  77
	{(u_char) ISISCIRCLANDESISCHANGES, ASN_COUNTER, RONLY, var_isisCircuitCounterTable, 5, {1, 5, 2, 1, 10}},
#define   ISISPACKETCOUNTIIHELLO  78
	{(u_char) ISISPACKETCOUNTIIHELLO, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 3}},
#define   ISISPACKETCOUNTISHELLO  79
	{(u_char) ISISPACKETCOUNTISHELLO, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 4}},
#define   ISISPACKETCOUNTESHELLO  80
	{(u_char) ISISPACKETCOUNTESHELLO, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 5}},
#define   ISISPACKETCOUNTLSP    81
	{(u_char) ISISPACKETCOUNTLSP, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 6}},
#define   ISISPACKETCOUNTCSNP   82
	{(u_char) ISISPACKETCOUNTCSNP, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 7}},
#define   ISISPACKETCOUNTPSNP   83
	{(u_char) ISISPACKETCOUNTPSNP, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 8}},
#define   ISISPACKETCOUNTUNKNOWN  84
	{(u_char) ISISPACKETCOUNTUNKNOWN, ASN_COUNTER, RONLY, var_isisPacketCounterTable, 5, {1, 5, 3, 1, 9}},
#define   ISISISADJSTATE        85
	{(u_char) ISISISADJSTATE, ASN_INTEGER, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 2}},
#define   ISISISADJ3WAYSTATE    86
	{(u_char) ISISISADJ3WAYSTATE, ASN_INTEGER, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 3}},
#define   ISISISADJNEIGHSNPAADDRESS  87
	{(u_char) ISISISADJNEIGHSNPAADDRESS, ASN_OCTET_STR, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 4}},
#define   ISISISADJNEIGHSYSTYPE  88
	{(u_char) ISISISADJNEIGHSYSTYPE, ASN_INTEGER, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 5}},
#define   ISISISADJNEIGHSYSID   89
	{(u_char) ISISISADJNEIGHSYSID, ASN_OCTET_STR, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 6}},
#define   ISISISADJNBREXTENDEDCIRCID  90
	{(u_char) ISISISADJNBREXTENDEDCIRCID, ASN_UNSIGNED, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 7}},
#define   ISISISADJUSAGE        91
	{(u_char) ISISISADJUSAGE, ASN_INTEGER, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 8}},
#define   ISISISADJHOLDTIMER    92
	{(u_char) ISISISADJHOLDTIMER, ASN_UNSIGNED, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 9}},
#define   ISISISADJNEIGHPRIORITY  93
	{(u_char) ISISISADJNEIGHPRIORITY, ASN_UNSIGNED, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 10}},
#define   ISISISADJLASTUPTIME   94
	{(u_char) ISISISADJLASTUPTIME, ASN_TIMETICKS, RONLY, var_isisISAdjTable, 5, {1, 6, 1, 1, 11}},
#define   ISISISADJAREAADDRESS  95
	{(u_char) ISISISADJAREAADDRESS, ASN_OCTET_STR, RONLY, var_isisISAdjAreaAddrTable, 5, {1, 6, 2, 1, 2}},
#define   ISISISADJIPADDRTYPE   96
	{(u_char) ISISISADJIPADDRTYPE, ASN_INTEGER, RONLY, var_isisISAdjIPAddrTable, 5, {1, 6, 3, 1, 2}},
#define   ISISISADJIPADDRADDRESS  97
	{(u_char) ISISISADJIPADDRADDRESS, ASN_OCTET_STR, RONLY, var_isisISAdjIPAddrTable, 5, {1, 6, 3, 1, 3}},
#define   ISISRAEXISTSTATE      99
	{(u_char) ISISRAEXISTSTATE, ASN_INTEGER, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 2}},
#define   ISISRAADMINSTATE      100
	{(u_char) ISISRAADMINSTATE, ASN_INTEGER, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 3}},
#define   ISISRAADDRPREFIX      101
	{(u_char) ISISRAADDRPREFIX, ASN_OCTET_STR, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 4}},
#define   ISISRAMAPTYPE         102
	{(u_char) ISISRAMAPTYPE, ASN_INTEGER, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 5}},
#define   ISISRAMETRIC          103
	{(u_char) ISISRAMETRIC, ASN_UNSIGNED, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 6}},
#define   ISISRAMETRICTYPE      104
	{(u_char) ISISRAMETRICTYPE, ASN_INTEGER, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 7}},
#define   ISISRASNPAADDRESS     105
	{(u_char) ISISRASNPAADDRESS, ASN_OCTET_STR, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 8}},
#define   ISISRASNPAMASK        106
	{(u_char) ISISRASNPAMASK, ASN_OCTET_STR, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 9}},
#define   ISISRASNPAPREFIX      107
	{(u_char) ISISRASNPAPREFIX, ASN_OCTET_STR, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 10}},
#define   ISISRATYPE            108
	{(u_char) ISISRATYPE, ASN_INTEGER, RWRITE, var_isisRATable, 5, {1, 7, 1, 1, 11}},
#define   ISISIPRANEXTHOPTYPE   109
	{(u_char) ISISIPRANEXTHOPTYPE, ASN_INTEGER, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 5}},
#define   ISISIPRANEXTHOP       110
	{(u_char) ISISIPRANEXTHOP, ASN_OCTET_STR, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 6}},
#define   ISISIPRATYPE          111
	{(u_char) ISISIPRATYPE, ASN_INTEGER, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 7}},
#define   ISISIPRAEXISTSTATE    112
	{(u_char) ISISIPRAEXISTSTATE, ASN_INTEGER, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 8}},
#define   ISISIPRAADMINSTATE    113
	{(u_char) ISISIPRAADMINSTATE, ASN_INTEGER, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 9}},
#define   ISISIPRAMETRIC        114
	{(u_char) ISISIPRAMETRIC, ASN_UNSIGNED, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 10}},
#define   ISISIPRAMETRICTYPE    115
	{(u_char) ISISIPRAMETRICTYPE, ASN_INTEGER, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 11}},
#define   ISISIPRAFULLMETRIC    116
	{(u_char) ISISIPRAFULLMETRIC, ASN_UNSIGNED, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 12}},
#define   ISISIPRASNPAADDRESS   117
	{(u_char) ISISIPRASNPAADDRESS, ASN_OCTET_STR, RWRITE, var_isisIPRATable, 5, {1, 8, 1, 1, 13}},
#define   ISISIPRASOURCETYPE    118
	{(u_char) ISISIPRASOURCETYPE, ASN_INTEGER, RONLY, var_isisIPRATable, 5, {1, 8, 1, 1, 14}},
#define   ISISLSPSEQ            119
	{(u_char) ISISLSPSEQ, ASN_UNSIGNED, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 3}},
#define   ISISLSPZEROLIFE       120
	{(u_char) ISISLSPZEROLIFE, ASN_INTEGER, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 4}},
#define   ISISLSPCHECKSUM       121
	{(u_char) ISISLSPCHECKSUM, ASN_UNSIGNED, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 5}},
#define   ISISLSPLIFETIMEREMAIN  122
	{(u_char) ISISLSPLIFETIMEREMAIN, ASN_UNSIGNED, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 6}},
#define   ISISLSPPDULENGTH      123
	{(u_char) ISISLSPPDULENGTH, ASN_UNSIGNED, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 7}},
#define   ISISLSPATTRIBUTES     124
	{(u_char) ISISLSPATTRIBUTES, ASN_UNSIGNED, RONLY, var_isisLSPSummaryTable, 5, {1, 9, 1, 1, 8}},
#define   ISISLSPTLVSEQ         125
	{(u_char) ISISLSPTLVSEQ, ASN_UNSIGNED, RONLY, var_isisLSPTLVTable, 5, {1, 9, 2, 1, 2}},
#define   ISISLSPTLVCHECKSUM    126
	{(u_char) ISISLSPTLVCHECKSUM, ASN_UNSIGNED, RONLY, var_isisLSPTLVTable, 5, {1, 9, 2, 1, 3}},
#define   ISISLSPTLVTYPE        127
	{(u_char) ISISLSPTLVTYPE, ASN_UNSIGNED, RONLY, var_isisLSPTLVTable, 5, {1, 9, 2, 1, 4}},
#define   ISISLSPTLVLEN         128
	{(u_char) ISISLSPTLVLEN, ASN_UNSIGNED, RONLY, var_isisLSPTLVTable, 5, {1, 9, 2, 1, 5}},
#define   ISISLSPTLVVALUE       129
	{(u_char) ISISLSPTLVVALUE, ASN_OCTET_STR, RONLY, var_isisLSPTLVTable, 5, {1, 9, 2, 1, 6}},
};

/* (L = length of the oidsuffix) */
struct isisMIB_data *isisMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *isisManAreaAddrTableStorage = NULL;
struct header_complex_index *isisAreaAddrTableStorage = NULL;
struct header_complex_index *isisSummAddrTableStorage = NULL;
struct header_complex_index *isisRedistributeAddrTableStorage = NULL;
struct header_complex_index *isisRouterTableStorage = NULL;
struct header_complex_index *isisSysLevelTableStorage = NULL;
struct header_complex_index *isisCircTableStorage = NULL;
struct header_complex_index *isisCircLevelTableStorage = NULL;
struct header_complex_index *isisSystemCounterTableStorage = NULL;
struct header_complex_index *isisCircuitCounterTableStorage = NULL;
struct header_complex_index *isisPacketCounterTableStorage = NULL;
struct header_complex_index *isisISAdjTableStorage = NULL;
struct header_complex_index *isisISAdjAreaAddrTableStorage = NULL;
struct header_complex_index *isisISAdjIPAddrTableStorage = NULL;
struct header_complex_index *isisISAdjProtSuppTableStorage = NULL;
struct header_complex_index *isisRATableStorage = NULL;
struct header_complex_index *isisIPRATableStorage = NULL;
struct header_complex_index *isisLSPSummaryTableStorage = NULL;
struct header_complex_index *isisLSPTLVTableStorage = NULL;

void (*isisMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void isisMIB_loop_handler(int);
void isisMIB_fd_handler(int, void *);

/**
 * @fn void init_isisMIB(void)
 * @brief isisMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (isisMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_isisMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("isisMIB", "init_isisMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("isisMIB", isisMIB_variables, variable7, isisMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_isisMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("isisMIB", parse_isisMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("isisManAreaAddrTable", parse_isisManAreaAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisAreaAddrTable", parse_isisAreaAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisSummAddrTable", parse_isisSummAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisRedistributeAddrTable", parse_isisRedistributeAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisRouterTable", parse_isisRouterTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisSysLevelTable", parse_isisSysLevelTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisCircTable", parse_isisCircTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisCircLevelTable", parse_isisCircLevelTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisSystemCounterTable", parse_isisSystemCounterTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisCircuitCounterTable", parse_isisCircuitCounterTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisPacketCounterTable", parse_isisPacketCounterTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisISAdjTable", parse_isisISAdjTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisISAdjAreaAddrTable", parse_isisISAdjAreaAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisISAdjIPAddrTable", parse_isisISAdjIPAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisISAdjProtSuppTable", parse_isisISAdjProtSuppTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisRATable", parse_isisRATable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisIPRATable", parse_isisIPRATable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisLSPSummaryTable", parse_isisLSPSummaryTable, NULL, "HELP STRING");
	snmpd_register_config_handler("isisLSPTLVTable", parse_isisLSPTLVTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisManAreaAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisAreaAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisSummAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisRedistributeAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisRouterTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisSysLevelTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisCircTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisCircLevelTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisSystemCounterTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisCircuitCounterTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisPacketCounterTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisISAdjTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisISAdjAreaAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisISAdjIPAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisISAdjProtSuppTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisRATable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisIPRATable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisLSPSummaryTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_isisLSPTLVTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, isisMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, isisMIB_fd_handler, (void *) 1);
	}
	isisMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &isisMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/**
 * @fn void deinit_isisMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (isisMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_isisMIB(void)
{
	DEBUGMSGTL(("isisMIB", "deinit_isisMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = isisMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(isisMIB_variables_oid, sizeof(isisMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("isisMIB");
	snmpd_unregister_config_handler("isisManAreaAddrTable");
	snmpd_unregister_config_handler("isisAreaAddrTable");
	snmpd_unregister_config_handler("isisSummAddrTable");
	snmpd_unregister_config_handler("isisRedistributeAddrTable");
	snmpd_unregister_config_handler("isisRouterTable");
	snmpd_unregister_config_handler("isisSysLevelTable");
	snmpd_unregister_config_handler("isisCircTable");
	snmpd_unregister_config_handler("isisCircLevelTable");
	snmpd_unregister_config_handler("isisSystemCounterTable");
	snmpd_unregister_config_handler("isisCircuitCounterTable");
	snmpd_unregister_config_handler("isisPacketCounterTable");
	snmpd_unregister_config_handler("isisISAdjTable");
	snmpd_unregister_config_handler("isisISAdjAreaAddrTable");
	snmpd_unregister_config_handler("isisISAdjIPAddrTable");
	snmpd_unregister_config_handler("isisISAdjProtSuppTable");
	snmpd_unregister_config_handler("isisRATable");
	snmpd_unregister_config_handler("isisIPRATable");
	snmpd_unregister_config_handler("isisLSPSummaryTable");
	snmpd_unregister_config_handler("isisLSPTLVTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

int
term_isisMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("isisMIB", "term_isisMIB: terminating...  "));
	deinit_isisMIB();
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct isisMIB_data *isisMIB_create(void)
 * @brief create a fresh data structure representing scalars in isisMIB.
 *
 * Creates a new isisMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in isisMIB.
 */
struct isisMIB_data *
isisMIB_create(void)
{
	struct isisMIB_data *StorageNew = SNMP_MALLOC_STRUCT(isisMIB_data);

	DEBUGMSGTL(("isisMIB", "isisMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->isisSysVersion = ISISSYSVERSION_ONE;
		StorageNew->isisSysLevelType = ISISSYSLEVELTYPE_LEVEL1AND2;
		if ((StorageNew->isisSysID = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisSysIDLen = 0;
		StorageNew->isisSysID[StorageNew->isisSysIDLen] = 0;
		StorageNew->isisSysMaxPathSplits = 2;
		StorageNew->isisSysMaxLSPGenInt = 900;
		StorageNew->isisSysPollESHelloRate = 50;
		StorageNew->isisSysWaitTime = 60;
		StorageNew->isisSysAdminState = ISISSYSADMINSTATE_OFF;
		StorageNew->isisSysL2toL1Leaking = TV_FALSE;
		StorageNew->isisSysMaxAge = 1200;
		StorageNew->isisSysReceiveLSPBufferSize = 1492;
		if (memdup((u_char **) &StorageNew->isisSysProtSupported, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->isisSysProtSupportedLen = 1;
		StorageNew->isisSysNotificationEnable = TV_TRUE;
		StorageNew->isisNextCircIndex = 0;

	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisMIB_data *isisMIB_duplicate(struct isisMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct isisMIB_data *
isisMIB_duplicate(struct isisMIB_data *thedata)
{
	struct isisMIB_data *StorageNew = SNMP_MALLOC_STRUCT(isisMIB_data);

	DEBUGMSGTL(("isisMIB", "isisMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		StorageNew->isisSysVersion = thedata->isisSysVersion;
		StorageNew->isisSysLevelType = thedata->isisSysLevelType;
		if (!(StorageNew->isisSysID = malloc(thedata->isisSysIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisSysID, thedata->isisSysID, thedata->isisSysIDLen);
		StorageNew->isisSysIDLen = thedata->isisSysIDLen;
		StorageNew->isisSysID[StorageNew->isisSysIDLen] = 0;
		StorageNew->isisSysMaxPathSplits = thedata->isisSysMaxPathSplits;
		StorageNew->isisSysMaxLSPGenInt = thedata->isisSysMaxLSPGenInt;
		StorageNew->isisSysPollESHelloRate = thedata->isisSysPollESHelloRate;
		StorageNew->isisSysWaitTime = thedata->isisSysWaitTime;
		StorageNew->isisSysAdminState = thedata->isisSysAdminState;
		StorageNew->isisSysL2toL1Leaking = thedata->isisSysL2toL1Leaking;
		StorageNew->isisSysMaxAge = thedata->isisSysMaxAge;
		StorageNew->isisSysReceiveLSPBufferSize = thedata->isisSysReceiveLSPBufferSize;
		if (!(StorageNew->isisSysProtSupported = malloc(thedata->isisSysProtSupportedLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisSysProtSupported, thedata->isisSysProtSupported, thedata->isisSysProtSupportedLen);
		StorageNew->isisSysProtSupportedLen = thedata->isisSysProtSupportedLen;
		StorageNew->isisSysProtSupported[StorageNew->isisSysProtSupportedLen] = 0;
		StorageNew->isisSysNotificationEnable = thedata->isisSysNotificationEnable;
		StorageNew->isisNextCircIndex = thedata->isisNextCircIndex;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisMIB_destroy(struct isisMIB_data **thedata)
 * @param thedata pointer to the data structure in isisMIB.
 * @brief delete a scalars structure from isisMIB.
 *
 * Frees scalars that were previously removed from isisMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisMIB_destroy(struct isisMIB_data **thedata)
{
	struct isisMIB_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisSysID);
		StorageDel->isisSysIDLen = 0;
		SNMP_FREE(StorageDel->isisSysProtSupported);
		StorageDel->isisSysProtSupportedLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisMIB_add(struct isisMIB_data *thedata)
 * @param thedata the structure representing isisMIB scalars.
 * @brief adds node to the isisMIB scalar data set.
 *
 * Adds a scalar structure to the isisMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
isisMIB_add(struct isisMIB_data *thedata)
{
	DEBUGMSGTL(("isisMIB", "isisMIB_add: adding data...  "));
	if (thedata)
		isisMIBStorage = thedata;
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_isisMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct isisMIB_data *StorageTmp = isisMIB_create();

	DEBUGMSGTL(("isisMIB", "parse_isisMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysVersion, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelType, &tmpsize);
	SNMP_FREE(StorageTmp->isisSysID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisSysID, &StorageTmp->isisSysIDLen);
	if (StorageTmp->isisSysID == NULL) {
		config_perror("invalid specification for isisSysID");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysMaxPathSplits, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysMaxLSPGenInt, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysPollESHelloRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysWaitTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysL2toL1Leaking, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysMaxAge, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysReceiveLSPBufferSize, &tmpsize);
	SNMP_FREE(StorageTmp->isisSysProtSupported);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisSysProtSupported, &StorageTmp->isisSysProtSupportedLen);
	if (StorageTmp->isisSysProtSupported == NULL) {
		config_perror("invalid specification for isisSysProtSupported");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysNotificationEnable, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisNextCircIndex, &tmpsize);
	isisMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_isisMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisMIB_data *StorageTmp;

	DEBUGMSGTL(("isisMIB", "store_isisMIB: storing data...  "));
	refresh_isisMIB(1);
	if ((StorageTmp = isisMIBStorage) == NULL) {
		DEBUGMSGTL(("isisMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "isisMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysVersion, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelType, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisSysID, &StorageTmp->isisSysIDLen);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysMaxPathSplits, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysMaxLSPGenInt, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysPollESHelloRate, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysWaitTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysAdminState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysL2toL1Leaking, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysMaxAge, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysReceiveLSPBufferSize, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisSysProtSupported, &StorageTmp->isisSysProtSupportedLen);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysNotificationEnable, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisNextCircIndex, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_isisMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_isisMIB(struct 
 * @fn void revert_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_isisMIB(struct isisMIB_data *StorageTmp, struct isisMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_isisMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of isisMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_isisMIB(int force)
{
	if (isisMIBStorage == NULL) {
		struct isisMIB_data *StorageNew;

		if ((StorageNew = isisMIB_create()) == NULL)
			return;
		isisMIBStorage = StorageNew;
		isisMIB_refresh = 1;
	}
	if (!force && isisMIB_refresh == 0)
		return;
	DEBUGMSGTL(("isisMIB", "refresh_isisMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	isisMIB_refresh = 0;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/**
 * @fn u_char * var_isisMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in isisMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_isisMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_isisMIB(0);
	if ((StorageTmp = isisMIBStorage) == NULL) {
		DEBUGMSGTL(("isisMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISSYSVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysVersion);
		rval = (u_char *) &StorageTmp->isisSysVersion;
		break;
	case (u_char) ISISSYSLEVELTYPE:	/* ReadWrite */
		*write_method = write_isisSysLevelType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelType);
		rval = (u_char *) &StorageTmp->isisSysLevelType;
		break;
	case (u_char) ISISSYSID:	/* ReadWrite */
		*write_method = write_isisSysID;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisSysIDLen;
		rval = (u_char *) StorageTmp->isisSysID;
		break;
	case (u_char) ISISSYSMAXPATHSPLITS:	/* ReadWrite */
		*write_method = write_isisSysMaxPathSplits;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysMaxPathSplits);
		rval = (u_char *) &StorageTmp->isisSysMaxPathSplits;
		break;
	case (u_char) ISISSYSMAXLSPGENINT:	/* ReadWrite */
		*write_method = write_isisSysMaxLSPGenInt;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysMaxLSPGenInt);
		rval = (u_char *) &StorageTmp->isisSysMaxLSPGenInt;
		break;
	case (u_char) ISISSYSPOLLESHELLORATE:	/* ReadWrite */
		*write_method = write_isisSysPollESHelloRate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysPollESHelloRate);
		rval = (u_char *) &StorageTmp->isisSysPollESHelloRate;
		break;
	case (u_char) ISISSYSWAITTIME:	/* ReadWrite */
		*write_method = write_isisSysWaitTime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysWaitTime);
		rval = (u_char *) &StorageTmp->isisSysWaitTime;
		break;
	case (u_char) ISISSYSADMINSTATE:	/* ReadWrite */
		*write_method = write_isisSysAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysAdminState);
		rval = (u_char *) &StorageTmp->isisSysAdminState;
		break;
	case (u_char) ISISSYSL2TOL1LEAKING:	/* ReadWrite */
		*write_method = write_isisSysL2toL1Leaking;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysL2toL1Leaking);
		rval = (u_char *) &StorageTmp->isisSysL2toL1Leaking;
		break;
	case (u_char) ISISSYSMAXAGE:	/* ReadWrite */
		*write_method = write_isisSysMaxAge;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysMaxAge);
		rval = (u_char *) &StorageTmp->isisSysMaxAge;
		break;
	case (u_char) ISISSYSRECEIVELSPBUFFERSIZE:	/* ReadWrite */
		*write_method = write_isisSysReceiveLSPBufferSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysReceiveLSPBufferSize);
		rval = (u_char *) &StorageTmp->isisSysReceiveLSPBufferSize;
		break;
	case (u_char) ISISSYSPROTSUPPORTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisSysProtSupportedLen;
		rval = (u_char *) StorageTmp->isisSysProtSupported;
		break;
	case (u_char) ISISSYSNOTIFICATIONENABLE:	/* ReadWrite */
		*write_method = write_isisSysNotificationEnable;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysNotificationEnable);
		rval = (u_char *) &StorageTmp->isisSysNotificationEnable;
		break;
	case (u_char) ISISNEXTCIRCINDEX:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisNextCircIndex);
		rval = (u_char *) &StorageTmp->isisNextCircIndex;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("isisMIB", "found.\n"));
	else
		DEBUGMSGTL(("isisMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct isisManAreaAddrTable_data *isisManAreaAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisManAreaAddrTable table.
 *
 * Creates a new isisManAreaAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisManAreaAddrTable_data *
isisManAreaAddrTable_create(void)
{
	struct isisManAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisManAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisManAreaAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisManAreaAddrExistState = 0;
		StorageNew->isisManAreaAddrExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisManAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisManAreaAddrTable_data *isisManAreaAddrTable_duplicate(struct isisManAreaAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisManAreaAddrTable_data *
isisManAreaAddrTable_duplicate(struct isisManAreaAddrTable_data *thedata)
{
	struct isisManAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisManAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisManAreaAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisManAreaAddrTable_id = thedata->isisManAreaAddrTable_id;
		if (!(StorageNew->isisManAreaAddr = malloc(thedata->isisManAreaAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisManAreaAddr, thedata->isisManAreaAddr, thedata->isisManAreaAddrLen);
		StorageNew->isisManAreaAddrLen = thedata->isisManAreaAddrLen;
		StorageNew->isisManAreaAddr[StorageNew->isisManAreaAddrLen] = 0;
		StorageNew->isisManAreaAddrExistState = thedata->isisManAreaAddrExistState;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisManAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisManAreaAddrTable_destroy(struct isisManAreaAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisManAreaAddrTable_destroy(struct isisManAreaAddrTable_data **thedata)
{
	struct isisManAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisManAreaAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisManAreaAddr);
		StorageDel->isisManAreaAddrLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisManAreaAddrTable_add(struct isisManAreaAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisManAreaAddrTable table data set.
 *
 * Adds a table row structure to the isisManAreaAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisManAreaAddrTable_add(struct isisManAreaAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisManAreaAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisManAreaAddr */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisManAreaAddr, thedata->isisManAreaAddrLen);
		header_complex_add_data(&isisManAreaAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisManAreaAddrTable_del(struct isisManAreaAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisManAreaAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisManAreaAddrTable_del(struct isisManAreaAddrTable_data *thedata)
{
	struct isisManAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisManAreaAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisManAreaAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisManAreaAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisManAreaAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisManAreaAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisManAreaAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisManAreaAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisManAreaAddrTable_data *StorageTmp = isisManAreaAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisManAreaAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->isisManAreaAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisManAreaAddr, &StorageTmp->isisManAreaAddrLen);
	if (StorageTmp->isisManAreaAddr == NULL) {
		config_perror("invalid specification for isisManAreaAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisManAreaAddrExistState, &tmpsize);
	isisManAreaAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisManAreaAddrTable(): store configuraiton file for isisManAreaAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisManAreaAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisManAreaAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisManAreaAddrTable: storing data...  "));
	refresh_isisManAreaAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisManAreaAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisManAreaAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisManAreaAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisManAreaAddr, &StorageTmp->isisManAreaAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisManAreaAddrExistState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisAreaAddrTable_data *isisAreaAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisAreaAddrTable table.
 *
 * Creates a new isisAreaAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisAreaAddrTable_data *
isisAreaAddrTable_create(void)
{
	struct isisAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisAreaAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisAreaAddrTable_data *isisAreaAddrTable_duplicate(struct isisAreaAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisAreaAddrTable_data *
isisAreaAddrTable_duplicate(struct isisAreaAddrTable_data *thedata)
{
	struct isisAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisAreaAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisAreaAddrTable_id = thedata->isisAreaAddrTable_id;
		if (!(StorageNew->isisAreaAddr = malloc(thedata->isisAreaAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisAreaAddr, thedata->isisAreaAddr, thedata->isisAreaAddrLen);
		StorageNew->isisAreaAddrLen = thedata->isisAreaAddrLen;
		StorageNew->isisAreaAddr[StorageNew->isisAreaAddrLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisAreaAddrTable_destroy(struct isisAreaAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisAreaAddrTable_destroy(struct isisAreaAddrTable_data **thedata)
{
	struct isisAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisAreaAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisAreaAddr);
		StorageDel->isisAreaAddrLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisAreaAddrTable_add(struct isisAreaAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisAreaAddrTable table data set.
 *
 * Adds a table row structure to the isisAreaAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisAreaAddrTable_add(struct isisAreaAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisAreaAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisAreaAddr */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisAreaAddr, thedata->isisAreaAddrLen);
		header_complex_add_data(&isisAreaAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisAreaAddrTable_del(struct isisAreaAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisAreaAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisAreaAddrTable_del(struct isisAreaAddrTable_data *thedata)
{
	struct isisAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisAreaAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisAreaAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisAreaAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisAreaAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisAreaAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisAreaAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisAreaAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisAreaAddrTable_data *StorageTmp = isisAreaAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisAreaAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->isisAreaAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisAreaAddr, &StorageTmp->isisAreaAddrLen);
	if (StorageTmp->isisAreaAddr == NULL) {
		config_perror("invalid specification for isisAreaAddr");
		return;
	}
	isisAreaAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisAreaAddrTable(): store configuraiton file for isisAreaAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisAreaAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisAreaAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisAreaAddrTable: storing data...  "));
	refresh_isisAreaAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisAreaAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisAreaAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisAreaAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisAreaAddr, &StorageTmp->isisAreaAddrLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisSummAddrTable_data *isisSummAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisSummAddrTable table.
 *
 * Creates a new isisSummAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisSummAddrTable_data *
isisSummAddrTable_create(void)
{
	struct isisSummAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSummAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisSummAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisSummAddrExistState = 0;
		StorageNew->isisSummAddrMetric = 20;
		StorageNew->isisSummAddrFullMetric = 20;
		StorageNew->isisSummAddrExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisSummAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisSummAddrTable_data *isisSummAddrTable_duplicate(struct isisSummAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisSummAddrTable_data *
isisSummAddrTable_duplicate(struct isisSummAddrTable_data *thedata)
{
	struct isisSummAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSummAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisSummAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisSummAddrTable_id = thedata->isisSummAddrTable_id;
		StorageNew->isisSummAddressType = thedata->isisSummAddressType;
		if (!(StorageNew->isisSummAddress = malloc(thedata->isisSummAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisSummAddress, thedata->isisSummAddress, thedata->isisSummAddressLen);
		StorageNew->isisSummAddressLen = thedata->isisSummAddressLen;
		StorageNew->isisSummAddress[StorageNew->isisSummAddressLen] = 0;
		StorageNew->isisSummAddrPrefixLen = thedata->isisSummAddrPrefixLen;
		StorageNew->isisSummAddrExistState = thedata->isisSummAddrExistState;
		StorageNew->isisSummAddrMetric = thedata->isisSummAddrMetric;
		StorageNew->isisSummAddrFullMetric = thedata->isisSummAddrFullMetric;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisSummAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisSummAddrTable_destroy(struct isisSummAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisSummAddrTable_destroy(struct isisSummAddrTable_data **thedata)
{
	struct isisSummAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSummAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisSummAddress);
		StorageDel->isisSummAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSummAddrTable_add(struct isisSummAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisSummAddrTable table data set.
 *
 * Adds a table row structure to the isisSummAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisSummAddrTable_add(struct isisSummAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisSummAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisSummAddressType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisSummAddressType, sizeof(thedata->isisSummAddressType));
		/* isisSummAddress */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisSummAddress, thedata->isisSummAddressLen);
		/* isisSummAddrPrefixLen */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisSummAddrPrefixLen, sizeof(thedata->isisSummAddrPrefixLen));
		header_complex_add_data(&isisSummAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSummAddrTable_del(struct isisSummAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisSummAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisSummAddrTable_del(struct isisSummAddrTable_data *thedata)
{
	struct isisSummAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSummAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisSummAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisSummAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisSummAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisSummAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisSummAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisSummAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisSummAddrTable_data *StorageTmp = isisSummAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisSummAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSummAddressType, &tmpsize);
	SNMP_FREE(StorageTmp->isisSummAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisSummAddress, &StorageTmp->isisSummAddressLen);
	if (StorageTmp->isisSummAddress == NULL) {
		config_perror("invalid specification for isisSummAddress");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSummAddrPrefixLen, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSummAddrExistState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSummAddrMetric, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSummAddrFullMetric, &tmpsize);
	isisSummAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisSummAddrTable(): store configuraiton file for isisSummAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisSummAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisSummAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisSummAddrTable: storing data...  "));
	refresh_isisSummAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisSummAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisSummAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisSummAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSummAddressType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisSummAddress, &StorageTmp->isisSummAddressLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSummAddrPrefixLen, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSummAddrExistState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSummAddrMetric, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSummAddrFullMetric, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisRedistributeAddrTable_data *isisRedistributeAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisRedistributeAddrTable table.
 *
 * Creates a new isisRedistributeAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisRedistributeAddrTable_data *
isisRedistributeAddrTable_create(void)
{
	struct isisRedistributeAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRedistributeAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisRedistributeAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisRedistributeAddrExistState = 0;
		StorageNew->isisRedistributeAddrExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisRedistributeAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisRedistributeAddrTable_data *isisRedistributeAddrTable_duplicate(struct isisRedistributeAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisRedistributeAddrTable_data *
isisRedistributeAddrTable_duplicate(struct isisRedistributeAddrTable_data *thedata)
{
	struct isisRedistributeAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRedistributeAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisRedistributeAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisRedistributeAddrTable_id = thedata->isisRedistributeAddrTable_id;
		StorageNew->isisRedistributeAddrType = thedata->isisRedistributeAddrType;
		if (!(StorageNew->isisRedistributeAddrAddress = malloc(thedata->isisRedistributeAddrAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRedistributeAddrAddress, thedata->isisRedistributeAddrAddress, thedata->isisRedistributeAddrAddressLen);
		StorageNew->isisRedistributeAddrAddressLen = thedata->isisRedistributeAddrAddressLen;
		StorageNew->isisRedistributeAddrAddress[StorageNew->isisRedistributeAddrAddressLen] = 0;
		StorageNew->isisRedistributeAddrPrefixLen = thedata->isisRedistributeAddrPrefixLen;
		StorageNew->isisRedistributeAddrExistState = thedata->isisRedistributeAddrExistState;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisRedistributeAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisRedistributeAddrTable_destroy(struct isisRedistributeAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisRedistributeAddrTable_destroy(struct isisRedistributeAddrTable_data **thedata)
{
	struct isisRedistributeAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRedistributeAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisRedistributeAddrAddress);
		StorageDel->isisRedistributeAddrAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRedistributeAddrTable_add(struct isisRedistributeAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisRedistributeAddrTable table data set.
 *
 * Adds a table row structure to the isisRedistributeAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisRedistributeAddrTable_add(struct isisRedistributeAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisRedistributeAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisRedistributeAddrType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisRedistributeAddrType, sizeof(thedata->isisRedistributeAddrType));
		/* isisRedistributeAddrAddress */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisRedistributeAddrAddress, thedata->isisRedistributeAddrAddressLen);
		/* isisRedistributeAddrPrefixLen */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisRedistributeAddrPrefixLen, sizeof(thedata->isisRedistributeAddrPrefixLen));
		header_complex_add_data(&isisRedistributeAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRedistributeAddrTable_del(struct isisRedistributeAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisRedistributeAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisRedistributeAddrTable_del(struct isisRedistributeAddrTable_data *thedata)
{
	struct isisRedistributeAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRedistributeAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisRedistributeAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisRedistributeAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisRedistributeAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisRedistributeAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisRedistributeAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisRedistributeAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisRedistributeAddrTable_data *StorageTmp = isisRedistributeAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisRedistributeAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRedistributeAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->isisRedistributeAddrAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRedistributeAddrAddress, &StorageTmp->isisRedistributeAddrAddressLen);
	if (StorageTmp->isisRedistributeAddrAddress == NULL) {
		config_perror("invalid specification for isisRedistributeAddrAddress");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisRedistributeAddrPrefixLen, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRedistributeAddrExistState, &tmpsize);
	isisRedistributeAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisRedistributeAddrTable(): store configuraiton file for isisRedistributeAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisRedistributeAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisRedistributeAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisRedistributeAddrTable: storing data...  "));
	refresh_isisRedistributeAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisRedistributeAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisRedistributeAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisRedistributeAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRedistributeAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRedistributeAddrAddress, &StorageTmp->isisRedistributeAddrAddressLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisRedistributeAddrPrefixLen, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRedistributeAddrExistState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisRouterTable_data *isisRouterTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisRouterTable table.
 *
 * Creates a new isisRouterTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisRouterTable_data *
isisRouterTable_create(void)
{
	struct isisRouterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRouterTable_data);

	DEBUGMSGTL(("isisMIB", "isisRouterTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->isisRouterHostName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisRouterHostNameLen = 0;
		StorageNew->isisRouterHostName[StorageNew->isisRouterHostNameLen] = 0;
		StorageNew->isisRouterID = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisRouterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisRouterTable_data *isisRouterTable_duplicate(struct isisRouterTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisRouterTable_data *
isisRouterTable_duplicate(struct isisRouterTable_data *thedata)
{
	struct isisRouterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRouterTable_data);

	DEBUGMSGTL(("isisMIB", "isisRouterTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisRouterTable_id = thedata->isisRouterTable_id;
		if (!(StorageNew->isisRouterSysID = malloc(thedata->isisRouterSysIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRouterSysID, thedata->isisRouterSysID, thedata->isisRouterSysIDLen);
		StorageNew->isisRouterSysIDLen = thedata->isisRouterSysIDLen;
		StorageNew->isisRouterSysID[StorageNew->isisRouterSysIDLen] = 0;
		StorageNew->isisRouterLevel = thedata->isisRouterLevel;
		if (!(StorageNew->isisRouterHostName = malloc(thedata->isisRouterHostNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRouterHostName, thedata->isisRouterHostName, thedata->isisRouterHostNameLen);
		StorageNew->isisRouterHostNameLen = thedata->isisRouterHostNameLen;
		StorageNew->isisRouterHostName[StorageNew->isisRouterHostNameLen] = 0;
		StorageNew->isisRouterID = thedata->isisRouterID;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisRouterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisRouterTable_destroy(struct isisRouterTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisRouterTable_destroy(struct isisRouterTable_data **thedata)
{
	struct isisRouterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRouterTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisRouterSysID);
		StorageDel->isisRouterSysIDLen = 0;
		SNMP_FREE(StorageDel->isisRouterHostName);
		StorageDel->isisRouterHostNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRouterTable_add(struct isisRouterTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisRouterTable table data set.
 *
 * Adds a table row structure to the isisRouterTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisRouterTable_add(struct isisRouterTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisRouterTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisRouterSysID */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisRouterSysID, thedata->isisRouterSysIDLen);
		/* isisRouterLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisRouterLevel, sizeof(thedata->isisRouterLevel));
		header_complex_add_data(&isisRouterTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRouterTable_del(struct isisRouterTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisRouterTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisRouterTable_del(struct isisRouterTable_data *thedata)
{
	struct isisRouterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRouterTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisRouterTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisRouterTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisRouterTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisRouterTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisRouterTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisRouterTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisRouterTable_data *StorageTmp = isisRouterTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisRouterTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->isisRouterSysID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRouterSysID, &StorageTmp->isisRouterSysIDLen);
	if (StorageTmp->isisRouterSysID == NULL) {
		config_perror("invalid specification for isisRouterSysID");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRouterLevel, &tmpsize);
	SNMP_FREE(StorageTmp->isisRouterHostName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRouterHostName, &StorageTmp->isisRouterHostNameLen);
	if (StorageTmp->isisRouterHostName == NULL) {
		config_perror("invalid specification for isisRouterHostName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisRouterID, &tmpsize);
	isisRouterTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisRouterTable(): store configuraiton file for isisRouterTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisRouterTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisRouterTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisRouterTable: storing data...  "));
	refresh_isisRouterTable(1);
	(void) tmpsize;
	for (hcindex = isisRouterTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisRouterTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisRouterTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRouterSysID, &StorageTmp->isisRouterSysIDLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRouterLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRouterHostName, &StorageTmp->isisRouterHostNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisRouterID, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisSysLevelTable_data *isisSysLevelTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisSysLevelTable table.
 *
 * Creates a new isisSysLevelTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisSysLevelTable_data *
isisSysLevelTable_create(void)
{
	struct isisSysLevelTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSysLevelTable_data);

	DEBUGMSGTL(("isisMIB", "isisSysLevelTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisSysLevelOrigLSPBuffSize = 1492;
		StorageNew->isisSysLevelMinLSPGenInt = 30;
		StorageNew->isisSysLevelState = 0;
		StorageNew->isisSysLevelSetOverload = TV_FALSE;
		StorageNew->isisSysLevelSetOverloadUntil = 0;
		StorageNew->isisSysLevelMetricStyle = ISISSYSLEVELMETRICSTYLE_NARROW;
		StorageNew->isisSysLevelSPFConsiders = ISISSYSLEVELSPFCONSIDERS_NARROW;
		StorageNew->isisSysLevelTEEnabled = TV_FALSE;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisSysLevelTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisSysLevelTable_data *isisSysLevelTable_duplicate(struct isisSysLevelTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisSysLevelTable_data *
isisSysLevelTable_duplicate(struct isisSysLevelTable_data *thedata)
{
	struct isisSysLevelTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSysLevelTable_data);

	DEBUGMSGTL(("isisMIB", "isisSysLevelTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisSysLevelTable_id = thedata->isisSysLevelTable_id;
		StorageNew->isisSysLevelIndex = thedata->isisSysLevelIndex;
		StorageNew->isisSysLevelOrigLSPBuffSize = thedata->isisSysLevelOrigLSPBuffSize;
		StorageNew->isisSysLevelMinLSPGenInt = thedata->isisSysLevelMinLSPGenInt;
		StorageNew->isisSysLevelState = thedata->isisSysLevelState;
		StorageNew->isisSysLevelSetOverload = thedata->isisSysLevelSetOverload;
		StorageNew->isisSysLevelSetOverloadUntil = thedata->isisSysLevelSetOverloadUntil;
		StorageNew->isisSysLevelMetricStyle = thedata->isisSysLevelMetricStyle;
		StorageNew->isisSysLevelSPFConsiders = thedata->isisSysLevelSPFConsiders;
		StorageNew->isisSysLevelTEEnabled = thedata->isisSysLevelTEEnabled;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisSysLevelTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisSysLevelTable_destroy(struct isisSysLevelTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisSysLevelTable_destroy(struct isisSysLevelTable_data **thedata)
{
	struct isisSysLevelTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSysLevelTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSysLevelTable_add(struct isisSysLevelTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisSysLevelTable table data set.
 *
 * Adds a table row structure to the isisSysLevelTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisSysLevelTable_add(struct isisSysLevelTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisSysLevelTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisSysLevelIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisSysLevelIndex, sizeof(thedata->isisSysLevelIndex));
		header_complex_add_data(&isisSysLevelTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSysLevelTable_del(struct isisSysLevelTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisSysLevelTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisSysLevelTable_del(struct isisSysLevelTable_data *thedata)
{
	struct isisSysLevelTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSysLevelTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisSysLevelTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisSysLevelTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisSysLevelTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisSysLevelTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisSysLevelTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisSysLevelTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisSysLevelTable_data *StorageTmp = isisSysLevelTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisSysLevelTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysLevelOrigLSPBuffSize, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysLevelMinLSPGenInt, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelSetOverload, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisSysLevelSetOverloadUntil, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelMetricStyle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelSPFConsiders, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelTEEnabled, &tmpsize);
	isisSysLevelTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisSysLevelTable(): store configuraiton file for isisSysLevelTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisSysLevelTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisSysLevelTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisSysLevelTable: storing data...  "));
	refresh_isisSysLevelTable(1);
	(void) tmpsize;
	for (hcindex = isisSysLevelTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisSysLevelTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisSysLevelTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysLevelOrigLSPBuffSize, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysLevelMinLSPGenInt, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelSetOverload, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisSysLevelSetOverloadUntil, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelMetricStyle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelSPFConsiders, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelTEEnabled, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisCircTable_data *isisCircTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisCircTable table.
 *
 * Creates a new isisCircTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisCircTable_data *
isisCircTable_create(void)
{
	struct isisCircTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIfIndex = 0;
		StorageNew->isisCircAdminState = ISISCIRCADMINSTATE_OFF;
		StorageNew->isisCircExistState = 0;
		StorageNew->isisCircType = 0;
		StorageNew->isisCircExtDomain = TV_FALSE;
		StorageNew->isisCircLevelType = ISISCIRCLEVELTYPE_LEVEL1AND2;
		StorageNew->isisCircPassiveCircuit = TV_FALSE;
		StorageNew->isisCircMeshGroupEnabled = ISISCIRCMESHGROUPENABLED_INACTIVE;
		StorageNew->isisCircMeshGroup = 0;
		StorageNew->isisCircSmallHellos = TV_FALSE;
		StorageNew->isisCircLastUpTime = 0;
		StorageNew->isisCirc3WayEnabled = TV_TRUE;
		StorageNew->isisCircExtendedCircID = 0;
		StorageNew->isisCircExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisCircTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisCircTable_data *isisCircTable_duplicate(struct isisCircTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisCircTable_data *
isisCircTable_duplicate(struct isisCircTable_data *thedata)
{
	struct isisCircTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisCircTable_id = thedata->isisCircTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisCircIfIndex = thedata->isisCircIfIndex;
		StorageNew->isisCircAdminState = thedata->isisCircAdminState;
		StorageNew->isisCircExistState = thedata->isisCircExistState;
		StorageNew->isisCircType = thedata->isisCircType;
		StorageNew->isisCircExtDomain = thedata->isisCircExtDomain;
		StorageNew->isisCircLevelType = thedata->isisCircLevelType;
		StorageNew->isisCircPassiveCircuit = thedata->isisCircPassiveCircuit;
		StorageNew->isisCircMeshGroupEnabled = thedata->isisCircMeshGroupEnabled;
		StorageNew->isisCircMeshGroup = thedata->isisCircMeshGroup;
		StorageNew->isisCircSmallHellos = thedata->isisCircSmallHellos;
		StorageNew->isisCircLastUpTime = thedata->isisCircLastUpTime;
		StorageNew->isisCirc3WayEnabled = thedata->isisCirc3WayEnabled;
		StorageNew->isisCircExtendedCircID = thedata->isisCircExtendedCircID;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisCircTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisCircTable_destroy(struct isisCircTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisCircTable_destroy(struct isisCircTable_data **thedata)
{
	struct isisCircTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircTable_add(struct isisCircTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisCircTable table data set.
 *
 * Adds a table row structure to the isisCircTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisCircTable_add(struct isisCircTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisCircTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		header_complex_add_data(&isisCircTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircTable_del(struct isisCircTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisCircTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisCircTable_del(struct isisCircTable_data *thedata)
{
	struct isisCircTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisCircTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisCircTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisCircTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisCircTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisCircTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisCircTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisCircTable_data *StorageTmp = isisCircTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisCircTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircIfIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircAdminState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircExistState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircExtDomain, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircLevelType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircPassiveCircuit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircMeshGroupEnabled, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircMeshGroup, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircSmallHellos, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->isisCircLastUpTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCirc3WayEnabled, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircExtendedCircID, &tmpsize);
	isisCircTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisCircTable(): store configuraiton file for isisCircTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisCircTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisCircTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisCircTable: storing data...  "));
	refresh_isisCircTable(1);
	(void) tmpsize;
	for (hcindex = isisCircTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisCircTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisCircTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircIfIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircExistState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircExtDomain, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircLevelType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircPassiveCircuit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircMeshGroupEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircMeshGroup, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircSmallHellos, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->isisCircLastUpTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCirc3WayEnabled, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircExtendedCircID, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisCircLevelTable_data *isisCircLevelTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisCircLevelTable table.
 *
 * Creates a new isisCircLevelTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisCircLevelTable_data *
isisCircLevelTable_create(void)
{
	struct isisCircLevelTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircLevelTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircLevelTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisCircLevelMetric = 10;
		StorageNew->isisCircLevelWideMetric = 10;
		StorageNew->isisCircLevelISPriority = 64;
		StorageNew->isisCircLevelIDOctet = 0;
		if ((StorageNew->isisCircLevelID = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisCircLevelIDLen = 0;
		StorageNew->isisCircLevelID[StorageNew->isisCircLevelIDLen] = 0;
		if ((StorageNew->isisCircLevelDesIS = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisCircLevelDesISLen = 0;
		StorageNew->isisCircLevelDesIS[StorageNew->isisCircLevelDesISLen] = 0;
		StorageNew->isisCircLevelHelloMultiplier = 10;
		StorageNew->isisCircLevelHelloTimer = 3000;
		StorageNew->isisCircLevelDRHelloTimer = 1000;
		StorageNew->isisCircLevelLSPThrottle = 30;
		StorageNew->isisCircLevelMinLSPRetransInt = 5;
		StorageNew->isisCircLevelCSNPInterval = 10;
		StorageNew->isisCircLevelPartSNPInterval = 2;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisCircLevelTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisCircLevelTable_data *isisCircLevelTable_duplicate(struct isisCircLevelTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisCircLevelTable_data *
isisCircLevelTable_duplicate(struct isisCircLevelTable_data *thedata)
{
	struct isisCircLevelTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircLevelTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircLevelTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisCircLevelTable_id = thedata->isisCircLevelTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisCircLevelIndex = thedata->isisCircLevelIndex;
		StorageNew->isisCircLevelMetric = thedata->isisCircLevelMetric;
		StorageNew->isisCircLevelWideMetric = thedata->isisCircLevelWideMetric;
		StorageNew->isisCircLevelISPriority = thedata->isisCircLevelISPriority;
		StorageNew->isisCircLevelIDOctet = thedata->isisCircLevelIDOctet;
		if (!(StorageNew->isisCircLevelID = malloc(thedata->isisCircLevelIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisCircLevelID, thedata->isisCircLevelID, thedata->isisCircLevelIDLen);
		StorageNew->isisCircLevelIDLen = thedata->isisCircLevelIDLen;
		StorageNew->isisCircLevelID[StorageNew->isisCircLevelIDLen] = 0;
		if (!(StorageNew->isisCircLevelDesIS = malloc(thedata->isisCircLevelDesISLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisCircLevelDesIS, thedata->isisCircLevelDesIS, thedata->isisCircLevelDesISLen);
		StorageNew->isisCircLevelDesISLen = thedata->isisCircLevelDesISLen;
		StorageNew->isisCircLevelDesIS[StorageNew->isisCircLevelDesISLen] = 0;
		StorageNew->isisCircLevelHelloMultiplier = thedata->isisCircLevelHelloMultiplier;
		StorageNew->isisCircLevelHelloTimer = thedata->isisCircLevelHelloTimer;
		StorageNew->isisCircLevelDRHelloTimer = thedata->isisCircLevelDRHelloTimer;
		StorageNew->isisCircLevelLSPThrottle = thedata->isisCircLevelLSPThrottle;
		StorageNew->isisCircLevelMinLSPRetransInt = thedata->isisCircLevelMinLSPRetransInt;
		StorageNew->isisCircLevelCSNPInterval = thedata->isisCircLevelCSNPInterval;
		StorageNew->isisCircLevelPartSNPInterval = thedata->isisCircLevelPartSNPInterval;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisCircLevelTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisCircLevelTable_destroy(struct isisCircLevelTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisCircLevelTable_destroy(struct isisCircLevelTable_data **thedata)
{
	struct isisCircLevelTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircLevelTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisCircLevelID);
		StorageDel->isisCircLevelIDLen = 0;
		SNMP_FREE(StorageDel->isisCircLevelDesIS);
		StorageDel->isisCircLevelDesISLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircLevelTable_add(struct isisCircLevelTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisCircLevelTable table data set.
 *
 * Adds a table row structure to the isisCircLevelTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisCircLevelTable_add(struct isisCircLevelTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisCircLevelTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisCircLevelIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisCircLevelIndex, sizeof(thedata->isisCircLevelIndex));
		header_complex_add_data(&isisCircLevelTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircLevelTable_del(struct isisCircLevelTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisCircLevelTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisCircLevelTable_del(struct isisCircLevelTable_data *thedata)
{
	struct isisCircLevelTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircLevelTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisCircLevelTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisCircLevelTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisCircLevelTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisCircLevelTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisCircLevelTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisCircLevelTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisCircLevelTable_data *StorageTmp = isisCircLevelTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisCircLevelTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircLevelIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelMetric, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelWideMetric, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelISPriority, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelIDOctet, &tmpsize);
	SNMP_FREE(StorageTmp->isisCircLevelID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisCircLevelID, &StorageTmp->isisCircLevelIDLen);
	if (StorageTmp->isisCircLevelID == NULL) {
		config_perror("invalid specification for isisCircLevelID");
		return;
	}
	SNMP_FREE(StorageTmp->isisCircLevelDesIS);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisCircLevelDesIS, &StorageTmp->isisCircLevelDesISLen);
	if (StorageTmp->isisCircLevelDesIS == NULL) {
		config_perror("invalid specification for isisCircLevelDesIS");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelHelloMultiplier, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelHelloTimer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelDRHelloTimer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelLSPThrottle, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelMinLSPRetransInt, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelCSNPInterval, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircLevelPartSNPInterval, &tmpsize);
	isisCircLevelTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisCircLevelTable(): store configuraiton file for isisCircLevelTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisCircLevelTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisCircLevelTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisCircLevelTable: storing data...  "));
	refresh_isisCircLevelTable(1);
	(void) tmpsize;
	for (hcindex = isisCircLevelTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisCircLevelTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisCircLevelTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircLevelIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelMetric, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelWideMetric, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelISPriority, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelIDOctet, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisCircLevelID, &StorageTmp->isisCircLevelIDLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisCircLevelDesIS, &StorageTmp->isisCircLevelDesISLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelHelloMultiplier, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelHelloTimer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelDRHelloTimer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelLSPThrottle, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelMinLSPRetransInt, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelCSNPInterval, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircLevelPartSNPInterval, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisSystemCounterTable_data *isisSystemCounterTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisSystemCounterTable table.
 *
 * Creates a new isisSystemCounterTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisSystemCounterTable_data *
isisSystemCounterTable_create(void)
{
	struct isisSystemCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSystemCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisSystemCounterTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisSysStatCorrLSPs = 0;
		StorageNew->isisSysStatAuthTypeFails = 0;
		StorageNew->isisSysStatAuthFails = 0;
		StorageNew->isisSysStatLSPDbaseOloads = 0;
		StorageNew->isisSysStatManAddrDropFromAreas = 0;
		StorageNew->isisSysStatAttmptToExMaxSeqNums = 0;
		StorageNew->isisSysStatSeqNumSkips = 0;
		StorageNew->isisSysStatOwnLSPPurges = 0;
		StorageNew->isisSysStatIDFieldLenMismatches = 0;
		StorageNew->isisSysStatPartChanges = 0;
		StorageNew->isisSysStatSPFRuns = 0;
		StorageNew->isisSysStatLSPErrors = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisSystemCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisSystemCounterTable_data *isisSystemCounterTable_duplicate(struct isisSystemCounterTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisSystemCounterTable_data *
isisSystemCounterTable_duplicate(struct isisSystemCounterTable_data *thedata)
{
	struct isisSystemCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisSystemCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisSystemCounterTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisSystemCounterTable_id = thedata->isisSystemCounterTable_id;
		StorageNew->isisSysStatLevel = thedata->isisSysStatLevel;
		StorageNew->isisSysStatCorrLSPs = thedata->isisSysStatCorrLSPs;
		StorageNew->isisSysStatAuthTypeFails = thedata->isisSysStatAuthTypeFails;
		StorageNew->isisSysStatAuthFails = thedata->isisSysStatAuthFails;
		StorageNew->isisSysStatLSPDbaseOloads = thedata->isisSysStatLSPDbaseOloads;
		StorageNew->isisSysStatManAddrDropFromAreas = thedata->isisSysStatManAddrDropFromAreas;
		StorageNew->isisSysStatAttmptToExMaxSeqNums = thedata->isisSysStatAttmptToExMaxSeqNums;
		StorageNew->isisSysStatSeqNumSkips = thedata->isisSysStatSeqNumSkips;
		StorageNew->isisSysStatOwnLSPPurges = thedata->isisSysStatOwnLSPPurges;
		StorageNew->isisSysStatIDFieldLenMismatches = thedata->isisSysStatIDFieldLenMismatches;
		StorageNew->isisSysStatPartChanges = thedata->isisSysStatPartChanges;
		StorageNew->isisSysStatSPFRuns = thedata->isisSysStatSPFRuns;
		StorageNew->isisSysStatLSPErrors = thedata->isisSysStatLSPErrors;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisSystemCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisSystemCounterTable_destroy(struct isisSystemCounterTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisSystemCounterTable_destroy(struct isisSystemCounterTable_data **thedata)
{
	struct isisSystemCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSystemCounterTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSystemCounterTable_add(struct isisSystemCounterTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisSystemCounterTable table data set.
 *
 * Adds a table row structure to the isisSystemCounterTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisSystemCounterTable_add(struct isisSystemCounterTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisSystemCounterTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisSysStatLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisSysStatLevel, sizeof(thedata->isisSysStatLevel));
		header_complex_add_data(&isisSystemCounterTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisSystemCounterTable_del(struct isisSystemCounterTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisSystemCounterTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisSystemCounterTable_del(struct isisSystemCounterTable_data *thedata)
{
	struct isisSystemCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisSystemCounterTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisSystemCounterTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisSystemCounterTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisSystemCounterTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisSystemCounterTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisSystemCounterTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisSystemCounterTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisSystemCounterTable_data *StorageTmp = isisSystemCounterTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisSystemCounterTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysStatLevel, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatCorrLSPs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatAuthTypeFails, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatAuthFails, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatLSPDbaseOloads, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatManAddrDropFromAreas, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatAttmptToExMaxSeqNums, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatSeqNumSkips, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatOwnLSPPurges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatIDFieldLenMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatPartChanges, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatSPFRuns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisSysStatLSPErrors, &tmpsize);
	isisSystemCounterTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisSystemCounterTable(): store configuraiton file for isisSystemCounterTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisSystemCounterTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisSystemCounterTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisSystemCounterTable: storing data...  "));
	refresh_isisSystemCounterTable(1);
	(void) tmpsize;
	for (hcindex = isisSystemCounterTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisSystemCounterTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisSystemCounterTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysStatLevel, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatCorrLSPs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatAuthTypeFails, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatAuthFails, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatLSPDbaseOloads, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatManAddrDropFromAreas, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatAttmptToExMaxSeqNums, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatSeqNumSkips, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatOwnLSPPurges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatIDFieldLenMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatPartChanges, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatSPFRuns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisSysStatLSPErrors, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisCircuitCounterTable_data *isisCircuitCounterTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisCircuitCounterTable table.
 *
 * Creates a new isisCircuitCounterTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisCircuitCounterTable_data *
isisCircuitCounterTable_create(void)
{
	struct isisCircuitCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircuitCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircuitCounterTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisCircAdjChanges = 0;
		StorageNew->isisCircNumAdj = 0;
		StorageNew->isisCircInitFails = 0;
		StorageNew->isisCircRejAdjs = 0;
		StorageNew->isisCircIDFieldLenMismatches = 0;
		StorageNew->isisCircMaxAreaAddrMismatches = 0;
		StorageNew->isisCircAuthTypeFails = 0;
		StorageNew->isisCircAuthFails = 0;
		StorageNew->isisCircLANDesISChanges = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisCircuitCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisCircuitCounterTable_data *isisCircuitCounterTable_duplicate(struct isisCircuitCounterTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisCircuitCounterTable_data *
isisCircuitCounterTable_duplicate(struct isisCircuitCounterTable_data *thedata)
{
	struct isisCircuitCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisCircuitCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisCircuitCounterTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisCircuitCounterTable_id = thedata->isisCircuitCounterTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisCircuitType = thedata->isisCircuitType;
		StorageNew->isisCircAdjChanges = thedata->isisCircAdjChanges;
		StorageNew->isisCircNumAdj = thedata->isisCircNumAdj;
		StorageNew->isisCircInitFails = thedata->isisCircInitFails;
		StorageNew->isisCircRejAdjs = thedata->isisCircRejAdjs;
		StorageNew->isisCircIDFieldLenMismatches = thedata->isisCircIDFieldLenMismatches;
		StorageNew->isisCircMaxAreaAddrMismatches = thedata->isisCircMaxAreaAddrMismatches;
		StorageNew->isisCircAuthTypeFails = thedata->isisCircAuthTypeFails;
		StorageNew->isisCircAuthFails = thedata->isisCircAuthFails;
		StorageNew->isisCircLANDesISChanges = thedata->isisCircLANDesISChanges;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisCircuitCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisCircuitCounterTable_destroy(struct isisCircuitCounterTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisCircuitCounterTable_destroy(struct isisCircuitCounterTable_data **thedata)
{
	struct isisCircuitCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircuitCounterTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircuitCounterTable_add(struct isisCircuitCounterTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisCircuitCounterTable table data set.
 *
 * Adds a table row structure to the isisCircuitCounterTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisCircuitCounterTable_add(struct isisCircuitCounterTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisCircuitCounterTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisCircuitType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisCircuitType, sizeof(thedata->isisCircuitType));
		header_complex_add_data(&isisCircuitCounterTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisCircuitCounterTable_del(struct isisCircuitCounterTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisCircuitCounterTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisCircuitCounterTable_del(struct isisCircuitCounterTable_data *thedata)
{
	struct isisCircuitCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisCircuitCounterTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisCircuitCounterTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisCircuitCounterTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisCircuitCounterTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisCircuitCounterTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisCircuitCounterTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisCircuitCounterTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisCircuitCounterTable_data *StorageTmp = isisCircuitCounterTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisCircuitCounterTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisCircuitType, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircAdjChanges, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircNumAdj, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircInitFails, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircRejAdjs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircIDFieldLenMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircMaxAreaAddrMismatches, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircAuthTypeFails, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircAuthFails, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisCircLANDesISChanges, &tmpsize);
	isisCircuitCounterTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisCircuitCounterTable(): store configuraiton file for isisCircuitCounterTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisCircuitCounterTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisCircuitCounterTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisCircuitCounterTable: storing data...  "));
	refresh_isisCircuitCounterTable(1);
	(void) tmpsize;
	for (hcindex = isisCircuitCounterTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisCircuitCounterTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisCircuitCounterTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisCircuitType, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircAdjChanges, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircNumAdj, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircInitFails, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircRejAdjs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircIDFieldLenMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircMaxAreaAddrMismatches, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircAuthTypeFails, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircAuthFails, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisCircLANDesISChanges, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisPacketCounterTable_data *isisPacketCounterTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisPacketCounterTable table.
 *
 * Creates a new isisPacketCounterTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisPacketCounterTable_data *
isisPacketCounterTable_create(void)
{
	struct isisPacketCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisPacketCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisPacketCounterTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisPacketCountIIHello = 0;
		StorageNew->isisPacketCountISHello = 0;
		StorageNew->isisPacketCountESHello = 0;
		StorageNew->isisPacketCountLSP = 0;
		StorageNew->isisPacketCountCSNP = 0;
		StorageNew->isisPacketCountPSNP = 0;
		StorageNew->isisPacketCountUnknown = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisPacketCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisPacketCounterTable_data *isisPacketCounterTable_duplicate(struct isisPacketCounterTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisPacketCounterTable_data *
isisPacketCounterTable_duplicate(struct isisPacketCounterTable_data *thedata)
{
	struct isisPacketCounterTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisPacketCounterTable_data);

	DEBUGMSGTL(("isisMIB", "isisPacketCounterTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisPacketCounterTable_id = thedata->isisPacketCounterTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisPacketCountLevel = thedata->isisPacketCountLevel;
		StorageNew->isisPacketCountDirection = thedata->isisPacketCountDirection;
		StorageNew->isisPacketCountIIHello = thedata->isisPacketCountIIHello;
		StorageNew->isisPacketCountISHello = thedata->isisPacketCountISHello;
		StorageNew->isisPacketCountESHello = thedata->isisPacketCountESHello;
		StorageNew->isisPacketCountLSP = thedata->isisPacketCountLSP;
		StorageNew->isisPacketCountCSNP = thedata->isisPacketCountCSNP;
		StorageNew->isisPacketCountPSNP = thedata->isisPacketCountPSNP;
		StorageNew->isisPacketCountUnknown = thedata->isisPacketCountUnknown;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisPacketCounterTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisPacketCounterTable_destroy(struct isisPacketCounterTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisPacketCounterTable_destroy(struct isisPacketCounterTable_data **thedata)
{
	struct isisPacketCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisPacketCounterTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisPacketCounterTable_add(struct isisPacketCounterTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisPacketCounterTable table data set.
 *
 * Adds a table row structure to the isisPacketCounterTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisPacketCounterTable_add(struct isisPacketCounterTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisPacketCounterTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisPacketCountLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisPacketCountLevel, sizeof(thedata->isisPacketCountLevel));
		/* isisPacketCountDirection */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisPacketCountDirection, sizeof(thedata->isisPacketCountDirection));
		header_complex_add_data(&isisPacketCounterTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisPacketCounterTable_del(struct isisPacketCounterTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisPacketCounterTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisPacketCounterTable_del(struct isisPacketCounterTable_data *thedata)
{
	struct isisPacketCounterTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisPacketCounterTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisPacketCounterTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisPacketCounterTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisPacketCounterTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisPacketCounterTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisPacketCounterTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisPacketCounterTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisPacketCounterTable_data *StorageTmp = isisPacketCounterTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisPacketCounterTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisPacketCountLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisPacketCountDirection, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountIIHello, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountISHello, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountESHello, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountLSP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountCSNP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountPSNP, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->isisPacketCountUnknown, &tmpsize);
	isisPacketCounterTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisPacketCounterTable(): store configuraiton file for isisPacketCounterTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisPacketCounterTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisPacketCounterTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisPacketCounterTable: storing data...  "));
	refresh_isisPacketCounterTable(1);
	(void) tmpsize;
	for (hcindex = isisPacketCounterTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisPacketCounterTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisPacketCounterTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisPacketCountLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisPacketCountDirection, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountIIHello, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountISHello, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountESHello, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountLSP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountCSNP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountPSNP, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->isisPacketCountUnknown, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisISAdjTable_data *isisISAdjTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisISAdjTable table.
 *
 * Creates a new isisISAdjTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisISAdjTable_data *
isisISAdjTable_create(void)
{
	struct isisISAdjTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisISAdjState = 0;
		StorageNew->isisISAdj3WayState = 0;
		if ((StorageNew->isisISAdjNeighSNPAAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisISAdjNeighSNPAAddressLen = 0;
		StorageNew->isisISAdjNeighSNPAAddress[StorageNew->isisISAdjNeighSNPAAddressLen] = 0;
		StorageNew->isisISAdjNeighSysType = 0;
		if ((StorageNew->isisISAdjNeighSysID = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisISAdjNeighSysIDLen = 0;
		StorageNew->isisISAdjNeighSysID[StorageNew->isisISAdjNeighSysIDLen] = 0;
		StorageNew->isisISAdjNbrExtendedCircID = 0;
		StorageNew->isisISAdjUsage = 0;
		StorageNew->isisISAdjHoldTimer = 0;
		StorageNew->isisISAdjNeighPriority = 0;
		StorageNew->isisISAdjLastUpTime = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisISAdjTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisISAdjTable_data *isisISAdjTable_duplicate(struct isisISAdjTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisISAdjTable_data *
isisISAdjTable_duplicate(struct isisISAdjTable_data *thedata)
{
	struct isisISAdjTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisISAdjTable_id = thedata->isisISAdjTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisISAdjIndex = thedata->isisISAdjIndex;
		StorageNew->isisISAdjState = thedata->isisISAdjState;
		StorageNew->isisISAdj3WayState = thedata->isisISAdj3WayState;
		if (!(StorageNew->isisISAdjNeighSNPAAddress = malloc(thedata->isisISAdjNeighSNPAAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisISAdjNeighSNPAAddress, thedata->isisISAdjNeighSNPAAddress, thedata->isisISAdjNeighSNPAAddressLen);
		StorageNew->isisISAdjNeighSNPAAddressLen = thedata->isisISAdjNeighSNPAAddressLen;
		StorageNew->isisISAdjNeighSNPAAddress[StorageNew->isisISAdjNeighSNPAAddressLen] = 0;
		StorageNew->isisISAdjNeighSysType = thedata->isisISAdjNeighSysType;
		if (!(StorageNew->isisISAdjNeighSysID = malloc(thedata->isisISAdjNeighSysIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisISAdjNeighSysID, thedata->isisISAdjNeighSysID, thedata->isisISAdjNeighSysIDLen);
		StorageNew->isisISAdjNeighSysIDLen = thedata->isisISAdjNeighSysIDLen;
		StorageNew->isisISAdjNeighSysID[StorageNew->isisISAdjNeighSysIDLen] = 0;
		StorageNew->isisISAdjNbrExtendedCircID = thedata->isisISAdjNbrExtendedCircID;
		StorageNew->isisISAdjUsage = thedata->isisISAdjUsage;
		StorageNew->isisISAdjHoldTimer = thedata->isisISAdjHoldTimer;
		StorageNew->isisISAdjNeighPriority = thedata->isisISAdjNeighPriority;
		StorageNew->isisISAdjLastUpTime = thedata->isisISAdjLastUpTime;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisISAdjTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisISAdjTable_destroy(struct isisISAdjTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisISAdjTable_destroy(struct isisISAdjTable_data **thedata)
{
	struct isisISAdjTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisISAdjNeighSNPAAddress);
		StorageDel->isisISAdjNeighSNPAAddressLen = 0;
		SNMP_FREE(StorageDel->isisISAdjNeighSysID);
		StorageDel->isisISAdjNeighSysIDLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjTable_add(struct isisISAdjTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisISAdjTable table data set.
 *
 * Adds a table row structure to the isisISAdjTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisISAdjTable_add(struct isisISAdjTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisISAdjTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisISAdjIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjIndex, sizeof(thedata->isisISAdjIndex));
		header_complex_add_data(&isisISAdjTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjTable_del(struct isisISAdjTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisISAdjTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisISAdjTable_del(struct isisISAdjTable_data *thedata)
{
	struct isisISAdjTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisISAdjTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisISAdjTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisISAdjTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisISAdjTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisISAdjTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisISAdjTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisISAdjTable_data *StorageTmp = isisISAdjTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisISAdjTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdjState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdj3WayState, &tmpsize);
	SNMP_FREE(StorageTmp->isisISAdjNeighSNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisISAdjNeighSNPAAddress, &StorageTmp->isisISAdjNeighSNPAAddressLen);
	if (StorageTmp->isisISAdjNeighSNPAAddress == NULL) {
		config_perror("invalid specification for isisISAdjNeighSNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdjNeighSysType, &tmpsize);
	SNMP_FREE(StorageTmp->isisISAdjNeighSysID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisISAdjNeighSysID, &StorageTmp->isisISAdjNeighSysIDLen);
	if (StorageTmp->isisISAdjNeighSysID == NULL) {
		config_perror("invalid specification for isisISAdjNeighSysID");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjNbrExtendedCircID, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdjUsage, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjHoldTimer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjNeighPriority, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->isisISAdjLastUpTime, &tmpsize);
	isisISAdjTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisISAdjTable(): store configuraiton file for isisISAdjTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisISAdjTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisISAdjTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisISAdjTable: storing data...  "));
	refresh_isisISAdjTable(1);
	(void) tmpsize;
	for (hcindex = isisISAdjTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisISAdjTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisISAdjTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdjState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdj3WayState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisISAdjNeighSNPAAddress, &StorageTmp->isisISAdjNeighSNPAAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdjNeighSysType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisISAdjNeighSysID, &StorageTmp->isisISAdjNeighSysIDLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjNbrExtendedCircID, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdjUsage, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjHoldTimer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjNeighPriority, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->isisISAdjLastUpTime, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisISAdjAreaAddrTable_data *isisISAdjAreaAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisISAdjAreaAddrTable table.
 *
 * Creates a new isisISAdjAreaAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisISAdjAreaAddrTable_data *
isisISAdjAreaAddrTable_create(void)
{
	struct isisISAdjAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjAreaAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisISAdjIndex = 0;
		if ((StorageNew->isisISAdjAreaAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisISAdjAreaAddressLen = 0;
		StorageNew->isisISAdjAreaAddress[StorageNew->isisISAdjAreaAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisISAdjAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisISAdjAreaAddrTable_data *isisISAdjAreaAddrTable_duplicate(struct isisISAdjAreaAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisISAdjAreaAddrTable_data *
isisISAdjAreaAddrTable_duplicate(struct isisISAdjAreaAddrTable_data *thedata)
{
	struct isisISAdjAreaAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjAreaAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjAreaAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisISAdjAreaAddrTable_id = thedata->isisISAdjAreaAddrTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisISAdjIndex = thedata->isisISAdjIndex;
		StorageNew->isisISAdjAreaAddrIndex = thedata->isisISAdjAreaAddrIndex;
		if (!(StorageNew->isisISAdjAreaAddress = malloc(thedata->isisISAdjAreaAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisISAdjAreaAddress, thedata->isisISAdjAreaAddress, thedata->isisISAdjAreaAddressLen);
		StorageNew->isisISAdjAreaAddressLen = thedata->isisISAdjAreaAddressLen;
		StorageNew->isisISAdjAreaAddress[StorageNew->isisISAdjAreaAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisISAdjAreaAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisISAdjAreaAddrTable_destroy(struct isisISAdjAreaAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisISAdjAreaAddrTable_destroy(struct isisISAdjAreaAddrTable_data **thedata)
{
	struct isisISAdjAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjAreaAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisISAdjAreaAddress);
		StorageDel->isisISAdjAreaAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjAreaAddrTable_add(struct isisISAdjAreaAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisISAdjAreaAddrTable table data set.
 *
 * Adds a table row structure to the isisISAdjAreaAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisISAdjAreaAddrTable_add(struct isisISAdjAreaAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisISAdjAreaAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisISAdjIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjIndex, sizeof(thedata->isisISAdjIndex));
		/* isisISAdjAreaAddrIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjAreaAddrIndex, sizeof(thedata->isisISAdjAreaAddrIndex));
		header_complex_add_data(&isisISAdjAreaAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjAreaAddrTable_del(struct isisISAdjAreaAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisISAdjAreaAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisISAdjAreaAddrTable_del(struct isisISAdjAreaAddrTable_data *thedata)
{
	struct isisISAdjAreaAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjAreaAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisISAdjAreaAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisISAdjAreaAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisISAdjAreaAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisISAdjAreaAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisISAdjAreaAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisISAdjAreaAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisISAdjAreaAddrTable_data *StorageTmp = isisISAdjAreaAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisISAdjAreaAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjAreaAddrIndex, &tmpsize);
	SNMP_FREE(StorageTmp->isisISAdjAreaAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisISAdjAreaAddress, &StorageTmp->isisISAdjAreaAddressLen);
	if (StorageTmp->isisISAdjAreaAddress == NULL) {
		config_perror("invalid specification for isisISAdjAreaAddress");
		return;
	}
	isisISAdjAreaAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisISAdjAreaAddrTable(): store configuraiton file for isisISAdjAreaAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisISAdjAreaAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisISAdjAreaAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisISAdjAreaAddrTable: storing data...  "));
	refresh_isisISAdjAreaAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisISAdjAreaAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisISAdjAreaAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisISAdjAreaAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjAreaAddrIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisISAdjAreaAddress, &StorageTmp->isisISAdjAreaAddressLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisISAdjIPAddrTable_data *isisISAdjIPAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisISAdjIPAddrTable table.
 *
 * Creates a new isisISAdjIPAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisISAdjIPAddrTable_data *
isisISAdjIPAddrTable_create(void)
{
	struct isisISAdjIPAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjIPAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjIPAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisISAdjIndex = 0;
		StorageNew->isisISAdjIPAddrType = 0;
		if ((StorageNew->isisISAdjIPAddrAddress = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisISAdjIPAddrAddressLen = 0;
		StorageNew->isisISAdjIPAddrAddress[StorageNew->isisISAdjIPAddrAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisISAdjIPAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisISAdjIPAddrTable_data *isisISAdjIPAddrTable_duplicate(struct isisISAdjIPAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisISAdjIPAddrTable_data *
isisISAdjIPAddrTable_duplicate(struct isisISAdjIPAddrTable_data *thedata)
{
	struct isisISAdjIPAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjIPAddrTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjIPAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisISAdjIPAddrTable_id = thedata->isisISAdjIPAddrTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisISAdjIndex = thedata->isisISAdjIndex;
		StorageNew->isisISAdjIPAddrIndex = thedata->isisISAdjIPAddrIndex;
		StorageNew->isisISAdjIPAddrType = thedata->isisISAdjIPAddrType;
		if (!(StorageNew->isisISAdjIPAddrAddress = malloc(thedata->isisISAdjIPAddrAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisISAdjIPAddrAddress, thedata->isisISAdjIPAddrAddress, thedata->isisISAdjIPAddrAddressLen);
		StorageNew->isisISAdjIPAddrAddressLen = thedata->isisISAdjIPAddrAddressLen;
		StorageNew->isisISAdjIPAddrAddress[StorageNew->isisISAdjIPAddrAddressLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisISAdjIPAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisISAdjIPAddrTable_destroy(struct isisISAdjIPAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisISAdjIPAddrTable_destroy(struct isisISAdjIPAddrTable_data **thedata)
{
	struct isisISAdjIPAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjIPAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisISAdjIPAddrAddress);
		StorageDel->isisISAdjIPAddrAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjIPAddrTable_add(struct isisISAdjIPAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisISAdjIPAddrTable table data set.
 *
 * Adds a table row structure to the isisISAdjIPAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisISAdjIPAddrTable_add(struct isisISAdjIPAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisISAdjIPAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisISAdjIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjIndex, sizeof(thedata->isisISAdjIndex));
		/* isisISAdjIPAddrIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjIPAddrIndex, sizeof(thedata->isisISAdjIPAddrIndex));
		header_complex_add_data(&isisISAdjIPAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjIPAddrTable_del(struct isisISAdjIPAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisISAdjIPAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisISAdjIPAddrTable_del(struct isisISAdjIPAddrTable_data *thedata)
{
	struct isisISAdjIPAddrTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjIPAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisISAdjIPAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisISAdjIPAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisISAdjIPAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisISAdjIPAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisISAdjIPAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisISAdjIPAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisISAdjIPAddrTable_data *StorageTmp = isisISAdjIPAddrTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisISAdjIPAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjIPAddrIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdjIPAddrType, &tmpsize);
	SNMP_FREE(StorageTmp->isisISAdjIPAddrAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisISAdjIPAddrAddress, &StorageTmp->isisISAdjIPAddrAddressLen);
	if (StorageTmp->isisISAdjIPAddrAddress == NULL) {
		config_perror("invalid specification for isisISAdjIPAddrAddress");
		return;
	}
	isisISAdjIPAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisISAdjIPAddrTable(): store configuraiton file for isisISAdjIPAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisISAdjIPAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisISAdjIPAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisISAdjIPAddrTable: storing data...  "));
	refresh_isisISAdjIPAddrTable(1);
	(void) tmpsize;
	for (hcindex = isisISAdjIPAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisISAdjIPAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisISAdjIPAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjIPAddrIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdjIPAddrType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisISAdjIPAddrAddress, &StorageTmp->isisISAdjIPAddrAddressLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisISAdjProtSuppTable_data *isisISAdjProtSuppTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisISAdjProtSuppTable table.
 *
 * Creates a new isisISAdjProtSuppTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisISAdjProtSuppTable_data *
isisISAdjProtSuppTable_create(void)
{
	struct isisISAdjProtSuppTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjProtSuppTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjProtSuppTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisISAdjIndex = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisISAdjProtSuppTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisISAdjProtSuppTable_data *isisISAdjProtSuppTable_duplicate(struct isisISAdjProtSuppTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisISAdjProtSuppTable_data *
isisISAdjProtSuppTable_duplicate(struct isisISAdjProtSuppTable_data *thedata)
{
	struct isisISAdjProtSuppTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisISAdjProtSuppTable_data);

	DEBUGMSGTL(("isisMIB", "isisISAdjProtSuppTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisISAdjProtSuppTable_id = thedata->isisISAdjProtSuppTable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisISAdjIndex = thedata->isisISAdjIndex;
		StorageNew->isisISAdjProtSuppProtocol = thedata->isisISAdjProtSuppProtocol;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisISAdjProtSuppTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisISAdjProtSuppTable_destroy(struct isisISAdjProtSuppTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisISAdjProtSuppTable_destroy(struct isisISAdjProtSuppTable_data **thedata)
{
	struct isisISAdjProtSuppTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjProtSuppTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjProtSuppTable_add(struct isisISAdjProtSuppTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisISAdjProtSuppTable table data set.
 *
 * Adds a table row structure to the isisISAdjProtSuppTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisISAdjProtSuppTable_add(struct isisISAdjProtSuppTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisISAdjProtSuppTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisISAdjIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisISAdjIndex, sizeof(thedata->isisISAdjIndex));
		/* isisISAdjProtSuppProtocol */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisISAdjProtSuppProtocol, sizeof(thedata->isisISAdjProtSuppProtocol));
		header_complex_add_data(&isisISAdjProtSuppTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisISAdjProtSuppTable_del(struct isisISAdjProtSuppTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisISAdjProtSuppTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisISAdjProtSuppTable_del(struct isisISAdjProtSuppTable_data *thedata)
{
	struct isisISAdjProtSuppTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisISAdjProtSuppTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisISAdjProtSuppTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisISAdjProtSuppTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisISAdjProtSuppTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisISAdjProtSuppTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisISAdjProtSuppTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisISAdjProtSuppTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisISAdjProtSuppTable_data *StorageTmp = isisISAdjProtSuppTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisISAdjProtSuppTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisISAdjIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisISAdjProtSuppProtocol, &tmpsize);
	isisISAdjProtSuppTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisISAdjProtSuppTable(): store configuraiton file for isisISAdjProtSuppTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisISAdjProtSuppTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisISAdjProtSuppTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisISAdjProtSuppTable: storing data...  "));
	refresh_isisISAdjProtSuppTable(1);
	(void) tmpsize;
	for (hcindex = isisISAdjProtSuppTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisISAdjProtSuppTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisISAdjProtSuppTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisISAdjIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisISAdjProtSuppProtocol, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisRATable_data *isisRATable_create(void)
 * @brief create a fresh data structure representing a new row in the isisRATable table.
 *
 * Creates a new isisRATable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisRATable_data *
isisRATable_create(void)
{
	struct isisRATable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRATable_data);

	DEBUGMSGTL(("isisMIB", "isisRATable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisCircIndex = 0;
		StorageNew->isisRAExistState = 0;
		StorageNew->isisRAAdminState = ISISRAADMINSTATE_OFF;
		if ((StorageNew->isisRAAddrPrefix = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisRAAddrPrefixLen = 0;
		StorageNew->isisRAAddrPrefix[StorageNew->isisRAAddrPrefixLen] = 0;
		StorageNew->isisRAMapType = 0;
		StorageNew->isisRAMetric = 20;
		StorageNew->isisRAMetricType = ISISRAMETRICTYPE_INTERNAL;
		/* StorageNew->isisRASNPAAddress = (uint8_t *) strdup(0); *//* DEFVAL 0 */
		/* StorageNew->isisRASNPAAddressLen = strlen(0); *//* DEFVAL 0 */
		/* StorageNew->isisRASNPAMask = (uint8_t *) strdup(0); *//* DEFVAL 0 */
		/* StorageNew->isisRASNPAMaskLen = strlen(0); *//* DEFVAL 0 */
		/* StorageNew->isisRASNPAPrefix = (uint8_t *) strdup(0); *//* DEFVAL 0 */
		/* StorageNew->isisRASNPAPrefixLen = strlen(0); *//* DEFVAL 0 */
		StorageNew->isisRAType = ISISRATYPE_MANUAL;
		StorageNew->isisRAExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisRATable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisRATable_data *isisRATable_duplicate(struct isisRATable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisRATable_data *
isisRATable_duplicate(struct isisRATable_data *thedata)
{
	struct isisRATable_data *StorageNew = SNMP_MALLOC_STRUCT(isisRATable_data);

	DEBUGMSGTL(("isisMIB", "isisRATable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisRATable_id = thedata->isisRATable_id;
		StorageNew->isisCircIndex = thedata->isisCircIndex;
		StorageNew->isisRAIndex = thedata->isisRAIndex;
		StorageNew->isisRAExistState = thedata->isisRAExistState;
		StorageNew->isisRAAdminState = thedata->isisRAAdminState;
		if (!(StorageNew->isisRAAddrPrefix = malloc(thedata->isisRAAddrPrefixLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRAAddrPrefix, thedata->isisRAAddrPrefix, thedata->isisRAAddrPrefixLen);
		StorageNew->isisRAAddrPrefixLen = thedata->isisRAAddrPrefixLen;
		StorageNew->isisRAAddrPrefix[StorageNew->isisRAAddrPrefixLen] = 0;
		StorageNew->isisRAMapType = thedata->isisRAMapType;
		StorageNew->isisRAMetric = thedata->isisRAMetric;
		StorageNew->isisRAMetricType = thedata->isisRAMetricType;
		if (!(StorageNew->isisRASNPAAddress = malloc(thedata->isisRASNPAAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRASNPAAddress, thedata->isisRASNPAAddress, thedata->isisRASNPAAddressLen);
		StorageNew->isisRASNPAAddressLen = thedata->isisRASNPAAddressLen;
		StorageNew->isisRASNPAAddress[StorageNew->isisRASNPAAddressLen] = 0;
		if (!(StorageNew->isisRASNPAMask = malloc(thedata->isisRASNPAMaskLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRASNPAMask, thedata->isisRASNPAMask, thedata->isisRASNPAMaskLen);
		StorageNew->isisRASNPAMaskLen = thedata->isisRASNPAMaskLen;
		StorageNew->isisRASNPAMask[StorageNew->isisRASNPAMaskLen] = 0;
		if (!(StorageNew->isisRASNPAPrefix = malloc(thedata->isisRASNPAPrefixLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisRASNPAPrefix, thedata->isisRASNPAPrefix, thedata->isisRASNPAPrefixLen);
		StorageNew->isisRASNPAPrefixLen = thedata->isisRASNPAPrefixLen;
		StorageNew->isisRASNPAPrefix[StorageNew->isisRASNPAPrefixLen] = 0;
		StorageNew->isisRAType = thedata->isisRAType;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisRATable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisRATable_destroy(struct isisRATable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisRATable_destroy(struct isisRATable_data **thedata)
{
	struct isisRATable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRATable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisRAAddrPrefix);
		StorageDel->isisRAAddrPrefixLen = 0;
		SNMP_FREE(StorageDel->isisRASNPAAddress);
		StorageDel->isisRASNPAAddressLen = 0;
		SNMP_FREE(StorageDel->isisRASNPAMask);
		StorageDel->isisRASNPAMaskLen = 0;
		SNMP_FREE(StorageDel->isisRASNPAPrefix);
		StorageDel->isisRASNPAPrefixLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRATable_add(struct isisRATable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisRATable table data set.
 *
 * Adds a table row structure to the isisRATable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisRATable_add(struct isisRATable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisRATable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisCircIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisCircIndex, sizeof(thedata->isisCircIndex));
		/* isisRAIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisRAIndex, sizeof(thedata->isisRAIndex));
		header_complex_add_data(&isisRATableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisRATable_del(struct isisRATable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisRATable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisRATable_del(struct isisRATable_data *thedata)
{
	struct isisRATable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisRATable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisRATableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisRATableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisRATable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisRATable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisRATable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisRATable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisRATable_data *StorageTmp = isisRATable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisRATable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisCircIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisRAIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRAExistState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRAAdminState, &tmpsize);
	SNMP_FREE(StorageTmp->isisRAAddrPrefix);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRAAddrPrefix, &StorageTmp->isisRAAddrPrefixLen);
	if (StorageTmp->isisRAAddrPrefix == NULL) {
		config_perror("invalid specification for isisRAAddrPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRAMapType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisRAMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRAMetricType, &tmpsize);
	SNMP_FREE(StorageTmp->isisRASNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRASNPAAddress, &StorageTmp->isisRASNPAAddressLen);
	if (StorageTmp->isisRASNPAAddress == NULL) {
		config_perror("invalid specification for isisRASNPAAddress");
		return;
	}
	SNMP_FREE(StorageTmp->isisRASNPAMask);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRASNPAMask, &StorageTmp->isisRASNPAMaskLen);
	if (StorageTmp->isisRASNPAMask == NULL) {
		config_perror("invalid specification for isisRASNPAMask");
		return;
	}
	SNMP_FREE(StorageTmp->isisRASNPAPrefix);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisRASNPAPrefix, &StorageTmp->isisRASNPAPrefixLen);
	if (StorageTmp->isisRASNPAPrefix == NULL) {
		config_perror("invalid specification for isisRASNPAPrefix");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisRAType, &tmpsize);
	isisRATable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisRATable(): store configuraiton file for isisRATable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisRATable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisRATable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisRATable: storing data...  "));
	refresh_isisRATable(1);
	(void) tmpsize;
	for (hcindex = isisRATableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisRATable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisRATable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisCircIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisRAIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRAExistState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRAAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRAAddrPrefix, &StorageTmp->isisRAAddrPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRAMapType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisRAMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRAMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRASNPAAddress, &StorageTmp->isisRASNPAAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRASNPAMask, &StorageTmp->isisRASNPAMaskLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisRASNPAPrefix, &StorageTmp->isisRASNPAPrefixLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisRAType, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisIPRATable_data *isisIPRATable_create(void)
 * @brief create a fresh data structure representing a new row in the isisIPRATable table.
 *
 * Creates a new isisIPRATable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisIPRATable_data *
isisIPRATable_create(void)
{
	struct isisIPRATable_data *StorageNew = SNMP_MALLOC_STRUCT(isisIPRATable_data);

	DEBUGMSGTL(("isisMIB", "isisIPRATable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisSysLevelIndex = 0;
		StorageNew->isisIPRANextHopType = 0;
		if ((StorageNew->isisIPRANextHop = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisIPRANextHopLen = 0;
		StorageNew->isisIPRANextHop[StorageNew->isisIPRANextHopLen] = 0;
		StorageNew->isisIPRAType = 0;
		StorageNew->isisIPRAExistState = 0;
		StorageNew->isisIPRAAdminState = ISISIPRAADMINSTATE_OFF;
		StorageNew->isisIPRAMetric = 10;
		StorageNew->isisIPRAMetricType = ISISIPRAMETRICTYPE_INTERNAL;
		StorageNew->isisIPRAFullMetric = 10;
		/* StorageNew->isisIPRASNPAAddress = (uint8_t *) strdup(0); *//* DEFVAL 0 */
		/* StorageNew->isisIPRASNPAAddressLen = strlen(0); *//* DEFVAL 0 */
		StorageNew->isisIPRASourceType = 0;
		StorageNew->isisIPRAExistState = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisIPRATable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisIPRATable_data *isisIPRATable_duplicate(struct isisIPRATable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisIPRATable_data *
isisIPRATable_duplicate(struct isisIPRATable_data *thedata)
{
	struct isisIPRATable_data *StorageNew = SNMP_MALLOC_STRUCT(isisIPRATable_data);

	DEBUGMSGTL(("isisMIB", "isisIPRATable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisIPRATable_id = thedata->isisIPRATable_id;
		StorageNew->isisSysLevelIndex = thedata->isisSysLevelIndex;
		StorageNew->isisIPRADestType = thedata->isisIPRADestType;
		if (!(StorageNew->isisIPRADest = malloc(thedata->isisIPRADestLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisIPRADest, thedata->isisIPRADest, thedata->isisIPRADestLen);
		StorageNew->isisIPRADestLen = thedata->isisIPRADestLen;
		StorageNew->isisIPRADest[StorageNew->isisIPRADestLen] = 0;
		StorageNew->isisIPRADestPrefixLen = thedata->isisIPRADestPrefixLen;
		StorageNew->isisIPRANextHopIndex = thedata->isisIPRANextHopIndex;
		StorageNew->isisIPRANextHopType = thedata->isisIPRANextHopType;
		if (!(StorageNew->isisIPRANextHop = malloc(thedata->isisIPRANextHopLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisIPRANextHop, thedata->isisIPRANextHop, thedata->isisIPRANextHopLen);
		StorageNew->isisIPRANextHopLen = thedata->isisIPRANextHopLen;
		StorageNew->isisIPRANextHop[StorageNew->isisIPRANextHopLen] = 0;
		StorageNew->isisIPRAType = thedata->isisIPRAType;
		StorageNew->isisIPRAExistState = thedata->isisIPRAExistState;
		StorageNew->isisIPRAAdminState = thedata->isisIPRAAdminState;
		StorageNew->isisIPRAMetric = thedata->isisIPRAMetric;
		StorageNew->isisIPRAMetricType = thedata->isisIPRAMetricType;
		StorageNew->isisIPRAFullMetric = thedata->isisIPRAFullMetric;
		if (!(StorageNew->isisIPRASNPAAddress = malloc(thedata->isisIPRASNPAAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisIPRASNPAAddress, thedata->isisIPRASNPAAddress, thedata->isisIPRASNPAAddressLen);
		StorageNew->isisIPRASNPAAddressLen = thedata->isisIPRASNPAAddressLen;
		StorageNew->isisIPRASNPAAddress[StorageNew->isisIPRASNPAAddressLen] = 0;
		StorageNew->isisIPRASourceType = thedata->isisIPRASourceType;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisIPRATable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisIPRATable_destroy(struct isisIPRATable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisIPRATable_destroy(struct isisIPRATable_data **thedata)
{
	struct isisIPRATable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisIPRATable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisIPRADest);
		StorageDel->isisIPRADestLen = 0;
		SNMP_FREE(StorageDel->isisIPRANextHop);
		StorageDel->isisIPRANextHopLen = 0;
		SNMP_FREE(StorageDel->isisIPRASNPAAddress);
		StorageDel->isisIPRASNPAAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisIPRATable_add(struct isisIPRATable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisIPRATable table data set.
 *
 * Adds a table row structure to the isisIPRATable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisIPRATable_add(struct isisIPRATable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisIPRATable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisSysLevelIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisSysLevelIndex, sizeof(thedata->isisSysLevelIndex));
		/* isisIPRADestType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisIPRADestType, sizeof(thedata->isisIPRADestType));
		/* isisIPRADest */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisIPRADest, thedata->isisIPRADestLen);
		/* isisIPRADestPrefixLen */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisIPRADestPrefixLen, sizeof(thedata->isisIPRADestPrefixLen));
		/* isisIPRANextHopIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisIPRANextHopIndex, sizeof(thedata->isisIPRANextHopIndex));
		header_complex_add_data(&isisIPRATableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisIPRATable_del(struct isisIPRATable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisIPRATable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisIPRATable_del(struct isisIPRATable_data *thedata)
{
	struct isisIPRATable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisIPRATable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisIPRATableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisIPRATableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisIPRATable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisIPRATable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisIPRATable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisIPRATable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisIPRATable_data *StorageTmp = isisIPRATable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisIPRATable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisSysLevelIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRADestType, &tmpsize);
	SNMP_FREE(StorageTmp->isisIPRADest);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisIPRADest, &StorageTmp->isisIPRADestLen);
	if (StorageTmp->isisIPRADest == NULL) {
		config_perror("invalid specification for isisIPRADest");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisIPRADestPrefixLen, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisIPRANextHopIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRANextHopType, &tmpsize);
	SNMP_FREE(StorageTmp->isisIPRANextHop);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisIPRANextHop, &StorageTmp->isisIPRANextHopLen);
	if (StorageTmp->isisIPRANextHop == NULL) {
		config_perror("invalid specification for isisIPRANextHop");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRAType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRAExistState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRAAdminState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisIPRAMetric, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRAMetricType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisIPRAFullMetric, &tmpsize);
	SNMP_FREE(StorageTmp->isisIPRASNPAAddress);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisIPRASNPAAddress, &StorageTmp->isisIPRASNPAAddressLen);
	if (StorageTmp->isisIPRASNPAAddress == NULL) {
		config_perror("invalid specification for isisIPRASNPAAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisIPRASourceType, &tmpsize);
	isisIPRATable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisIPRATable(): store configuraiton file for isisIPRATable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisIPRATable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisIPRATable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisIPRATable: storing data...  "));
	refresh_isisIPRATable(1);
	(void) tmpsize;
	for (hcindex = isisIPRATableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisIPRATable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisIPRATable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisSysLevelIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRADestType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisIPRADest, &StorageTmp->isisIPRADestLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisIPRADestPrefixLen, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisIPRANextHopIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRANextHopType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisIPRANextHop, &StorageTmp->isisIPRANextHopLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRAType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRAExistState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRAAdminState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisIPRAMetric, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRAMetricType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisIPRAFullMetric, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisIPRASNPAAddress, &StorageTmp->isisIPRASNPAAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisIPRASourceType, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisLSPSummaryTable_data *isisLSPSummaryTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisLSPSummaryTable table.
 *
 * Creates a new isisLSPSummaryTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisLSPSummaryTable_data *
isisLSPSummaryTable_create(void)
{
	struct isisLSPSummaryTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisLSPSummaryTable_data);

	DEBUGMSGTL(("isisMIB", "isisLSPSummaryTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisLSPSeq = 0;
		StorageNew->isisLSPZeroLife = 0;
		StorageNew->isisLSPChecksum = 0;
		StorageNew->isisLSPLifetimeRemain = 0;
		StorageNew->isisLSPPDULength = 0;
		StorageNew->isisLSPAttributes = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisLSPSummaryTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisLSPSummaryTable_data *isisLSPSummaryTable_duplicate(struct isisLSPSummaryTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisLSPSummaryTable_data *
isisLSPSummaryTable_duplicate(struct isisLSPSummaryTable_data *thedata)
{
	struct isisLSPSummaryTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisLSPSummaryTable_data);

	DEBUGMSGTL(("isisMIB", "isisLSPSummaryTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisLSPSummaryTable_id = thedata->isisLSPSummaryTable_id;
		StorageNew->isisLSPLevel = thedata->isisLSPLevel;
		if (!(StorageNew->isisLSPID = malloc(thedata->isisLSPIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisLSPID, thedata->isisLSPID, thedata->isisLSPIDLen);
		StorageNew->isisLSPIDLen = thedata->isisLSPIDLen;
		StorageNew->isisLSPID[StorageNew->isisLSPIDLen] = 0;
		StorageNew->isisLSPSeq = thedata->isisLSPSeq;
		StorageNew->isisLSPZeroLife = thedata->isisLSPZeroLife;
		StorageNew->isisLSPChecksum = thedata->isisLSPChecksum;
		StorageNew->isisLSPLifetimeRemain = thedata->isisLSPLifetimeRemain;
		StorageNew->isisLSPPDULength = thedata->isisLSPPDULength;
		StorageNew->isisLSPAttributes = thedata->isisLSPAttributes;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisLSPSummaryTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisLSPSummaryTable_destroy(struct isisLSPSummaryTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisLSPSummaryTable_destroy(struct isisLSPSummaryTable_data **thedata)
{
	struct isisLSPSummaryTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisLSPSummaryTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisLSPID);
		StorageDel->isisLSPIDLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisLSPSummaryTable_add(struct isisLSPSummaryTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisLSPSummaryTable table data set.
 *
 * Adds a table row structure to the isisLSPSummaryTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisLSPSummaryTable_add(struct isisLSPSummaryTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisLSPSummaryTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisLSPLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisLSPLevel, sizeof(thedata->isisLSPLevel));
		/* isisLSPID */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisLSPID, thedata->isisLSPIDLen);
		header_complex_add_data(&isisLSPSummaryTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisLSPSummaryTable_del(struct isisLSPSummaryTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisLSPSummaryTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisLSPSummaryTable_del(struct isisLSPSummaryTable_data *thedata)
{
	struct isisLSPSummaryTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisLSPSummaryTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisLSPSummaryTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisLSPSummaryTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisLSPSummaryTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisLSPSummaryTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisLSPSummaryTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisLSPSummaryTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisLSPSummaryTable_data *StorageTmp = isisLSPSummaryTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisLSPSummaryTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisLSPLevel, &tmpsize);
	SNMP_FREE(StorageTmp->isisLSPID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisLSPID, &StorageTmp->isisLSPIDLen);
	if (StorageTmp->isisLSPID == NULL) {
		config_perror("invalid specification for isisLSPID");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPSeq, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisLSPZeroLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPChecksum, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPLifetimeRemain, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPPDULength, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPAttributes, &tmpsize);
	isisLSPSummaryTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisLSPSummaryTable(): store configuraiton file for isisLSPSummaryTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisLSPSummaryTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisLSPSummaryTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisLSPSummaryTable: storing data...  "));
	refresh_isisLSPSummaryTable(1);
	(void) tmpsize;
	for (hcindex = isisLSPSummaryTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisLSPSummaryTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisLSPSummaryTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisLSPLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisLSPID, &StorageTmp->isisLSPIDLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPSeq, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisLSPZeroLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPLifetimeRemain, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPPDULength, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPAttributes, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct isisLSPTLVTable_data *isisLSPTLVTable_create(void)
 * @brief create a fresh data structure representing a new row in the isisLSPTLVTable table.
 *
 * Creates a new isisLSPTLVTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct isisLSPTLVTable_data *
isisLSPTLVTable_create(void)
{
	struct isisLSPTLVTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisLSPTLVTable_data);

	DEBUGMSGTL(("isisMIB", "isisLSPTLVTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->isisLSPLevel = 0;
		if ((StorageNew->isisLSPID = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisLSPIDLen = 0;
		StorageNew->isisLSPID[StorageNew->isisLSPIDLen] = 0;
		StorageNew->isisLSPTLVSeq = 0;
		StorageNew->isisLSPTLVChecksum = 0;
		StorageNew->isisLSPTLVType = 0;
		StorageNew->isisLSPTLVLen = 0;
		if ((StorageNew->isisLSPTLVValue = malloc(1)) == NULL)
			goto nomem;
		StorageNew->isisLSPTLVValueLen = 0;
		StorageNew->isisLSPTLVValue[StorageNew->isisLSPTLVValueLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	isisLSPTLVTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct isisLSPTLVTable_data *isisLSPTLVTable_duplicate(struct isisLSPTLVTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct isisLSPTLVTable_data *
isisLSPTLVTable_duplicate(struct isisLSPTLVTable_data *thedata)
{
	struct isisLSPTLVTable_data *StorageNew = SNMP_MALLOC_STRUCT(isisLSPTLVTable_data);

	DEBUGMSGTL(("isisMIB", "isisLSPTLVTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->isisLSPTLVTable_id = thedata->isisLSPTLVTable_id;
		StorageNew->isisLSPLevel = thedata->isisLSPLevel;
		if (!(StorageNew->isisLSPID = malloc(thedata->isisLSPIDLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisLSPID, thedata->isisLSPID, thedata->isisLSPIDLen);
		StorageNew->isisLSPIDLen = thedata->isisLSPIDLen;
		StorageNew->isisLSPID[StorageNew->isisLSPIDLen] = 0;
		StorageNew->isisLSPTLVIndex = thedata->isisLSPTLVIndex;
		StorageNew->isisLSPTLVSeq = thedata->isisLSPTLVSeq;
		StorageNew->isisLSPTLVChecksum = thedata->isisLSPTLVChecksum;
		StorageNew->isisLSPTLVType = thedata->isisLSPTLVType;
		StorageNew->isisLSPTLVLen = thedata->isisLSPTLVLen;
		if (!(StorageNew->isisLSPTLVValue = malloc(thedata->isisLSPTLVValueLen + 1)))
			goto destroy;
		memcpy(StorageNew->isisLSPTLVValue, thedata->isisLSPTLVValue, thedata->isisLSPTLVValueLen);
		StorageNew->isisLSPTLVValueLen = thedata->isisLSPTLVValueLen;
		StorageNew->isisLSPTLVValue[StorageNew->isisLSPTLVValueLen] = 0;
	}
      done:
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	isisLSPTLVTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int isisLSPTLVTable_destroy(struct isisLSPTLVTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
isisLSPTLVTable_destroy(struct isisLSPTLVTable_data **thedata)
{
	struct isisLSPTLVTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisLSPTLVTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->isisLSPID);
		StorageDel->isisLSPIDLen = 0;
		SNMP_FREE(StorageDel->isisLSPTLVValue);
		StorageDel->isisLSPTLVValueLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisLSPTLVTable_add(struct isisLSPTLVTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the isisLSPTLVTable table data set.
 *
 * Adds a table row structure to the isisLSPTLVTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
isisLSPTLVTable_add(struct isisLSPTLVTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("isisMIB", "isisLSPTLVTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* isisLSPLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->isisLSPLevel, sizeof(thedata->isisLSPLevel));
		/* isisLSPID */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->isisLSPID, thedata->isisLSPIDLen);
		/* isisLSPTLVIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->isisLSPTLVIndex, sizeof(thedata->isisLSPTLVIndex));
		header_complex_add_data(&isisLSPTLVTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("isisMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int isisLSPTLVTable_del(struct isisLSPTLVTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the isisLSPTLVTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
isisLSPTLVTable_del(struct isisLSPTLVTable_data *thedata)
{
	struct isisLSPTLVTable_data *StorageDel;

	DEBUGMSGTL(("isisMIB", "isisLSPTLVTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(isisLSPTLVTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&isisLSPTLVTableStorage, hciptr);
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_isisLSPTLVTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for isisLSPTLVTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case isisLSPTLVTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_isisLSPTLVTable(const char *token, char *line)
{
	size_t tmpsize;
	struct isisLSPTLVTable_data *StorageTmp = isisLSPTLVTable_create();

	DEBUGMSGTL(("isisMIB", "parse_isisLSPTLVTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->isisLSPLevel, &tmpsize);
	SNMP_FREE(StorageTmp->isisLSPID);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisLSPID, &StorageTmp->isisLSPIDLen);
	if (StorageTmp->isisLSPID == NULL) {
		config_perror("invalid specification for isisLSPID");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPTLVIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPTLVSeq, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPTLVChecksum, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPTLVType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->isisLSPTLVLen, &tmpsize);
	SNMP_FREE(StorageTmp->isisLSPTLVValue);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->isisLSPTLVValue, &StorageTmp->isisLSPTLVValueLen);
	if (StorageTmp->isisLSPTLVValue == NULL) {
		config_perror("invalid specification for isisLSPTLVValue");
		return;
	}
	isisLSPTLVTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/*
 * store_isisLSPTLVTable(): store configuraiton file for isisLSPTLVTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_isisLSPTLVTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct isisLSPTLVTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("isisMIB", "store_isisLSPTLVTable: storing data...  "));
	refresh_isisLSPTLVTable(1);
	(void) tmpsize;
	for (hcindex = isisLSPTLVTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct isisLSPTLVTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "isisLSPTLVTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->isisLSPLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisLSPID, &StorageTmp->isisLSPIDLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPTLVIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPTLVSeq, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPTLVChecksum, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPTLVType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->isisLSPTLVLen, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->isisLSPTLVValue, &StorageTmp->isisLSPTLVValueLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isisCircTable_row(struct isisCircTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisCircTable_row(struct isisCircTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisCircTable_row(struct isisCircTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisCircTable_row(struct isisCircTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isisRATable_row(struct isisRATable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisRATable_row(struct isisRATable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisRATable_row(struct isisRATable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisRATable_row(struct isisRATable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisManAreaAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisManAreaAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, struct isisManAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisManAreaAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisManAreaAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisManAreaAddrTable_data *
refresh_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisManAreaAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisManAreaAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisManAreaAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisManAreaAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisManAreaAddrTable(int force)
{
	if (!force && isisManAreaAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisManAreaAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisManAreaAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisManAreaAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisManAreaAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisManAreaAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisManAreaAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisManAreaAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisManAreaAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisManAreaAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISMANAREAADDREXISTSTATE:	/* Create */
		*write_method = write_isisManAreaAddrExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisManAreaAddrExistState);
		rval = (u_char *) &StorageTmp->isisManAreaAddrExistState;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisAreaAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisAreaAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, struct isisAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisAreaAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisAreaAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisAreaAddrTable_data *
refresh_isisAreaAddrTable_row(struct isisAreaAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisAreaAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisAreaAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisAreaAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisAreaAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisAreaAddrTable(int force)
{
	if (!force && isisAreaAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisAreaAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisAreaAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisAreaAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisAreaAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisAreaAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisAreaAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisAreaAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisAreaAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisAreaAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisSummAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisSummAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, struct isisSummAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisSummAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisSummAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisSummAddrTable_data *
refresh_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisSummAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisSummAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisSummAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisSummAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisSummAddrTable(int force)
{
	if (!force && isisSummAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisSummAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisSummAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisSummAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisSummAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisSummAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisSummAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisSummAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisSummAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisSummAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISSUMMADDREXISTSTATE:	/* Create */
		*write_method = write_isisSummAddrExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSummAddrExistState);
		rval = (u_char *) &StorageTmp->isisSummAddrExistState;
		break;
	case (u_char) ISISSUMMADDRMETRIC:	/* Create */
		*write_method = write_isisSummAddrMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSummAddrMetric);
		rval = (u_char *) &StorageTmp->isisSummAddrMetric;
		break;
	case (u_char) ISISSUMMADDRFULLMETRIC:	/* Create */
		*write_method = write_isisSummAddrFullMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSummAddrFullMetric);
		rval = (u_char *) &StorageTmp->isisSummAddrFullMetric;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisRedistributeAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisRedistributeAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, struct isisRedistributeAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisRedistributeAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisRedistributeAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisRedistributeAddrTable_data *
refresh_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisRedistributeAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisRedistributeAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisRedistributeAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisRedistributeAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisRedistributeAddrTable(int force)
{
	if (!force && isisRedistributeAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisRedistributeAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisRedistributeAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisRedistributeAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisRedistributeAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisRedistributeAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisRedistributeAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisRedistributeAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisRedistributeAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisRedistributeAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISREDISTRIBUTEADDREXISTSTATE:	/* Create */
		*write_method = write_isisRedistributeAddrExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRedistributeAddrExistState);
		rval = (u_char *) &StorageTmp->isisRedistributeAddrExistState;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisRouterTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisRouterTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, struct isisRouterTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisRouterTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisRouterTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisRouterTable_data *
refresh_isisRouterTable_row(struct isisRouterTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisRouterTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisRouterTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisRouterTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisRouterTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisRouterTable(int force)
{
	if (!force && isisRouterTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisRouterTable_refresh = 0;
}

/**
 * @fn u_char *var_isisRouterTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisRouterTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisRouterTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisRouterTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisRouterTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisRouterTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisRouterTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisRouterTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISROUTERHOSTNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisRouterHostNameLen;
		rval = (u_char *) StorageTmp->isisRouterHostName;
		break;
	case (u_char) ISISROUTERID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRouterID);
		rval = (u_char *) &StorageTmp->isisRouterID;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisSysLevelTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisSysLevelTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, struct isisSysLevelTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisSysLevelTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisSysLevelTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisSysLevelTable_data *
refresh_isisSysLevelTable_row(struct isisSysLevelTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisSysLevelTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisSysLevelTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisSysLevelTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisSysLevelTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisSysLevelTable(int force)
{
	if (!force && isisSysLevelTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisSysLevelTable_refresh = 0;
}

/**
 * @fn u_char *var_isisSysLevelTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisSysLevelTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisSysLevelTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisSysLevelTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisSysLevelTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisSysLevelTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisSysLevelTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisSysLevelTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISSYSLEVELORIGLSPBUFFSIZE:	/* ReadWrite */
		*write_method = write_isisSysLevelOrigLSPBuffSize;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelOrigLSPBuffSize);
		rval = (u_char *) &StorageTmp->isisSysLevelOrigLSPBuffSize;
		break;
	case (u_char) ISISSYSLEVELMINLSPGENINT:	/* ReadWrite */
		*write_method = write_isisSysLevelMinLSPGenInt;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelMinLSPGenInt);
		rval = (u_char *) &StorageTmp->isisSysLevelMinLSPGenInt;
		break;
	case (u_char) ISISSYSLEVELSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelState);
		rval = (u_char *) &StorageTmp->isisSysLevelState;
		break;
	case (u_char) ISISSYSLEVELSETOVERLOAD:	/* ReadWrite */
		*write_method = write_isisSysLevelSetOverload;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelSetOverload);
		rval = (u_char *) &StorageTmp->isisSysLevelSetOverload;
		break;
	case (u_char) ISISSYSLEVELSETOVERLOADUNTIL:	/* ReadWrite */
		*write_method = write_isisSysLevelSetOverloadUntil;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelSetOverloadUntil);
		rval = (u_char *) &StorageTmp->isisSysLevelSetOverloadUntil;
		break;
	case (u_char) ISISSYSLEVELMETRICSTYLE:	/* ReadWrite */
		*write_method = write_isisSysLevelMetricStyle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelMetricStyle);
		rval = (u_char *) &StorageTmp->isisSysLevelMetricStyle;
		break;
	case (u_char) ISISSYSLEVELSPFCONSIDERS:	/* ReadWrite */
		*write_method = write_isisSysLevelSPFConsiders;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelSPFConsiders);
		rval = (u_char *) &StorageTmp->isisSysLevelSPFConsiders;
		break;
	case (u_char) ISISSYSLEVELTEENABLED:	/* ReadWrite */
		*write_method = write_isisSysLevelTEEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysLevelTEEnabled);
		rval = (u_char *) &StorageTmp->isisSysLevelTEEnabled;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisCircTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisCircTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisCircTable_row(struct isisCircTable_data *StorageTmp, struct isisCircTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisCircTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisCircTable_row(struct isisCircTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisCircTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisCircTable_data *
refresh_isisCircTable_row(struct isisCircTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisCircTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisCircTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisCircTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisCircTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisCircTable(int force)
{
	if (!force && isisCircTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisCircTable_refresh = 0;
}

/**
 * @fn u_char *var_isisCircTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisCircTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisCircTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisCircTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisCircTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisCircTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisCircTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisCircTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISCIRCIFINDEX:	/* Create */
		*write_method = write_isisCircIfIndex;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircIfIndex);
		rval = (u_char *) &StorageTmp->isisCircIfIndex;
		break;
	case (u_char) ISISCIRCADMINSTATE:	/* Create */
		*write_method = write_isisCircAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircAdminState);
		rval = (u_char *) &StorageTmp->isisCircAdminState;
		break;
	case (u_char) ISISCIRCEXISTSTATE:	/* Create */
		*write_method = write_isisCircExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircExistState);
		rval = (u_char *) &StorageTmp->isisCircExistState;
		break;
	case (u_char) ISISCIRCTYPE:	/* Create */
		*write_method = write_isisCircType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircType);
		rval = (u_char *) &StorageTmp->isisCircType;
		break;
	case (u_char) ISISCIRCEXTDOMAIN:	/* Create */
		*write_method = write_isisCircExtDomain;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircExtDomain);
		rval = (u_char *) &StorageTmp->isisCircExtDomain;
		break;
	case (u_char) ISISCIRCLEVELTYPE:	/* Create */
		*write_method = write_isisCircLevelType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelType);
		rval = (u_char *) &StorageTmp->isisCircLevelType;
		break;
	case (u_char) ISISCIRCPASSIVECIRCUIT:	/* Create */
		*write_method = write_isisCircPassiveCircuit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircPassiveCircuit);
		rval = (u_char *) &StorageTmp->isisCircPassiveCircuit;
		break;
	case (u_char) ISISCIRCMESHGROUPENABLED:	/* Create */
		*write_method = write_isisCircMeshGroupEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircMeshGroupEnabled);
		rval = (u_char *) &StorageTmp->isisCircMeshGroupEnabled;
		break;
	case (u_char) ISISCIRCMESHGROUP:	/* Create */
		*write_method = write_isisCircMeshGroup;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircMeshGroup);
		rval = (u_char *) &StorageTmp->isisCircMeshGroup;
		break;
	case (u_char) ISISCIRCSMALLHELLOS:	/* Create */
		*write_method = write_isisCircSmallHellos;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircSmallHellos);
		rval = (u_char *) &StorageTmp->isisCircSmallHellos;
		break;
	case (u_char) ISISCIRCLASTUPTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLastUpTime);
		rval = (u_char *) &StorageTmp->isisCircLastUpTime;
		break;
	case (u_char) ISISCIRC3WAYENABLED:	/* Create */
		*write_method = write_isisCirc3WayEnabled;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCirc3WayEnabled);
		rval = (u_char *) &StorageTmp->isisCirc3WayEnabled;
		break;
	case (u_char) ISISCIRCEXTENDEDCIRCID:	/* Create */
		*write_method = write_isisCircExtendedCircID;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircExtendedCircID);
		rval = (u_char *) &StorageTmp->isisCircExtendedCircID;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisCircLevelTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisCircLevelTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, struct isisCircLevelTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisCircLevelTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisCircLevelTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisCircLevelTable_data *
refresh_isisCircLevelTable_row(struct isisCircLevelTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisCircLevelTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisCircLevelTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisCircLevelTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisCircLevelTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisCircLevelTable(int force)
{
	if (!force && isisCircLevelTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisCircLevelTable_refresh = 0;
}

/**
 * @fn u_char *var_isisCircLevelTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisCircLevelTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisCircLevelTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisCircLevelTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisCircLevelTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisCircLevelTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisCircLevelTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisCircLevelTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISCIRCLEVELMETRIC:	/* ReadWrite */
		*write_method = write_isisCircLevelMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelMetric);
		rval = (u_char *) &StorageTmp->isisCircLevelMetric;
		break;
	case (u_char) ISISCIRCLEVELWIDEMETRIC:	/* ReadWrite */
		*write_method = write_isisCircLevelWideMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelWideMetric);
		rval = (u_char *) &StorageTmp->isisCircLevelWideMetric;
		break;
	case (u_char) ISISCIRCLEVELISPRIORITY:	/* ReadWrite */
		*write_method = write_isisCircLevelISPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelISPriority);
		rval = (u_char *) &StorageTmp->isisCircLevelISPriority;
		break;
	case (u_char) ISISCIRCLEVELIDOCTET:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelIDOctet);
		rval = (u_char *) &StorageTmp->isisCircLevelIDOctet;
		break;
	case (u_char) ISISCIRCLEVELID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisCircLevelIDLen;
		rval = (u_char *) StorageTmp->isisCircLevelID;
		break;
	case (u_char) ISISCIRCLEVELDESIS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisCircLevelDesISLen;
		rval = (u_char *) StorageTmp->isisCircLevelDesIS;
		break;
	case (u_char) ISISCIRCLEVELHELLOMULTIPLIER:	/* ReadWrite */
		*write_method = write_isisCircLevelHelloMultiplier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelHelloMultiplier);
		rval = (u_char *) &StorageTmp->isisCircLevelHelloMultiplier;
		break;
	case (u_char) ISISCIRCLEVELHELLOTIMER:	/* ReadWrite */
		*write_method = write_isisCircLevelHelloTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelHelloTimer);
		rval = (u_char *) &StorageTmp->isisCircLevelHelloTimer;
		break;
	case (u_char) ISISCIRCLEVELDRHELLOTIMER:	/* ReadWrite */
		*write_method = write_isisCircLevelDRHelloTimer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelDRHelloTimer);
		rval = (u_char *) &StorageTmp->isisCircLevelDRHelloTimer;
		break;
	case (u_char) ISISCIRCLEVELLSPTHROTTLE:	/* ReadWrite */
		*write_method = write_isisCircLevelLSPThrottle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelLSPThrottle);
		rval = (u_char *) &StorageTmp->isisCircLevelLSPThrottle;
		break;
	case (u_char) ISISCIRCLEVELMINLSPRETRANSINT:	/* ReadWrite */
		*write_method = write_isisCircLevelMinLSPRetransInt;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelMinLSPRetransInt);
		rval = (u_char *) &StorageTmp->isisCircLevelMinLSPRetransInt;
		break;
	case (u_char) ISISCIRCLEVELCSNPINTERVAL:	/* ReadWrite */
		*write_method = write_isisCircLevelCSNPInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelCSNPInterval);
		rval = (u_char *) &StorageTmp->isisCircLevelCSNPInterval;
		break;
	case (u_char) ISISCIRCLEVELPARTSNPINTERVAL:	/* ReadWrite */
		*write_method = write_isisCircLevelPartSNPInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLevelPartSNPInterval);
		rval = (u_char *) &StorageTmp->isisCircLevelPartSNPInterval;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisSystemCounterTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisSystemCounterTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, struct isisSystemCounterTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisSystemCounterTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisSystemCounterTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisSystemCounterTable_data *
refresh_isisSystemCounterTable_row(struct isisSystemCounterTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisSystemCounterTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisSystemCounterTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisSystemCounterTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisSystemCounterTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisSystemCounterTable(int force)
{
	if (!force && isisSystemCounterTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisSystemCounterTable_refresh = 0;
}

/**
 * @fn u_char *var_isisSystemCounterTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisSystemCounterTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisSystemCounterTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisSystemCounterTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisSystemCounterTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisSystemCounterTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisSystemCounterTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisSystemCounterTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISSYSSTATCORRLSPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatCorrLSPs);
		rval = (u_char *) &StorageTmp->isisSysStatCorrLSPs;
		break;
	case (u_char) ISISSYSSTATAUTHTYPEFAILS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatAuthTypeFails);
		rval = (u_char *) &StorageTmp->isisSysStatAuthTypeFails;
		break;
	case (u_char) ISISSYSSTATAUTHFAILS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatAuthFails);
		rval = (u_char *) &StorageTmp->isisSysStatAuthFails;
		break;
	case (u_char) ISISSYSSTATLSPDBASEOLOADS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatLSPDbaseOloads);
		rval = (u_char *) &StorageTmp->isisSysStatLSPDbaseOloads;
		break;
	case (u_char) ISISSYSSTATMANADDRDROPFROMAREAS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatManAddrDropFromAreas);
		rval = (u_char *) &StorageTmp->isisSysStatManAddrDropFromAreas;
		break;
	case (u_char) ISISSYSSTATATTMPTTOEXMAXSEQNUMS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatAttmptToExMaxSeqNums);
		rval = (u_char *) &StorageTmp->isisSysStatAttmptToExMaxSeqNums;
		break;
	case (u_char) ISISSYSSTATSEQNUMSKIPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatSeqNumSkips);
		rval = (u_char *) &StorageTmp->isisSysStatSeqNumSkips;
		break;
	case (u_char) ISISSYSSTATOWNLSPPURGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatOwnLSPPurges);
		rval = (u_char *) &StorageTmp->isisSysStatOwnLSPPurges;
		break;
	case (u_char) ISISSYSSTATIDFIELDLENMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatIDFieldLenMismatches);
		rval = (u_char *) &StorageTmp->isisSysStatIDFieldLenMismatches;
		break;
	case (u_char) ISISSYSSTATPARTCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatPartChanges);
		rval = (u_char *) &StorageTmp->isisSysStatPartChanges;
		break;
	case (u_char) ISISSYSSTATSPFRUNS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatSPFRuns);
		rval = (u_char *) &StorageTmp->isisSysStatSPFRuns;
		break;
	case (u_char) ISISSYSSTATLSPERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisSysStatLSPErrors);
		rval = (u_char *) &StorageTmp->isisSysStatLSPErrors;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisCircuitCounterTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisCircuitCounterTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, struct isisCircuitCounterTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisCircuitCounterTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisCircuitCounterTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisCircuitCounterTable_data *
refresh_isisCircuitCounterTable_row(struct isisCircuitCounterTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisCircuitCounterTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisCircuitCounterTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisCircuitCounterTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisCircuitCounterTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisCircuitCounterTable(int force)
{
	if (!force && isisCircuitCounterTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisCircuitCounterTable_refresh = 0;
}

/**
 * @fn u_char *var_isisCircuitCounterTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisCircuitCounterTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisCircuitCounterTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisCircuitCounterTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisCircuitCounterTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisCircuitCounterTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisCircuitCounterTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisCircuitCounterTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISCIRCADJCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircAdjChanges);
		rval = (u_char *) &StorageTmp->isisCircAdjChanges;
		break;
	case (u_char) ISISCIRCNUMADJ:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircNumAdj);
		rval = (u_char *) &StorageTmp->isisCircNumAdj;
		break;
	case (u_char) ISISCIRCINITFAILS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircInitFails);
		rval = (u_char *) &StorageTmp->isisCircInitFails;
		break;
	case (u_char) ISISCIRCREJADJS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircRejAdjs);
		rval = (u_char *) &StorageTmp->isisCircRejAdjs;
		break;
	case (u_char) ISISCIRCIDFIELDLENMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircIDFieldLenMismatches);
		rval = (u_char *) &StorageTmp->isisCircIDFieldLenMismatches;
		break;
	case (u_char) ISISCIRCMAXAREAADDRMISMATCHES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircMaxAreaAddrMismatches);
		rval = (u_char *) &StorageTmp->isisCircMaxAreaAddrMismatches;
		break;
	case (u_char) ISISCIRCAUTHTYPEFAILS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircAuthTypeFails);
		rval = (u_char *) &StorageTmp->isisCircAuthTypeFails;
		break;
	case (u_char) ISISCIRCAUTHFAILS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircAuthFails);
		rval = (u_char *) &StorageTmp->isisCircAuthFails;
		break;
	case (u_char) ISISCIRCLANDESISCHANGES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisCircLANDesISChanges);
		rval = (u_char *) &StorageTmp->isisCircLANDesISChanges;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisPacketCounterTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisPacketCounterTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, struct isisPacketCounterTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisPacketCounterTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisPacketCounterTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisPacketCounterTable_data *
refresh_isisPacketCounterTable_row(struct isisPacketCounterTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisPacketCounterTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisPacketCounterTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisPacketCounterTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisPacketCounterTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisPacketCounterTable(int force)
{
	if (!force && isisPacketCounterTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisPacketCounterTable_refresh = 0;
}

/**
 * @fn u_char *var_isisPacketCounterTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisPacketCounterTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisPacketCounterTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisPacketCounterTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisPacketCounterTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisPacketCounterTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisPacketCounterTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisPacketCounterTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISPACKETCOUNTIIHELLO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountIIHello);
		rval = (u_char *) &StorageTmp->isisPacketCountIIHello;
		break;
	case (u_char) ISISPACKETCOUNTISHELLO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountISHello);
		rval = (u_char *) &StorageTmp->isisPacketCountISHello;
		break;
	case (u_char) ISISPACKETCOUNTESHELLO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountESHello);
		rval = (u_char *) &StorageTmp->isisPacketCountESHello;
		break;
	case (u_char) ISISPACKETCOUNTLSP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountLSP);
		rval = (u_char *) &StorageTmp->isisPacketCountLSP;
		break;
	case (u_char) ISISPACKETCOUNTCSNP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountCSNP);
		rval = (u_char *) &StorageTmp->isisPacketCountCSNP;
		break;
	case (u_char) ISISPACKETCOUNTPSNP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountPSNP);
		rval = (u_char *) &StorageTmp->isisPacketCountPSNP;
		break;
	case (u_char) ISISPACKETCOUNTUNKNOWN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisPacketCountUnknown);
		rval = (u_char *) &StorageTmp->isisPacketCountUnknown;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisISAdjTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisISAdjTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, struct isisISAdjTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisISAdjTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisISAdjTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisISAdjTable_data *
refresh_isisISAdjTable_row(struct isisISAdjTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisISAdjTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisISAdjTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisISAdjTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisISAdjTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisISAdjTable(int force)
{
	if (!force && isisISAdjTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisISAdjTable_refresh = 0;
}

/**
 * @fn u_char *var_isisISAdjTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisISAdjTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisISAdjTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisISAdjTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisISAdjTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisISAdjTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisISAdjTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisISAdjTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISISADJSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjState);
		rval = (u_char *) &StorageTmp->isisISAdjState;
		break;
	case (u_char) ISISISADJ3WAYSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdj3WayState);
		rval = (u_char *) &StorageTmp->isisISAdj3WayState;
		break;
	case (u_char) ISISISADJNEIGHSNPAADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisISAdjNeighSNPAAddressLen;
		rval = (u_char *) StorageTmp->isisISAdjNeighSNPAAddress;
		break;
	case (u_char) ISISISADJNEIGHSYSTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjNeighSysType);
		rval = (u_char *) &StorageTmp->isisISAdjNeighSysType;
		break;
	case (u_char) ISISISADJNEIGHSYSID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisISAdjNeighSysIDLen;
		rval = (u_char *) StorageTmp->isisISAdjNeighSysID;
		break;
	case (u_char) ISISISADJNBREXTENDEDCIRCID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjNbrExtendedCircID);
		rval = (u_char *) &StorageTmp->isisISAdjNbrExtendedCircID;
		break;
	case (u_char) ISISISADJUSAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjUsage);
		rval = (u_char *) &StorageTmp->isisISAdjUsage;
		break;
	case (u_char) ISISISADJHOLDTIMER:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjHoldTimer);
		rval = (u_char *) &StorageTmp->isisISAdjHoldTimer;
		break;
	case (u_char) ISISISADJNEIGHPRIORITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjNeighPriority);
		rval = (u_char *) &StorageTmp->isisISAdjNeighPriority;
		break;
	case (u_char) ISISISADJLASTUPTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjLastUpTime);
		rval = (u_char *) &StorageTmp->isisISAdjLastUpTime;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisISAdjAreaAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisISAdjAreaAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, struct isisISAdjAreaAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisISAdjAreaAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisISAdjAreaAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisISAdjAreaAddrTable_data *
refresh_isisISAdjAreaAddrTable_row(struct isisISAdjAreaAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisISAdjAreaAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisISAdjAreaAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisISAdjAreaAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisISAdjAreaAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisISAdjAreaAddrTable(int force)
{
	if (!force && isisISAdjAreaAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisISAdjAreaAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisISAdjAreaAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisISAdjAreaAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisISAdjAreaAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisISAdjAreaAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisISAdjAreaAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisISAdjAreaAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisISAdjAreaAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisISAdjAreaAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISISADJAREAADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisISAdjAreaAddressLen;
		rval = (u_char *) StorageTmp->isisISAdjAreaAddress;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisISAdjIPAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisISAdjIPAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, struct isisISAdjIPAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisISAdjIPAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisISAdjIPAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisISAdjIPAddrTable_data *
refresh_isisISAdjIPAddrTable_row(struct isisISAdjIPAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisISAdjIPAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisISAdjIPAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisISAdjIPAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisISAdjIPAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisISAdjIPAddrTable(int force)
{
	if (!force && isisISAdjIPAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisISAdjIPAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_isisISAdjIPAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisISAdjIPAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisISAdjIPAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisISAdjIPAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisISAdjIPAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisISAdjIPAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisISAdjIPAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisISAdjIPAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISISADJIPADDRTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisISAdjIPAddrType);
		rval = (u_char *) &StorageTmp->isisISAdjIPAddrType;
		break;
	case (u_char) ISISISADJIPADDRADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisISAdjIPAddrAddressLen;
		rval = (u_char *) StorageTmp->isisISAdjIPAddrAddress;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisISAdjProtSuppTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisISAdjProtSuppTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, struct isisISAdjProtSuppTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisISAdjProtSuppTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisISAdjProtSuppTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisISAdjProtSuppTable_data *
refresh_isisISAdjProtSuppTable_row(struct isisISAdjProtSuppTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisISAdjProtSuppTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisISAdjProtSuppTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisISAdjProtSuppTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisISAdjProtSuppTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisISAdjProtSuppTable(int force)
{
	if (!force && isisISAdjProtSuppTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisISAdjProtSuppTable_refresh = 0;
}

/**
 * @fn u_char *var_isisISAdjProtSuppTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisISAdjProtSuppTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisISAdjProtSuppTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisISAdjProtSuppTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisISAdjProtSuppTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisISAdjProtSuppTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisISAdjProtSuppTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisISAdjProtSuppTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisRATable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisRATable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisRATable_row(struct isisRATable_data *StorageTmp, struct isisRATable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisRATable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisRATable_row(struct isisRATable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisRATable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisRATable_data *
refresh_isisRATable_row(struct isisRATable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisRATable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisRATable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisRATable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisRATable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisRATable(int force)
{
	if (!force && isisRATable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisRATable_refresh = 0;
}

/**
 * @fn u_char *var_isisRATable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisRATable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisRATable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisRATable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisRATable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisRATable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisRATableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisRATable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISRAEXISTSTATE:	/* Create */
		*write_method = write_isisRAExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAExistState);
		rval = (u_char *) &StorageTmp->isisRAExistState;
		break;
	case (u_char) ISISRAADMINSTATE:	/* Create */
		*write_method = write_isisRAAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAAdminState);
		rval = (u_char *) &StorageTmp->isisRAAdminState;
		break;
	case (u_char) ISISRAADDRPREFIX:	/* Create */
		*write_method = write_isisRAAddrPrefix;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisRAAddrPrefixLen;
		rval = (u_char *) StorageTmp->isisRAAddrPrefix;
		break;
	case (u_char) ISISRAMAPTYPE:	/* Create */
		*write_method = write_isisRAMapType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAMapType);
		rval = (u_char *) &StorageTmp->isisRAMapType;
		break;
	case (u_char) ISISRAMETRIC:	/* Create */
		*write_method = write_isisRAMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAMetric);
		rval = (u_char *) &StorageTmp->isisRAMetric;
		break;
	case (u_char) ISISRAMETRICTYPE:	/* Create */
		*write_method = write_isisRAMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAMetricType);
		rval = (u_char *) &StorageTmp->isisRAMetricType;
		break;
	case (u_char) ISISRASNPAADDRESS:	/* Create */
		*write_method = write_isisRASNPAAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisRASNPAAddressLen;
		rval = (u_char *) StorageTmp->isisRASNPAAddress;
		break;
	case (u_char) ISISRASNPAMASK:	/* Create */
		*write_method = write_isisRASNPAMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisRASNPAMaskLen;
		rval = (u_char *) StorageTmp->isisRASNPAMask;
		break;
	case (u_char) ISISRASNPAPREFIX:	/* Create */
		*write_method = write_isisRASNPAPrefix;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisRASNPAPrefixLen;
		rval = (u_char *) StorageTmp->isisRASNPAPrefix;
		break;
	case (u_char) ISISRATYPE:	/* Create */
		*write_method = write_isisRAType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisRAType);
		rval = (u_char *) &StorageTmp->isisRAType;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisIPRATable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisIPRATable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, struct isisIPRATable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisIPRATable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisIPRATable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisIPRATable_data *
refresh_isisIPRATable_row(struct isisIPRATable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisIPRATable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisIPRATable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisIPRATable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisIPRATable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisIPRATable(int force)
{
	if (!force && isisIPRATable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisIPRATable_refresh = 0;
}

/**
 * @fn u_char *var_isisIPRATable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisIPRATable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisIPRATable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisIPRATable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisIPRATable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisIPRATable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisIPRATableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisIPRATable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISIPRANEXTHOPTYPE:	/* Create */
		*write_method = write_isisIPRANextHopType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRANextHopType);
		rval = (u_char *) &StorageTmp->isisIPRANextHopType;
		break;
	case (u_char) ISISIPRANEXTHOP:	/* Create */
		*write_method = write_isisIPRANextHop;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisIPRANextHopLen;
		rval = (u_char *) StorageTmp->isisIPRANextHop;
		break;
	case (u_char) ISISIPRATYPE:	/* Create */
		*write_method = write_isisIPRAType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAType);
		rval = (u_char *) &StorageTmp->isisIPRAType;
		break;
	case (u_char) ISISIPRAEXISTSTATE:	/* Create */
		*write_method = write_isisIPRAExistState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAExistState);
		rval = (u_char *) &StorageTmp->isisIPRAExistState;
		break;
	case (u_char) ISISIPRAADMINSTATE:	/* Create */
		*write_method = write_isisIPRAAdminState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAAdminState);
		rval = (u_char *) &StorageTmp->isisIPRAAdminState;
		break;
	case (u_char) ISISIPRAMETRIC:	/* Create */
		*write_method = write_isisIPRAMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAMetric);
		rval = (u_char *) &StorageTmp->isisIPRAMetric;
		break;
	case (u_char) ISISIPRAMETRICTYPE:	/* Create */
		*write_method = write_isisIPRAMetricType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAMetricType);
		rval = (u_char *) &StorageTmp->isisIPRAMetricType;
		break;
	case (u_char) ISISIPRAFULLMETRIC:	/* Create */
		*write_method = write_isisIPRAFullMetric;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRAFullMetric);
		rval = (u_char *) &StorageTmp->isisIPRAFullMetric;
		break;
	case (u_char) ISISIPRASNPAADDRESS:	/* Create */
		*write_method = write_isisIPRASNPAAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisIPRASNPAAddressLen;
		rval = (u_char *) StorageTmp->isisIPRASNPAAddress;
		break;
	case (u_char) ISISIPRASOURCETYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisIPRASourceType);
		rval = (u_char *) &StorageTmp->isisIPRASourceType;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisLSPSummaryTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisLSPSummaryTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, struct isisLSPSummaryTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisLSPSummaryTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisLSPSummaryTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisLSPSummaryTable_data *
refresh_isisLSPSummaryTable_row(struct isisLSPSummaryTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisLSPSummaryTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisLSPSummaryTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisLSPSummaryTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisLSPSummaryTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisLSPSummaryTable(int force)
{
	if (!force && isisLSPSummaryTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisLSPSummaryTable_refresh = 0;
}

/**
 * @fn u_char *var_isisLSPSummaryTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisLSPSummaryTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisLSPSummaryTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisLSPSummaryTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisLSPSummaryTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisLSPSummaryTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisLSPSummaryTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisLSPSummaryTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISLSPSEQ:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPSeq);
		rval = (u_char *) &StorageTmp->isisLSPSeq;
		break;
	case (u_char) ISISLSPZEROLIFE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPZeroLife);
		rval = (u_char *) &StorageTmp->isisLSPZeroLife;
		break;
	case (u_char) ISISLSPCHECKSUM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPChecksum);
		rval = (u_char *) &StorageTmp->isisLSPChecksum;
		break;
	case (u_char) ISISLSPLIFETIMEREMAIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPLifetimeRemain);
		rval = (u_char *) &StorageTmp->isisLSPLifetimeRemain;
		break;
	case (u_char) ISISLSPPDULENGTH:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPPDULength);
		rval = (u_char *) &StorageTmp->isisLSPPDULength;
		break;
	case (u_char) ISISLSPATTRIBUTES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPAttributes);
		rval = (u_char *) &StorageTmp->isisLSPAttributes;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_isisLSPTLVTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	isisLSPTLVTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, struct isisLSPTLVTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_isisLSPTLVTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the isisLSPTLVTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct isisLSPTLVTable_data *
refresh_isisLSPTLVTable_row(struct isisLSPTLVTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->isisLSPTLVTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->isisLSPTLVTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_isisLSPTLVTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the isisLSPTLVTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_isisLSPTLVTable(int force)
{
	if (!force && isisLSPTLVTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	isisLSPTLVTable_refresh = 0;
}

/**
 * @fn u_char *var_isisLSPTLVTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in isisLSPTLVTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_isisMIB above.
 */
u_char *
var_isisLSPTLVTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct isisLSPTLVTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("isisMIB", "var_isisLSPTLVTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_isisLSPTLVTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(isisLSPTLVTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_isisLSPTLVTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) ISISLSPTLVSEQ:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPTLVSeq);
		rval = (u_char *) &StorageTmp->isisLSPTLVSeq;
		break;
	case (u_char) ISISLSPTLVCHECKSUM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPTLVChecksum);
		rval = (u_char *) &StorageTmp->isisLSPTLVChecksum;
		break;
	case (u_char) ISISLSPTLVTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPTLVType);
		rval = (u_char *) &StorageTmp->isisLSPTLVType;
		break;
	case (u_char) ISISLSPTLVLEN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->isisLSPTLVLen);
		rval = (u_char *) &StorageTmp->isisLSPTLVLen;
		break;
	case (u_char) ISISLSPTLVVALUE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->isisLSPTLVValueLen;
		rval = (u_char *) StorageTmp->isisLSPTLVValue;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_isisSummAddrMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSummAddrMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSummAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSummAddrMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSummAddrTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisSummAddrExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			if (StorageTmp->isisSummAddrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSummAddrTable_old = isisSummAddrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSummAddrTable_rsvs++;
		StorageTmp->isisSummAddrMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSummAddrTable_tsts == 0)
				if ((ret = check_isisSummAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSummAddrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSummAddrMetric for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSummAddrTable_sets == 0)
				if ((ret = update_isisSummAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSummAddrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
			StorageTmp->isisSummAddrTable_rsvs = 0;
			StorageTmp->isisSummAddrTable_tsts = 0;
			StorageTmp->isisSummAddrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSummAddrTable_sets == 0)
			revert_isisSummAddrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			break;
		StorageTmp->isisSummAddrMetric = StorageOld->isisSummAddrMetric;
		if (--StorageTmp->isisSummAddrTable_rsvs == 0)
			isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSummAddrFullMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSummAddrFullMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSummAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSummAddrFullMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSummAddrTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisSummAddrExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrFullMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrFullMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrFullMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			if (StorageTmp->isisSummAddrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSummAddrTable_old = isisSummAddrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSummAddrTable_rsvs++;
		StorageTmp->isisSummAddrFullMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSummAddrTable_tsts == 0)
				if ((ret = check_isisSummAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSummAddrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSummAddrFullMetric for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSummAddrTable_sets == 0)
				if ((ret = update_isisSummAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSummAddrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
			isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
			StorageTmp->isisSummAddrTable_rsvs = 0;
			StorageTmp->isisSummAddrTable_tsts = 0;
			StorageTmp->isisSummAddrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSummAddrTable_sets == 0)
			revert_isisSummAddrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
			break;
		StorageTmp->isisSummAddrFullMetric = StorageOld->isisSummAddrFullMetric;
		if (--StorageTmp->isisSummAddrTable_rsvs == 0)
			isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelOrigLSPBuffSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelOrigLSPBuffSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelOrigLSPBuffSize entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelOrigLSPBuffSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelOrigLSPBuffSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1492 */
		/* Note: ranges 512..16000 */
		if ((512 > set_value || set_value > 16000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelOrigLSPBuffSize: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelOrigLSPBuffSize = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelOrigLSPBuffSize for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelOrigLSPBuffSize = StorageOld->isisSysLevelOrigLSPBuffSize;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelMinLSPGenInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelMinLSPGenInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelMinLSPGenInt entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMinLSPGenInt not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMinLSPGenInt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 30 */
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMinLSPGenInt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelMinLSPGenInt = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelMinLSPGenInt for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelMinLSPGenInt = StorageOld->isisSysLevelMinLSPGenInt;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelSetOverload(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelSetOverload(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelSetOverload entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSetOverload not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSetOverload: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSetOverload: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelSetOverload = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelSetOverload for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelSetOverload = StorageOld->isisSysLevelSetOverload;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelSetOverloadUntil(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelSetOverloadUntil(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelSetOverloadUntil entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSetOverloadUntil not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSetOverloadUntil: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelSetOverloadUntil = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelSetOverloadUntil for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelSetOverloadUntil = StorageOld->isisSysLevelSetOverloadUntil;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelMetricStyle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelMetricStyle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelMetricStyle entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMetricStyle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMetricStyle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value narrow */
		switch (set_value) {
		case ISISSYSLEVELMETRICSTYLE_NARROW:
		case ISISSYSLEVELMETRICSTYLE_WIDE:
		case ISISSYSLEVELMETRICSTYLE_BOTH:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelMetricStyle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelMetricStyle = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelMetricStyle for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelMetricStyle = StorageOld->isisSysLevelMetricStyle;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelSPFConsiders(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelSPFConsiders(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelSPFConsiders entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSPFConsiders not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSPFConsiders: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value narrow */
		switch (set_value) {
		case ISISSYSLEVELSPFCONSIDERS_NARROW:
		case ISISSYSLEVELSPFCONSIDERS_WIDE:
		case ISISSYSLEVELSPFCONSIDERS_BOTH:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelSPFConsiders: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelSPFConsiders = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelSPFConsiders for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelSPFConsiders = StorageOld->isisSysLevelSPFConsiders;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelTEEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisSysLevelTEEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSysLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelTEEnabled entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisSysLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelTEEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelTEEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelTEEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			if (StorageTmp->isisSysLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisSysLevelTable_old = isisSysLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisSysLevelTable_rsvs++;
		StorageTmp->isisSysLevelTEEnabled = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisSysLevelTable_tsts == 0)
				if ((ret = check_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelTEEnabled for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisSysLevelTable_sets == 0)
				if ((ret = update_isisSysLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisSysLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) != NULL) {
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
			StorageTmp->isisSysLevelTable_rsvs = 0;
			StorageTmp->isisSysLevelTable_tsts = 0;
			StorageTmp->isisSysLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisSysLevelTable_sets == 0)
			revert_isisSysLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisSysLevelTable_old) == NULL)
			break;
		StorageTmp->isisSysLevelTEEnabled = StorageOld->isisSysLevelTEEnabled;
		if (--StorageTmp->isisSysLevelTable_rsvs == 0)
			isisSysLevelTable_destroy(&StorageTmp->isisSysLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircIfIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircIfIndex(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircIfIndex entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircIfIndex: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircIfIndex not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircIfIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..2147483647 */
		if ((1 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircIfIndex: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircIfIndex = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircIfIndex for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircIfIndex = StorageOld->isisCircIfIndex;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value off */
		switch (set_value) {
		case ISISCIRCADMINSTATE_ON:
		case ISISCIRCADMINSTATE_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircAdminState = StorageOld->isisCircAdminState;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISISCIRCTYPE_BROADCAST:
		case ISISCIRCTYPE_PTTOPT:
		case ISISCIRCTYPE_STATICIN:
		case ISISCIRCTYPE_STATICOUT:
		case ISISCIRCTYPE_DA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircType for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircType = StorageOld->isisCircType;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircExtDomain(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircExtDomain(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircExtDomain entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtDomain: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtDomain not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtDomain: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtDomain: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircExtDomain = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircExtDomain for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircExtDomain = StorageOld->isisCircExtDomain;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value level1and2 */
		switch (set_value) {
		case ISISCIRCLEVELTYPE_LEVEL1:
		case ISISCIRCLEVELTYPE_LEVEL2:
		case ISISCIRCLEVELTYPE_LEVEL1AND2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircLevelType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelType = StorageOld->isisCircLevelType;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircPassiveCircuit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircPassiveCircuit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircPassiveCircuit entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircPassiveCircuit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircPassiveCircuit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircPassiveCircuit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircPassiveCircuit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircPassiveCircuit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircPassiveCircuit for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircPassiveCircuit = StorageOld->isisCircPassiveCircuit;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircMeshGroupEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircMeshGroupEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircMeshGroupEnabled entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroupEnabled: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroupEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroupEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value inactive */
		switch (set_value) {
		case ISISCIRCMESHGROUPENABLED_INACTIVE:
		case ISISCIRCMESHGROUPENABLED_BLOCKED:
		case ISISCIRCMESHGROUPENABLED_SET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroupEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircMeshGroupEnabled = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircMeshGroupEnabled for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircMeshGroupEnabled = StorageOld->isisCircMeshGroupEnabled;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircMeshGroup(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircMeshGroup(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircMeshGroup entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroup: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroup not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircMeshGroup: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircMeshGroup = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircMeshGroup for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircMeshGroup = StorageOld->isisCircMeshGroup;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircSmallHellos(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircSmallHellos(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircSmallHellos entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircSmallHellos: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircSmallHellos not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircSmallHellos: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircSmallHellos: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircSmallHellos = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircSmallHellos for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircSmallHellos = StorageOld->isisCircSmallHellos;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCirc3WayEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCirc3WayEnabled(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCirc3WayEnabled entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCirc3WayEnabled: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCirc3WayEnabled not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCirc3WayEnabled: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCirc3WayEnabled: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCirc3WayEnabled = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCirc3WayEnabled for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCirc3WayEnabled = StorageOld->isisCirc3WayEnabled;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircExtendedCircID(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircExtendedCircID(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircExtendedCircID entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisCircExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtendedCircID: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtendedCircID not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExtendedCircID: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			if (StorageTmp->isisCircTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircTable_rsvs++;
		StorageTmp->isisCircExtendedCircID = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircTable_tsts == 0)
				if ((ret = check_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircExtendedCircID for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircTable_sets == 0)
				if ((ret = update_isisCircTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			StorageTmp->isisCircTable_rsvs = 0;
			StorageTmp->isisCircTable_tsts = 0;
			StorageTmp->isisCircTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircTable_sets == 0)
			revert_isisCircTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
			break;
		StorageTmp->isisCircExtendedCircID = StorageOld->isisCircExtendedCircID;
		if (--StorageTmp->isisCircTable_rsvs == 0)
			isisCircTable_destroy(&StorageTmp->isisCircTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelMetric for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelMetric = StorageOld->isisCircLevelMetric;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelWideMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelWideMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelWideMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelWideMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelWideMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelWideMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelWideMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelWideMetric for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelWideMetric = StorageOld->isisCircLevelWideMetric;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelISPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelISPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelISPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelISPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelISPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 64 */
		/* Note: ranges 0..127 */
		if ((0 > set_value || set_value > 127)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelISPriority: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelISPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelISPriority for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelISPriority = StorageOld->isisCircLevelISPriority;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelHelloMultiplier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelHelloMultiplier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelHelloMultiplier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloMultiplier not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloMultiplier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 2..100 */
		if ((2 > set_value || set_value > 100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloMultiplier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelHelloMultiplier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelHelloMultiplier for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelHelloMultiplier = StorageOld->isisCircLevelHelloMultiplier;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelHelloTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelHelloTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelHelloTimer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloTimer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 10..600000 */
		if ((10 > set_value || set_value > 600000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelHelloTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelHelloTimer = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelHelloTimer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelHelloTimer = StorageOld->isisCircLevelHelloTimer;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelDRHelloTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelDRHelloTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelDRHelloTimer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelDRHelloTimer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelDRHelloTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges 10..120000 */
		if ((10 > set_value || set_value > 120000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelDRHelloTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelDRHelloTimer = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelDRHelloTimer for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelDRHelloTimer = StorageOld->isisCircLevelDRHelloTimer;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelLSPThrottle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelLSPThrottle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelLSPThrottle entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelLSPThrottle not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelLSPThrottle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 30 */
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelLSPThrottle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelLSPThrottle = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelLSPThrottle for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelLSPThrottle = StorageOld->isisCircLevelLSPThrottle;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelMinLSPRetransInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelMinLSPRetransInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelMinLSPRetransInt entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMinLSPRetransInt not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMinLSPRetransInt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges 1..300 */
		if ((1 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelMinLSPRetransInt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelMinLSPRetransInt = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelMinLSPRetransInt for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelMinLSPRetransInt = StorageOld->isisCircLevelMinLSPRetransInt;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelCSNPInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelCSNPInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelCSNPInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelCSNPInterval not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelCSNPInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 1..600 */
		if ((1 > set_value || set_value > 600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelCSNPInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelCSNPInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelCSNPInterval for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelCSNPInterval = StorageOld->isisCircLevelCSNPInterval;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircLevelPartSNPInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisCircLevelPartSNPInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircLevelTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisCircLevelPartSNPInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisCircLevelTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelPartSNPInterval not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelPartSNPInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 1..120 */
		if ((1 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircLevelPartSNPInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			if (StorageTmp->isisCircLevelTable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisCircLevelTable_old = isisCircLevelTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisCircLevelTable_rsvs++;
		StorageTmp->isisCircLevelPartSNPInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisCircLevelTable_tsts == 0)
				if ((ret = check_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisCircLevelPartSNPInterval for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisCircLevelTable_sets == 0)
				if ((ret = update_isisCircLevelTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisCircLevelTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) != NULL) {
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
			StorageTmp->isisCircLevelTable_rsvs = 0;
			StorageTmp->isisCircLevelTable_tsts = 0;
			StorageTmp->isisCircLevelTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisCircLevelTable_sets == 0)
			revert_isisCircLevelTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisCircLevelTable_old) == NULL)
			break;
		StorageTmp->isisCircLevelPartSNPInterval = StorageOld->isisCircLevelPartSNPInterval;
		if (--StorageTmp->isisCircLevelTable_rsvs == 0)
			isisCircLevelTable_destroy(&StorageTmp->isisCircLevelTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value off */
		switch (set_value) {
		case ISISRAADMINSTATE_ON:
		case ISISRAADMINSTATE_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		StorageTmp->isisRAAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		StorageTmp->isisRAAdminState = StorageOld->isisRAAdminState;
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAAddrPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAAddrPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAAddrPrefix entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAddrPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAddrPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAAddrPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisRAAddrPrefix);
		StorageTmp->isisRAAddrPrefix = string;
		StorageTmp->isisRAAddrPrefixLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAAddrPrefix for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		if (StorageOld->isisRAAddrPrefix != NULL) {
			SNMP_FREE(StorageTmp->isisRAAddrPrefix);
			StorageTmp->isisRAAddrPrefix = StorageOld->isisRAAddrPrefix;
			StorageTmp->isisRAAddrPrefixLen = StorageOld->isisRAAddrPrefixLen;
			StorageOld->isisRAAddrPrefix = NULL;
			StorageOld->isisRAAddrPrefixLen = 0;
		}
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAMapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAMapType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAMapType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMapType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMapType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMapType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISISRAMAPTYPE_NONE:
		case ISISRAMAPTYPE_EXPLICIT:
		case ISISRAMAPTYPE_EXTRACTIDI:
		case ISISRAMAPTYPE_EXTRACTDSP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMapType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		StorageTmp->isisRAMapType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAMapType for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		StorageTmp->isisRAMapType = StorageOld->isisRAMapType;
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		StorageTmp->isisRAMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAMetric for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		StorageTmp->isisRAMetric = StorageOld->isisRAMetric;
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAMetricType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case ISISRAMETRICTYPE_INTERNAL:
		case ISISRAMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		StorageTmp->isisRAMetricType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAMetricType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		StorageTmp->isisRAMetricType = StorageOld->isisRAMetricType;
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRASNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRASNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRASNPAAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisRASNPAAddress);
		StorageTmp->isisRASNPAAddress = string;
		StorageTmp->isisRASNPAAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRASNPAAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		if (StorageOld->isisRASNPAAddress != NULL) {
			SNMP_FREE(StorageTmp->isisRASNPAAddress);
			StorageTmp->isisRASNPAAddress = StorageOld->isisRASNPAAddress;
			StorageTmp->isisRASNPAAddressLen = StorageOld->isisRASNPAAddressLen;
			StorageOld->isisRASNPAAddress = NULL;
			StorageOld->isisRASNPAAddressLen = 0;
		}
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRASNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRASNPAMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRASNPAMask entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAMask: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisRASNPAMask);
		StorageTmp->isisRASNPAMask = string;
		StorageTmp->isisRASNPAMaskLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRASNPAMask for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		if (StorageOld->isisRASNPAMask != NULL) {
			SNMP_FREE(StorageTmp->isisRASNPAMask);
			StorageTmp->isisRASNPAMask = StorageOld->isisRASNPAMask;
			StorageTmp->isisRASNPAMaskLen = StorageOld->isisRASNPAMaskLen;
			StorageOld->isisRASNPAMask = NULL;
			StorageOld->isisRASNPAMaskLen = 0;
		}
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRASNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRASNPAPrefix(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRASNPAPrefix entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAPrefix: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAPrefix not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRASNPAPrefix: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisRASNPAPrefix);
		StorageTmp->isisRASNPAPrefix = string;
		StorageTmp->isisRASNPAPrefixLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRASNPAPrefix for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		if (StorageOld->isisRASNPAPrefix != NULL) {
			SNMP_FREE(StorageTmp->isisRASNPAPrefix);
			StorageTmp->isisRASNPAPrefix = StorageOld->isisRASNPAPrefix;
			StorageTmp->isisRASNPAPrefixLen = StorageOld->isisRASNPAPrefixLen;
			StorageOld->isisRASNPAPrefix = NULL;
			StorageOld->isisRASNPAPrefixLen = 0;
		}
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisRAType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisRAType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value manual */
		switch (set_value) {
		case ISISRATYPE_MANUAL:
		case ISISRATYPE_AUTOMATIC:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			if (StorageTmp->isisRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisRATable_rsvs++;
		StorageTmp->isisRAType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisRATable_tsts == 0)
				if ((ret = check_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisRAType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisRATable_sets == 0)
				if ((ret = update_isisRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
			isisRATable_destroy(&StorageTmp->isisRATable_old);
			StorageTmp->isisRATable_rsvs = 0;
			StorageTmp->isisRATable_tsts = 0;
			StorageTmp->isisRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisRATable_sets == 0)
			revert_isisRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
			break;
		StorageTmp->isisRAType = StorageOld->isisRAType;
		if (--StorageTmp->isisRATable_rsvs == 0)
			isisRATable_destroy(&StorageTmp->isisRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRANextHopType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRANextHopType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRANextHopType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHopType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHopType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHopType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISISIPRANEXTHOPTYPE_UNKNOWN:
		case ISISIPRANEXTHOPTYPE_IPV4:
		case ISISIPRANEXTHOPTYPE_IPV6:
		case ISISIPRANEXTHOPTYPE_IPV4Z:
		case ISISIPRANEXTHOPTYPE_IPV6Z:
		case ISISIPRANEXTHOPTYPE_DNS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHopType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRANextHopType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRANextHopType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRANextHopType = StorageOld->isisIPRANextHopType;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRANextHop(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRANextHop(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRANextHop entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHop: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHop not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRANextHop: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisIPRANextHop);
		StorageTmp->isisIPRANextHop = string;
		StorageTmp->isisIPRANextHopLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRANextHop for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		if (StorageOld->isisIPRANextHop != NULL) {
			SNMP_FREE(StorageTmp->isisIPRANextHop);
			StorageTmp->isisIPRANextHop = StorageOld->isisIPRANextHop;
			StorageTmp->isisIPRANextHopLen = StorageOld->isisIPRANextHopLen;
			StorageOld->isisIPRANextHop = NULL;
			StorageOld->isisIPRANextHopLen = 0;
		}
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRAType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case ISISIPRATYPE_MANUAL:
		case ISISIPRATYPE_AUTOMATIC:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRAType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRAType for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRAType = StorageOld->isisIPRAType;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRAAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAAdminState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAAdminState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value off */
		switch (set_value) {
		case ISISIPRAADMINSTATE_ON:
		case ISISIPRAADMINSTATE_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRAAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRAAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRAAdminState = StorageOld->isisIPRAAdminState;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRAMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..63 */
		if ((0 > set_value || set_value > 63)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetric: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRAMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRAMetric for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRAMetric = StorageOld->isisIPRAMetric;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRAMetricType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAMetricType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetricType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetricType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetricType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internal */
		switch (set_value) {
		case ISISIPRAMETRICTYPE_INTERNAL:
		case ISISIPRAMETRICTYPE_EXTERNAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAMetricType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRAMetricType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRAMetricType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRAMetricType = StorageOld->isisIPRAMetricType;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAFullMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRAFullMetric(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAFullMetric entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAFullMetric: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAFullMetric not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAFullMetric: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		StorageTmp->isisIPRAFullMetric = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRAFullMetric for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		StorageTmp->isisIPRAFullMetric = StorageOld->isisIPRAFullMetric;
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRASNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_isisIPRASNPAAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 12;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisIPRASNPAAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->isisIPRAExistState) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRASNPAAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRASNPAAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..20 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 20))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRASNPAAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			if (StorageTmp->isisIPRATable_rsvs == 0)
				if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisIPRATable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisIPRASNPAAddress);
		StorageTmp->isisIPRASNPAAddress = string;
		StorageTmp->isisIPRASNPAAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->isisIPRATable_tsts == 0)
				if ((ret = check_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisIPRASNPAAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisIPRATable_sets == 0)
				if ((ret = update_isisIPRATable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisIPRATable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			StorageTmp->isisIPRATable_rsvs = 0;
			StorageTmp->isisIPRATable_tsts = 0;
			StorageTmp->isisIPRATable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisIPRATable_sets == 0)
			revert_isisIPRATable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
			break;
		if (StorageOld->isisIPRASNPAAddress != NULL) {
			SNMP_FREE(StorageTmp->isisIPRASNPAAddress);
			StorageTmp->isisIPRASNPAAddress = StorageOld->isisIPRASNPAAddress;
			StorageTmp->isisIPRASNPAAddressLen = StorageOld->isisIPRASNPAAddressLen;
			StorageOld->isisIPRASNPAAddress = NULL;
			StorageOld->isisIPRASNPAAddressLen = 0;
		}
		if (--StorageTmp->isisIPRATable_rsvs == 0)
			isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysLevelType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysLevelType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysLevelType entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value level1and2 */
		switch (set_value) {
		case ISISSYSLEVELTYPE_LEVEL1:
		case ISISSYSLEVELTYPE_LEVEL2:
		case ISISSYSLEVELTYPE_LEVEL1AND2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysLevelType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysLevelType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysLevelType for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysLevelType = StorageOld->isisSysLevelType;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysID(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysID(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysID entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysID not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 6..6 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 6)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysID: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->isisSysID);
		StorageTmp->isisSysID = string;
		StorageTmp->isisSysIDLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysID for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		if (StorageOld->isisSysID != NULL) {
			SNMP_FREE(StorageTmp->isisSysID);
			StorageTmp->isisSysID = StorageOld->isisSysID;
			StorageTmp->isisSysIDLen = StorageOld->isisSysIDLen;
			StorageOld->isisSysID = NULL;
			StorageOld->isisSysIDLen = 0;
		}
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysMaxPathSplits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysMaxPathSplits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysMaxPathSplits entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxPathSplits not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxPathSplits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 1..32 */
		if ((1 > set_value || set_value > 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxPathSplits: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysMaxPathSplits = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysMaxPathSplits for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysMaxPathSplits = StorageOld->isisSysMaxPathSplits;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysMaxLSPGenInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysMaxLSPGenInt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysMaxLSPGenInt entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxLSPGenInt not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxLSPGenInt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 900 */
		/* Note: ranges 1..65235 */
		if ((1 > set_value || set_value > 65235)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxLSPGenInt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysMaxLSPGenInt = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysMaxLSPGenInt for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysMaxLSPGenInt = StorageOld->isisSysMaxLSPGenInt;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysPollESHelloRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysPollESHelloRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysPollESHelloRate entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysPollESHelloRate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysPollESHelloRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysPollESHelloRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysPollESHelloRate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysPollESHelloRate for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysPollESHelloRate = StorageOld->isisSysPollESHelloRate;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysWaitTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysWaitTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysWaitTime entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysWaitTime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysWaitTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60 */
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysWaitTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysWaitTime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysWaitTime for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysWaitTime = StorageOld->isisSysWaitTime;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysAdminState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysAdminState entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysAdminState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysAdminState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value off */
		switch (set_value) {
		case ISISSYSADMINSTATE_ON:
		case ISISSYSADMINSTATE_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysAdminState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysAdminState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysAdminState for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysAdminState = StorageOld->isisSysAdminState;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysL2toL1Leaking(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysL2toL1Leaking(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysL2toL1Leaking entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysL2toL1Leaking not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysL2toL1Leaking: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysL2toL1Leaking: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysL2toL1Leaking = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysL2toL1Leaking for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysL2toL1Leaking = StorageOld->isisSysL2toL1Leaking;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysMaxAge(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysMaxAge(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysMaxAge entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxAge not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxAge: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 350..65535 */
		if ((350 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysMaxAge: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysMaxAge = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysMaxAge for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysMaxAge = StorageOld->isisSysMaxAge;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysReceiveLSPBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysReceiveLSPBufferSize(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysReceiveLSPBufferSize entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysReceiveLSPBufferSize not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysReceiveLSPBufferSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1492 */
		/* Note: ranges 1492..16000 */
		if ((1492 > set_value || set_value > 16000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysReceiveLSPBufferSize: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysReceiveLSPBufferSize = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysReceiveLSPBufferSize for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysReceiveLSPBufferSize = StorageOld->isisSysReceiveLSPBufferSize;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSysNotificationEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_isisSysNotificationEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("isisMIB", "write_isisSysNotificationEnable entering action=%d...  \n", action));
	if ((StorageTmp = isisMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysNotificationEnable not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysNotificationEnable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSysNotificationEnable: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			if (StorageTmp->isisMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->isisMIB_old = isisMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->isisMIB_rsvs++;
		StorageTmp->isisSysNotificationEnable = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->isisMIB_tsts == 0)
				if ((ret = check_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->isisSysNotificationEnable for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->isisMIB_sets == 0)
				if ((ret = update_isisMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->isisMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->isisMIB_old) != NULL) {
			isisMIB_destroy(&StorageTmp->isisMIB_old);
			StorageTmp->isisMIB_rsvs = 0;
			StorageTmp->isisMIB_tsts = 0;
			StorageTmp->isisMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->isisMIB_tsts == 0)
			revert_isisMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->isisMIB_old) == NULL)
			break;
		StorageTmp->isisSysNotificationEnable = StorageOld->isisSysNotificationEnable;
		if (--StorageTmp->isisMIB_rsvs == 0)
			isisMIB_destroy(&StorageTmp->isisMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisManAreaAddrTable_row(struct isisManAreaAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisSummAddrTable_row(struct isisSummAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisRedistributeAddrTable_row(struct isisRedistributeAddrTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisCircTable_row(struct isisCircTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisCircTable_row(struct isisCircTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisCircTable_row(struct isisCircTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisCircTable_row(struct isisCircTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisRATable_row(struct isisRATable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisRATable_row(struct isisRATable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisRATable_row(struct isisRATable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisRATable_row(struct isisRATable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_isisIPRATable_row(struct isisIPRATable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisManAreaAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisManAreaAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisManAreaAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisManAreaAddrTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisManAreaAddrExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisManAreaAddrTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisManAreaAddrExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisManAreaAddrExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisManAreaAddr */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisManAreaAddr */
			/* Note: ranges 0..20 */
			if (vp->val_len > SPRINT_MAX_LEN || ((0 > vp->val_len || vp->val_len > 20))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisManAreaAddr: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisManAreaAddrTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisManAreaAddrTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->isisManAreaAddr, vp->val.string, vp->val_len);
			StorageNew->isisManAreaAddrLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&isisManAreaAddrTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisManAreaAddrExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisManAreaAddrTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisManAreaAddrTable_old) == NULL)
				if (StorageTmp->isisManAreaAddrTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisManAreaAddrTable_old = isisManAreaAddrTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisManAreaAddrTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisManAreaAddrTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisManAreaAddrTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisManAreaAddrTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisManAreaAddrExistState != RS_ACTIVE)
				if ((ret = can_act_isisManAreaAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisManAreaAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisManAreaAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisManAreaAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisManAreaAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisManAreaAddrExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisManAreaAddrTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisManAreaAddrExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisManAreaAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisManAreaAddrExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisManAreaAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisManAreaAddrTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisManAreaAddrExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisManAreaAddrExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisManAreaAddrExistState = set_value;
			if ((StorageOld = StorageTmp->isisManAreaAddrTable_old) != NULL) {
				isisManAreaAddrTable_destroy(&StorageTmp->isisManAreaAddrTable_old);
				StorageTmp->isisManAreaAddrTable_rsvs = 0;
				StorageTmp->isisManAreaAddrTable_tsts = 0;
				StorageTmp->isisManAreaAddrTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisManAreaAddrTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisManAreaAddrTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisManAreaAddrExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisManAreaAddrTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisManAreaAddrExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisManAreaAddrTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisManAreaAddrTable_del(StorageNew);
				isisManAreaAddrTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisManAreaAddrTable_old) == NULL)
				break;
			if (--StorageTmp->isisManAreaAddrTable_rsvs == 0)
				isisManAreaAddrTable_destroy(&StorageTmp->isisManAreaAddrTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisManAreaAddrTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisSummAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisSummAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisSummAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisSummAddrTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisSummAddrExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisSummAddrTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisSummAddrExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisSummAddressType */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisSummAddress */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisSummAddrPrefixLen */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisSummAddressType */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSummAddressType: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case ISISSUMMADDRESSTYPE_UNKNOWN:
			case ISISSUMMADDRESSTYPE_IPV4:
			case ISISSUMMADDRESSTYPE_IPV6:
			case ISISSUMMADDRESSTYPE_IPV4Z:
			case ISISSUMMADDRESSTYPE_IPV6Z:
			case ISISSUMMADDRESSTYPE_DNS:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSummAddressType: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisSummAddress */
			/* Note: ranges 0..255 */
			if (vp->val_len > SPRINT_MAX_LEN || ((0 > vp->val_len || vp->val_len > 255))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSummAddress: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisSummAddrPrefixLen */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSummAddrPrefixLen: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..2040 */
			if ((0 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2040)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSummAddrPrefixLen: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisSummAddrTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisSummAddrTable_rsvs = 1;
			vp = vars;
			StorageNew->isisSummAddressType = (long) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->isisSummAddress, vp->val.string, vp->val_len);
			StorageNew->isisSummAddressLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->isisSummAddrPrefixLen = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isisSummAddrTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisSummAddrExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisSummAddrTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
				if (StorageTmp->isisSummAddrTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisSummAddrTable_old = isisSummAddrTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisSummAddrTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisSummAddrTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisSummAddrTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisSummAddrTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisSummAddrExistState != RS_ACTIVE)
				if ((ret = can_act_isisSummAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisSummAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisSummAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisSummAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisSummAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisSummAddrExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisSummAddrTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisSummAddrExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisSummAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisSummAddrExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisSummAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisSummAddrTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisSummAddrExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisSummAddrExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisSummAddrExistState = set_value;
			if ((StorageOld = StorageTmp->isisSummAddrTable_old) != NULL) {
				isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
				StorageTmp->isisSummAddrTable_rsvs = 0;
				StorageTmp->isisSummAddrTable_tsts = 0;
				StorageTmp->isisSummAddrTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisSummAddrTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisSummAddrTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisSummAddrExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisSummAddrTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisSummAddrExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisSummAddrTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisSummAddrTable_del(StorageNew);
				isisSummAddrTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisSummAddrTable_old) == NULL)
				break;
			if (--StorageTmp->isisSummAddrTable_rsvs == 0)
				isisSummAddrTable_destroy(&StorageTmp->isisSummAddrTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisSummAddrTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRedistributeAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisRedistributeAddrExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRedistributeAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisRedistributeAddrTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisRedistributeAddrExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisRedistributeAddrTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRedistributeAddrExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRedistributeAddrExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisRedistributeAddrType */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisRedistributeAddrAddress */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisRedistributeAddrPrefixLen */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisRedistributeAddrType */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRedistributeAddrType: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case ISISREDISTRIBUTEADDRTYPE_UNKNOWN:
			case ISISREDISTRIBUTEADDRTYPE_IPV4:
			case ISISREDISTRIBUTEADDRTYPE_IPV6:
			case ISISREDISTRIBUTEADDRTYPE_IPV4Z:
			case ISISREDISTRIBUTEADDRTYPE_IPV6Z:
			case ISISREDISTRIBUTEADDRTYPE_DNS:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRedistributeAddrType: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisRedistributeAddrAddress */
			/* Note: ranges 0..255 */
			if (vp->val_len > SPRINT_MAX_LEN || ((0 > vp->val_len || vp->val_len > 255))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRedistributeAddrAddress: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisRedistributeAddrPrefixLen */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRedistributeAddrPrefixLen: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..2040 */
			if ((0 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2040)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRedistributeAddrPrefixLen: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisRedistributeAddrTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisRedistributeAddrTable_rsvs = 1;
			vp = vars;
			StorageNew->isisRedistributeAddrType = (long) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->isisRedistributeAddrAddress, vp->val.string, vp->val_len);
			StorageNew->isisRedistributeAddrAddressLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->isisRedistributeAddrPrefixLen = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isisRedistributeAddrTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisRedistributeAddrExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisRedistributeAddrTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisRedistributeAddrTable_old) == NULL)
				if (StorageTmp->isisRedistributeAddrTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisRedistributeAddrTable_old = isisRedistributeAddrTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisRedistributeAddrTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisRedistributeAddrTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisRedistributeAddrTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisRedistributeAddrTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisRedistributeAddrExistState != RS_ACTIVE)
				if ((ret = can_act_isisRedistributeAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisRedistributeAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisRedistributeAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisRedistributeAddrExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisRedistributeAddrTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisRedistributeAddrExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must
		   be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisRedistributeAddrTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisRedistributeAddrExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisRedistributeAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisRedistributeAddrExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisRedistributeAddrTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisRedistributeAddrTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisRedistributeAddrExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisRedistributeAddrExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisRedistributeAddrExistState = set_value;
			if ((StorageOld = StorageTmp->isisRedistributeAddrTable_old) != NULL) {
				isisRedistributeAddrTable_destroy(&StorageTmp->isisRedistributeAddrTable_old);
				StorageTmp->isisRedistributeAddrTable_rsvs = 0;
				StorageTmp->isisRedistributeAddrTable_tsts = 0;
				StorageTmp->isisRedistributeAddrTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisRedistributeAddrTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisRedistributeAddrTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisRedistributeAddrExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisRedistributeAddrTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisRedistributeAddrExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisRedistributeAddrTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisRedistributeAddrTable_del(StorageNew);
				isisRedistributeAddrTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisRedistributeAddrTable_old) == NULL)
				break;
			if (--StorageTmp->isisRedistributeAddrTable_rsvs == 0)
				isisRedistributeAddrTable_destroy(&StorageTmp->isisRedistributeAddrTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisRedistributeAddrTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisCircExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisCircExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisCircTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisCircTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisCircExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisCircTableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisCircExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisCircIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisCircIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisCircIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisCircIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisCircTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisCircTable_rsvs = 1;
			vp = vars;
			StorageNew->isisCircIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isisCircTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisCircExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisCircTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
				if (StorageTmp->isisCircTable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisCircTable_old = isisCircTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisCircTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisCircTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisCircTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisCircTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisCircExistState != RS_ACTIVE)
				if ((ret = can_act_isisCircTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisCircExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisCircTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisCircExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisCircTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisCircExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisCircTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisCircExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisCircTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisCircExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisCircTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisCircTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisCircExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisCircExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisCircExistState = set_value;
			if ((StorageOld = StorageTmp->isisCircTable_old) != NULL) {
				isisCircTable_destroy(&StorageTmp->isisCircTable_old);
				StorageTmp->isisCircTable_rsvs = 0;
				StorageTmp->isisCircTable_tsts = 0;
				StorageTmp->isisCircTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisCircTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisCircTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisCircExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisCircTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisCircExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisCircTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisCircTable_del(StorageNew);
				isisCircTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisCircTable_old) == NULL)
				break;
			if (--StorageTmp->isisCircTable_rsvs == 0)
				isisCircTable_destroy(&StorageTmp->isisCircTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisCircTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisRAExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisRAExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisRATable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisRAExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisRAExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisCircIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisRAIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisCircIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisCircIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisCircIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisRAIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRAIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisRAIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisRATable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisRATable_rsvs = 1;
			vp = vars;
			StorageNew->isisCircIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isisRAIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isisRATableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisRAExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisRATable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
				if (StorageTmp->isisRATable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisRATable_old = isisRATable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisRATable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisRATable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisRATable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisRATable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisRAExistState != RS_ACTIVE)
				if ((ret = can_act_isisRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisRAExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisRAExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisRAExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisRATable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisRAExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisRATable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisRAExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisRATable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisRATable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisRAExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisRAExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisRAExistState = set_value;
			if ((StorageOld = StorageTmp->isisRATable_old) != NULL) {
				isisRATable_destroy(&StorageTmp->isisRATable_old);
				StorageTmp->isisRATable_rsvs = 0;
				StorageTmp->isisRATable_tsts = 0;
				StorageTmp->isisRATable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisRATable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisRATable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisRAExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisRATable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisRAExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisRATable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisRATable_del(StorageNew);
				isisRATable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisRATable_old) == NULL)
				break;
			if (--StorageTmp->isisRATable_rsvs == 0)
				isisRATable_destroy(&StorageTmp->isisRATable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisRATable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_isisIPRAExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_isisIPRAExistState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct isisIPRATable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct isisIPRATable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 12;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("isisMIB", "write_isisIPRAExistState entering action=%d...  \n", action));
	StorageTmp = header_complex(isisIPRATableStorage, NULL, &name[12], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAExistState not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to isisIPRAExistState: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* isisSysLevelIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisIPRADestType */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisIPRADest */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisIPRADestPrefixLen */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* isisIPRANextHopIndex */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[12]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* isisSysLevelIndex */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSysLevelIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case ISISSYSLEVELINDEX_AREA:
			case ISISSYSLEVELINDEX_DOMAIN:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisSysLevelIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisIPRADestType */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRADestType: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case ISISIPRADESTTYPE_UNKNOWN:
			case ISISIPRADESTTYPE_IPV4:
			case ISISIPRADESTTYPE_IPV6:
			case ISISIPRADESTTYPE_IPV4Z:
			case ISISIPRADESTTYPE_IPV6Z:
			case ISISIPRADESTTYPE_DNS:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRADestType: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisIPRADest */
			/* Note: ranges 0..255 */
			if (vp->val_len > SPRINT_MAX_LEN || ((0 > vp->val_len || vp->val_len > 255))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRADest: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisIPRADestPrefixLen */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRADestPrefixLen: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 0..2040 */
			if ((0 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 2040)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRADestPrefixLen: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* isisIPRANextHopIndex */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRANextHopIndex: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..-1 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > -1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index isisIPRANextHopIndex: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = isisIPRATable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->isisIPRATable_rsvs = 1;
			vp = vars;
			StorageNew->isisSysLevelIndex = (long) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isisIPRADestType = (long) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->isisIPRADest, vp->val.string, vp->val_len);
			StorageNew->isisIPRADestLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->isisIPRADestPrefixLen = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->isisIPRANextHopIndex = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&isisIPRATableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->isisIPRAExistState == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->isisIPRATable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
				if (StorageTmp->isisIPRATable_rsvs == 0)
					if ((StorageOld = StorageTmp->isisIPRATable_old = isisIPRATable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->isisIPRATable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->isisIPRATable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				isisIPRATable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_isisIPRATable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->isisIPRAExistState != RS_ACTIVE)
				if ((ret = can_act_isisIPRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->isisIPRAExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisIPRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->isisIPRAExistState != RS_NOTINSERVICE)
				if ((ret = can_deact_isisIPRATable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->isisIPRAExistState for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_isisIPRATable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->isisIPRAExistState != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_isisIPRATable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->isisIPRAExistState != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_isisIPRATable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_isisIPRATable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->isisIPRAExistState = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->isisIPRAExistState = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->isisIPRAExistState = set_value;
			if ((StorageOld = StorageTmp->isisIPRATable_old) != NULL) {
				isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
				StorageTmp->isisIPRATable_rsvs = 0;
				StorageTmp->isisIPRATable_tsts = 0;
				StorageTmp->isisIPRATable_sets = 0;
			}
			break;
		case RS_DESTROY:
			isisIPRATable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_isisIPRATable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->isisIPRAExistState == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_isisIPRATable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->isisIPRAExistState == RS_ACTIVE)
				/* activate with underlying device */
				activate_isisIPRATable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				isisIPRATable_del(StorageNew);
				isisIPRATable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->isisIPRATable_old) == NULL)
				break;
			if (--StorageTmp->isisIPRATable_rsvs == 0)
				isisIPRATable_destroy(&StorageTmp->isisIPRATable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				isisIPRATable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_isisDatabaseOverload_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisDatabaseOverload_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisDatabaseOverload_oid;
	trap.val_len = sizeof(isisDatabaseOverload_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisManualAddressDrops_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisManualAddressDrops_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisManualAddressDrops_oid;
	trap.val_len = sizeof(isisManualAddressDrops_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisCorruptedLSPDetected_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisCorruptedLSPDetected_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisCorruptedLSPDetected_oid;
	trap.val_len = sizeof(isisCorruptedLSPDetected_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisAttemptToExceedMaxSequence_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisAttemptToExceedMaxSequence_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisAttemptToExceedMaxSequence_oid;
	trap.val_len = sizeof(isisAttemptToExceedMaxSequence_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisIDLenMismatch_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisIDLenMismatch_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisIDLenMismatch_oid;
	trap.val_len = sizeof(isisIDLenMismatch_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisMaxAreaAddressesMismatch_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisMaxAreaAddressesMismatch_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisMaxAreaAddressesMismatch_oid;
	trap.val_len = sizeof(isisMaxAreaAddressesMismatch_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisOwnLSPPurge_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisOwnLSPPurge_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisOwnLSPPurge_oid;
	trap.val_len = sizeof(isisOwnLSPPurge_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisSequenceNumberSkip_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisSequenceNumberSkip_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisSequenceNumberSkip_oid;
	trap.val_len = sizeof(isisSequenceNumberSkip_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisAuthenticationTypeFailure_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisAuthenticationTypeFailure_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisAuthenticationTypeFailure_oid;
	trap.val_len = sizeof(isisAuthenticationTypeFailure_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisAuthenticationFailure_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisAuthenticationFailure_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisAuthenticationFailure_oid;
	trap.val_len = sizeof(isisAuthenticationFailure_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisVersionSkew_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisVersionSkew_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisVersionSkew_oid;
	trap.val_len = sizeof(isisVersionSkew_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisAreaMismatch_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisAreaMismatch_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisAreaMismatch_oid;
	trap.val_len = sizeof(isisAreaMismatch_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisRejectedAdjacency_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisRejectedAdjacency_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisRejectedAdjacency_oid;
	trap.val_len = sizeof(isisRejectedAdjacency_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisLSPTooLargeToPropagate_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisLSPTooLargeToPropagate_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisLSPTooLargeToPropagate_oid;
	trap.val_len = sizeof(isisLSPTooLargeToPropagate_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisOrigLSPBuffSizeMismatch_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisOrigLSPBuffSizeMismatch_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisOrigLSPBuffSizeMismatch_oid;
	trap.val_len = sizeof(isisOrigLSPBuffSizeMismatch_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisProtocolsSupportedMismatch_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisProtocolsSupportedMismatch_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisProtocolsSupportedMismatch_oid;
	trap.val_len = sizeof(isisProtocolsSupportedMismatch_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisAdjacencyChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisAdjacencyChange_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisAdjacencyChange_oid;
	trap.val_len = sizeof(isisAdjacencyChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

void
send_isisLSPErrorDetected_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("isisMIB", "send_isisLSPErrorDetected_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = isisLSPErrorDetected_oid;
	trap.val_len = sizeof(isisLSPErrorDetected_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/**
 * @fn void isisMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
isisMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("isisMIB", "isisMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (isisMIBold_signal_handler != NULL)
		(*isisMIBold_signal_handler) (sig);
	DEBUGMSGTL(("isisMIB", "done.\n"));
}

/**
 * @fn void isisMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
isisMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("isisMIB", "isisMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("isisMIB", "done.\n"));
	return;
}
