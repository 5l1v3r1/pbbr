# mib2c.storage.conf:
#
#  This is a special mib2c.conf file that assumes that you want to do
#  all storage of information locally rather than pulling the
#  information from another source outside the agent (EG, the
#  kernel).  To accomplish this, it defines a structure for the
#  storage of tables and assumes you want to use the header_complex
#  functions for retrieving and storing that data in a local data
#  store.  It even writes a .conf file parser for you and sets you up
#  for being able to do persistant storage fairly simply.
#
#  In short:  it trys to do almost all of the work for you...  Almost...

#
# Define types of data by mib type, and translate into needed C code.
#

# We need to get some extra stuff into the variable declarations
# before sourcing the main mib2c.vartypes.conf file below.
type:		OCTETSTR
storage:	uint8_t *${name}; /* $mib->{access} */
storage:	size_t ${name}Len;
tmpsize:	StorageTmp->${name}Len
varlencheck:	var_val_len > SPRINT_MAX_LEN
varptrcheck:	vp->val_len > SPRINT_MAX_LEN
prefree:	SNMP_FREE(StorageTmp->${name});
vartest:	if (StorageTmp->${name} == NULL) {
vartest:		config_perror(\"invalid specification for ${name}\");
vartest:		return;
vartest:	}
vartest:	
reserve1:	if ((string = malloc(var_val_len + 1)) == NULL)
reserve1:		return SNMP_ERR_RESOURCEUNAVAILABLE;
reserve1:	memcpy((void *)string, (void *)var_val, var_val_len);
reserve1:	string[var_val_len] = 0;
reserve1:	SNMP_FREE(StorageTmp->${name});
reserve1:	StorageTmp->${name} = string;
reserve1:	StorageTmp->${name}Len = var_val_len;
free:		if (StorageOld->${name} != NULL) {
free:			SNMP_FREE(StorageTmp->${name});
free:			StorageTmp->${name} = StorageOld->${name};
free:			StorageTmp->${name}Len = StorageOld->${name}Len;
free:			StorageOld->${name} = NULL;
free:			StorageOld->${name}Len = 0;
free:		}
deletevar:	SNMP_FREE(StorageDel->${name});
deletevar:	StorageDel->${name}Len = 0;
sizeofstart:	
sizeofend:	Len
tmpvar:		uint8_t *
varname:	string
varlistname:	string
#varinit:	static size_t old_length = 0;
#varinit:	static uint8_t *string = NULL;
varinit:	uint8_t *string = NULL;
casttmp:	strdup((uint8_t *) old_value);
action2:	memdup((void *) &StorageNew->$name, vp->val.string, vp->val_len);
action2:	StorageNew->${name}Len = vp->val_len;
action3:	StorageNew->${name} = strdup(\"$mib->{defaultValue}\");
action3:	StorageNew->${name}Len = strlen(\"$mib->{defaultValue}\");\n
action4:	if (!(StorageNew->${name} = malloc(thedata->${name}Len + 1)))
action4:		goto destroy;
action4:	memcpy(StorageNew->${name}, thedata->${name}, thedata->${name}Len);
action4:	StorageNew->${name}Len = thedata->${name}Len;
action4:	StorageNew->${name}[StorageNew->${name}Len] = 0;
#
type:		INTEGER
storage:	long $name; /* $mib->{access} */
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(int32_t)
varptrcheck:	vp->val_len > sizeof(int32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		long
varname:	set_value
varlistname:	integer
varlistval:	(long) *vp->val.integer
varinit:	long set_value = *((long *) var_val);
reserve1:	StorageTmp->${name} = set_value;
free:		StorageTmp->${name} = StorageOld->${name};
casttmp:	old_value;
action2:	StorageNew->$name = (long) *vp->val.integer;
action3:	StorageNew->${name} = $mib->{defaultValue};\n
action4:	StorageNew->${name} = thedata->${name};
#
type:		UNSIGNED32
storage:	ulong $name; /* $mib->{access} */
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(uint32_t)
varptrcheck:	vp->val_len > sizeof(uint32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		ulong
varname:	set_value
varlistname:	integer
varlistval:	(ulong) *vp->val.integer
varinit:	ulong set_value = *((ulong *) var_val);
reserve1:	StorageTmp->${name} = set_value;
free:		StorageTmp->${name} = StorageOld->${name};
casttmp:	old_value;
action2:	StorageNew->$name = (ulong) *vp->val.integer;
action3:	StorageNew->${name} = $mib->{defaultValue};\n
action4:	StorageNew->${name} = thedata->${name};
#
type:		OBJECTID
storage:	oid *$name; /* $mib->{access} */
storage:	size_t ${name}Len;
tmpsize:	StorageTmp->${name}Len
varsize:	* sizeof(oid)
varlencheck:	MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)
varptrcheck:	MIN_OID_LEN * sizeof(oid) > vp->val_len || vp->val_len > MAX_OID_LEN * sizeof(oid)
prefree:	SNMP_FREE(StorageTmp->${name});
vartest:	if (StorageTmp->${name} == NULL) {
vartest:		config_perror(\"invalid specification for ${name}\");
vartest:		return;
vartest:	}
vartest:	
reserve1:	if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
reserve1:		return SNMP_ERR_RESOURCEUNAVAILABLE;
reserve1:	SNMP_FREE(StorageTmp->${name});
reserve1:	StorageTmp->${name} = objid;
reserve1:	StorageTmp->${name}Len = var_val_len/sizeof(oid);
free:		if (StorageOld->${name} != NULL) {
free:			SNMP_FREE(StorageTmp->${name});
free:			StorageTmp->${name} = StorageOld->${name};
free:			StorageTmp->${name}Len = StorageOld->${name}Len;
free:			StorageOld->${name} = NULL;
free:			StorageOld->${name}Len = 0;
free:		}
deletevar:	SNMP_FREE(StorageDel->${name});
deletevar:	StorageDel->${name}Len = 0;
sizeofstart:	
sizeofend:	Len * sizeof(oid)
tmpvar:		oid *
varname:	objid
varlistname:	objid
#varinit:	static size_t old_length = 0;
#varinit:	static oid *objid = NULL;
varinit:	oid *objid = NULL;
casttmp:	(oid *) old_value;
freetmp:	SNMP_FREE(old_value);
action2:	memdup((void *) &StorageNew->$name, (uint8_t *)vp->val.objid, vp->val_len);
action2:	StorageNew->${name}Len = vp->val_len;
action3:	 /* StorageNew->${name} = $mib->{defaultValue}; */\n
action4:	if (!(StorageNew->${name} = snmp_duplicate_objid(thedata->${name}, thedata->${name}Len / sizeof(oid))))
action4:		goto destroy;
action4:	StorageNew->${name}Len = thedata->${name}Len;
#
type:		COUNTER64
storage:	struct counter64 $name; /* $mib->{access} */
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(uint64_t)
varptrcheck:	vp->val_len > sizeof(uint64_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		struct counter64
varname:	c64
varlistname:	counter64
varinit:	struct counter64 c64 = *((struct counter64 *) var_val);
reserve1:	StorageTmp->${name} = c64;
free:		StorageTmp->${name} = StorageOld->${name};
casttmp:	old_value;
action2:	StorageNew->$name = *vp->val.counter64;
action3:	StorageNew->${name} = 0;\n
action4:	StorageNew->${name} = thedata->${name};

############################################################################
# source variable typing information:
include: mib2c.vartypes.conf

# Begin code template section
############################################################################
# variable statemnts used in a couple of places below
############################################################################
type:	code-varInits
code:	 /* variables we may use later */
code:	static long long_ret;
code:	static ulong ulong_ret;
code:	static uint8_t string[SPRINT_MAX_LEN];
code:	static oid objid[MAX_OID_LEN];
code:	static struct counter64 c64;

#
# Table refresh variable declarations.
#
type:		code-refresh-decl
processtable:	code-refresh-decl
code:	volatile int ${vtable}_refresh = 1;
#
# Structure definition line.
#
type:		code-structure-mib
process:	code-structure-mib
skipif:		$vroutine ne $mibName || $mib->{access} =~ /NoAccess|Notify/
code:	" . eval ("\"$variables{$mib->{type}}{storage}\"") . "

#
# Structure definition, one per table
#
type:		code-structure-per-table
processtable:	code-structure-per-table
code:	struct ${vtable}_data { struct ${vtable}_data *${vtable}_old; uint ${vtable}_rsvs; uint ${vtable}_tsts; uint ${vtable}_sets; uint ${vtable}_request; uint ${vtable}_refs; uint ${vtable}_id; $variables{$vtable}{'code-structure'}{processed} };

#
# Structure storage arrays, one per table
#
type:		code-structure-storage
processtable:	code-structure-storage
code:	struct header_complex_index *${vtable}Storage = NULL;

#
# Strucutre storage declarations, one per table
#
type:		code-structure-storage-declaration
processtable:	code-structure-storage-declaration
code:	extern struct header_complex_index *${vtable}Storage;

#
# Structure definition line.
#
type:		code-structure
process:	code-structure
code:	" . eval ("\"$variables{$mib->{type}}{storage}\"") . "
#
# ENUM definitions
#
type:		code-enums
process:	code-enums
skipif:		$mib->{textualConvention} eq "RowStatus" || $mib->{textualConvention} eq "StorageType"
code:	" . eval{ my ($i, $x); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { $x .= sprintf("#define %-40s %d\n","${NAME}_" . uc($i),$mib->{enums}{$i}); } $x =~ s/-/_/g; $x; } . "\n
#
# OID definitions
#
type:		code-declarations-oids
processoid:	code-declarations-oids
skipif:		$name eq $mibName || $mib->{type} eq "NOTIF"
code:	extern oid ${name}_oid[" . ($variables{$name}{oidlen}) . "];
#
# OID definitions
#
type:		code-declarations-notifications
processoid:	code-declarations-notifications
skipif:		$mib->{type} ne "NOTIF"
code:	extern oid ${name}_oid[" . ($variables{$name}{oidlen}) . "];
#
type:		code-trap-declarations
processoid:	code-trap-declarations
skipif:		$mib->{type} ne "NOTIF"
code:	extern void send_${name}_v2trap(struct variable_list *);
#
# OID definitions
#
type:		code-declarations-parameters
process:	code-declarations-parameters
skipif:		$vroutine ne $mibName || $mib->{access} ne "Notify" || $variables{$vroutine}{$i}{isanindex} == 1
code:	extern oid ${name}_oid[" . ($variables{$name}{oidlen}) . "];

############################################################################
# The .c file, top
############################################################################
type:	code-main-part
code:	/*****************************************************************************
code:	
code:	 \@(#) src/snmp/${outputbase}.c
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
code:	 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
code:	 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock\@openss7.org>
code:	
code:	 All Rights Reserved.
code:	
code:	 This program is free software: you can redistribute it and/or modify it under
code:	 the terms of the GNU Affero General Public License as published by the Free
code:	 Software Foundation, version 3 of the license.
code:	
code:	 This program is distributed in the hope that it will be useful, but WITHOUT
code:	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
code:	 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
code:	 details.
code:	
code:	 You should have received a copy of the GNU Affero General Public License
code:	 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
code:	 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
code:	 02139, USA.
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
code:	 behalf of the U.S. Government (\"Government\"), the following provisions apply
code:	 to you.  If the Software is supplied by the Department of Defense (\"DoD\"), it
code:	 is classified as \"Commercial Computer Software\" under paragraph 252.227-7014
code:	 of the DoD Supplement to the Federal Acquisition Regulations (\"DFARS\") (or any
code:	 successor regulations) and the Government is acquiring only the license rights
code:	 granted herein (the license rights customarily provided to non-Government
code:	 users).  If the Software is supplied to any unit or agency of the Government
code:	 other than DoD, it is classified as \"Restricted Computer Software\" and the
code:	 Government's rights in the Software are defined in paragraph 52.227-19 of the
code:	 Federal Acquisition Regulations (\"FAR\") (or any successor regulations) or, in
code:	 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
code:	 (or any successor regulations).
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Commercial licensing and support of this software is available from OpenSS7
code:	 Corporation at a fee.  See http://www.openss7.com/
code:	
code:	 *****************************************************************************/
code:	
code:	static char const ident[] = \"src/snmp/${outputbase}.c (\" PACKAGE_ENVR \") \" PACKAGE_DATE;
code:	
code:	/* This file was generated by mib2c and is intended for use as
code:	   a mib module for the ucd-snmp snmpd agent. */
code:	#include <ucd-snmp/ucd-snmp-config.h>
code:	#include <ucd-snmp/ucd-snmp-includes.h>
code:	#include <ucd-snmp/ucd-snmp-agent-includes.h>
code:	#include <ucd-snmp/agent_trap.h>
code:	#include <ucd-snmp/callback.h>
code:	#include <ucd-snmp/snmp-tc.h>
code:	#include <ucd-snmp/default_store.h>
code:	#include <ucd-snmp/snmp_alarm.h>
code:	/* The following header files are mangled in most recent net-snmp releases so
code:	 * the versions from UCD-SNMP 4.2.5 are included here.  */
code:	#if defined HAVE_LIBNETSNMP
code:	#else  /* defined HAVE_LIBNETSNMP */
code:	#endif /* defined HAVE_LIBNETSNMP */
code:	/* These are messed up on both. */
code:	#include \"ds_agent.h\"
code:	#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
code:	#include <ucd-snmp/util_funcs.h>
code:	/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
code:	int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
code:	#else  /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#include \"util_funcs.h\"
code:	#endif /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
code:	#include <ucd-snmp/header_complex.h>
code:	#else  /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	#include \"header_complex.h\"
code:	#endif /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	/* This one is the other way around: it is just fine for net-snmp, but
code:	 * ucd-snmp does not provide the header file at all.  */
code:	#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
code:	#include <ucd-snmp/mib_modules.h>
code:	#else  /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
code:	#include <net-snmp/agent/mib_modules.h>
code:	#else  /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#include \"mib_modules.h\"
code:	#endif /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#endif /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#include <stdint.h>
code:	#include <signal.h>
code:	#include <sys/stat.h>		/* for struct stat, fstat() */
code:	#include <sys/types.h>
code:	#include <unistd.h>
code:	#include <stdlib.h>
code:	#include <pwd.h>		/* for getpwuid() getpwnam() */
code:	#include <grp.h>		/* for getgrgid() getgrnam() */
code:	#include <libgen.h>		/* for basename() */
code:	#include <fcntl.h>		/* for O_CREAT */
code:	#include <sys/sysctl.h>		/* for sysctl */
code:	#include <errno.h>
code:	#include <string.h>
code:	#ifdef _GNU_SOURCE
code:	#include <getopt.h>
code:	#endif
code:	#include \"$mibName.h\"
code:	#define MASTER 1
code:	#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
code:	#if defined MODULE
code:	#if defined MASTER
code:	const char sa_program[] = \"$mibName\";
code:	int sa_fclose = 1;			/* default close files between requests */
code:	int sa_changed = 1;			/* indication to reread MIB configuration */
code:	int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
code:	int sa_request = 1;			/* request number for per-request actions */
code:	int sa_dump = 0;			/* default packet dump */
code:	int sa_debug = 0;			/* default no debug */
code:	#endif /* defined MASTER */
code:	#endif /* defined MODULE */
code:	static int my_fd = -1;			/* file descriptor for this MIB's use */
code:	static int my_readfd = -1;		/* file descriptor for autonomnous events */
code:	volatile int ${mibName}_refresh = 1;
code:	$variables{'code-refresh-decl'}{processed}
code:	/*
code:	 * ${mibName}_variables_oid: object identifier for $mibName
code:	 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
code:	 * suffix appearing in the variable below.
code:	 */
code:	oid ${mibName}_variables_oid[$variables{$mibName}{oidlen}] = { $commaoid };
code:	$variables{'code-write-rowstatus-oid'}{processed}
code:	/*
code:	 * Oids for use in notifications defined in this MIB.
code:	 */
code:	$variables{'code-definitions-notifications'}{processed}
code:	/*
code:	 * Oids accessible only for notify defined in this MIB.
code:	 */
code:	$variables{'code-definitions-parameters'}{processed}
code:	/*
code:	 * Other oids defined in this MIB.
code:	 */
code:	$variables{'code-definitions-oids'}{processed}
code:	static oid zeroDotZero_oid[2] = { 0, 0 };
code:	static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
code:	/*
code:	 * variable$varlen ${mibName}_variables: tree for $mibName
code:	 * This variable defines function callbacks and type return information for the $mibName mib section
code:	 */
code:	struct variable$varlen ${mibName}_variables[] = {
code:		 /* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
code:		$variables{'variable-structure-info'}{processed}
code:	};
code:	/* (L = length of the oidsuffix) */
code:	struct ${mibName}_data *${mibName}Storage = NULL;
code:	/* global storage of our data, saved in and configured by header_complex() */
code:	$variables{'code-structure-storage'}{processed}
code:	void (*${mibName}old_signal_handler)(int) = NULL; /* save old signal handler just in case */
code:	void ${mibName}_loop_handler(int);
code:	void ${mibName}_fd_handler(int, void *);
code:	/**
code:	 * \@fn void init_$mibName(void)
code:	 * \@brief $mibName initialization routine.
code:	 *
code:	 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
code:	 * structure (${mibName}_variables) should take place here.  By default the function also
code:	 * registers the configuration handler and configuration store callbacks.
code:	 *
code:	 * Additional registrations that may be considered here are calls to regsiter_readfd(),
code:	 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
code:	 * used as a loadable module.  By default this function establishes a single file descriptor to
code:	 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
code:	 * extneral file descriptors, so these should be used sparingly.
code:	 *
code:	 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
code:	 * the current request number can be deteremined.  This is accomplished by using a trick of the
code:	 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
code:	 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
code:	 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
code:	 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
code:	 * file descriptors).
code:	 */
code:	void
code:	init_$mibName(void)
code:	{
code:		(void) my_fd;
code:		(void) zeroDotZero_oid;
code:		(void) snmpTrapOID_oid;
code:		DEBUGMSGTL((\"$mibName\", \"init_$mibName: initializing...  \"));
code:		 /* register ourselves with the agent to handle our mib tree */
code:		REGISTER_MIB(\"$mibName\", ${mibName}_variables, variable$varlen, ${mibName}_variables_oid);
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_$mibName, NULL);
code:		 /* register our config handler(s) to deal with registrations */
code:		snmpd_register_config_handler(\"$mibName\", parse_$mibName, NULL, \"HELP STRING\"); $variables{'code-parser-registration'}{processed}
code:		 /* we need to be called back later to store our data */
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_$mibName, NULL); $variables{'code-store-registration'}{processed}
code:		 /* place any other initialization junk you need here */
code:		if (my_readfd >= 0) {
code:			register_readfd(my_readfd, ${mibName}_fd_handler, (void *)0);
code:			register_exceptfd(my_readfd, ${mibName}_fd_handler, (void *)1);
code:		}
code:		${mibName}old_signal_handler = external_signal_handler[SIGCHLD];
code:		external_signal_handler[SIGCHLD] = &${mibName}_loop_handler;
code:		external_signal_scheduled[SIGCHLD] = 1;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/**
code:	 * \@fn void deinit_$mibName(void)
code:	 * \@brief deinitialization routine.
code:	 *
code:	 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
code:	 * structure (${mibName}_variables) should take place here.  By default, the function also
code:	 * deregisters the the configuration file handlers for the MIB variables and table rows.
code:	 *
code:	 * Additional deregistrations that may be required here are calls to unregister_readfd(),
code:	 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
code:	 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
code:	 */
code:	void
code:	deinit_$mibName(void)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"deinit_$mibName: deinitializating...  \"));
code:		external_signal_handler[SIGCHLD] = ${mibName}old_signal_handler;
code:		if (my_readfd >= 0) {
code:			unregister_exceptfd(my_readfd);
code:			unregister_readfd(my_readfd);
code:			close(my_readfd);
code:			my_readfd = -1;
code:		}
code:		unregister_mib(${mibName}_variables_oid, sizeof(${mibName}_variables_oid)/sizeof(oid));
code:		snmpd_unregister_config_handler(\"$mibName\"); $variables{'code-parser-deregistration'}{processed}
code:		 /* place any other de-initialization junk you need here */
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	int
code:	term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"term_$mibName: terminating...  \"));
code:		deinit_$mibName();
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return 0;
code:	}
code:	/**
code:	 * \@fn struct ${mibName}_data *${mibName}_create(void)
code:	 * \@brief create a fresh data structure representing scalars in ${mibName}.
code:	 *
code:	 * Creates a new ${mibName}_data structure by allocating dynamic memory for the structure and
code:	 * initializing the default values of scalars in ${mibName}.
code:	 */
code:	struct ${mibName}_data *
code:	${mibName}_create(void)
code:	{
code:		struct ${mibName}_data *StorageNew = SNMP_MALLOC_STRUCT(${mibName}_data);
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_create: creating scalars...  \"));
code:		if (StorageNew != NULL) {
code:			 /* XXX: fill in default scalar values here into StorageNew */
code:			$variables{$mibName}{'code-default-scalars'}{processed}
code:		}
code:		done:
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return (StorageNew);
code:		goto nomem;
code:		nomem:
code:		${mibName}_destroy(&StorageNew);
code:		goto done;
code:	}
code:	/**
code:	 * \@fn struct ${mibName}_data *${mibName}_duplicate(struct ${mibName}_data *thedata)
code:	 * \@param thedata the mib structure to duplicate
code:	 * \@brief duplicate a mib structure for the mib
code:	 *
code:	 * Duplicates the specified mib structure \@param thedata and returns a pointer to the newly
code:	 * allocated mib structure on success, or NULL on failure.
code:	 */
code:	struct ${mibName}_data *
code:	${mibName}_duplicate(struct ${mibName}_data *thedata)
code:	{
code:		struct ${mibName}_data *StorageNew = SNMP_MALLOC_STRUCT(${mibName}_data);
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_duplicate: duplicating mib... \"));
code:		if (StorageNew != NULL) { $variables{$mibName}{'code-duplicate-scalars'}{processed}
code:		}
code:		done:
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return (StorageNew);
code:		goto destroy;
code:		destroy:
code:		${mibName}_destroy(&StorageNew);
code:		goto done;
code:	}
code:	/**
code:	 * \@fn int ${mibName}_destroy(struct ${mibName}_data **thedata)
code:	 * \@param thedata pointer to the data structure in ${mibName}.
code:	 * \@brief delete a scalars structure from $mibName.
code:	 *
code:	 * Frees scalars that were previously removed from $mibName.  Note that the strings associated
code:	 * with octet strings, object identifiers and bit strings still attached to the structure will also
code:	 * be freed.  The pointer that was passed in \@param thedata will be set to NULL if it is not already
code:	 * NULL.
code:	 */
code:	int
code:	${mibName}_destroy(struct ${mibName}_data **thedata)
code:	{
code:		struct ${mibName}_data *StorageDel;
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_destroy: deleting scalars...  \"));
code:		if ((StorageDel = *thedata) != NULL) { $variables{$mibName}{'code-delete-scalars'}{processed}
code:			SNMP_FREE(StorageDel);
code:			*thedata = StorageDel;
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${mibName}_add(struct ${mibName}_data *thedata)
code:	 * \@param thedata the structure representing $mibName scalars.
code:	 * \@brief adds node to the ${mibName} scalar data set.
code:	 *
code:	 * Adds a scalar structure to the ${mibName} data set.  Note that this function is necessary even
code:	 * when the scalar values are not peristent.
code:	 */
code:	int
code:	${mibName}_add(struct ${mibName}_data *thedata)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_add: adding data...  \"));
code:		if (thedata)
code:			${mibName}Storage = thedata;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn void parse_$mibName(const char *token, char *line)
code:	 * \@param token token used within the configuration file.
code:	 * \@param line line from configuration file matching the token.
code:	 * \@brief parse configuration file for $mibName entries.
code:	 *
code:	 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
code:	 * file line for the registsred token (in this case ${mibName}).  This routine is invoked by
code:	 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
code:	 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
code:	 * in the configuration MIB, this function will simply not be called.
code:	 */
code:	void
code:	parse_${mibName}(const char *token, char *line)
code:	{
code:		size_t tmpsize;
code:		struct ${mibName}_data *StorageTmp = ${mibName}_create();
code:		DEBUGMSGTL((\"$mibName\", \"parse_$mibName: parsing config...  \"));
code:		if (StorageTmp == NULL) {
code:			config_perror(\"malloc failure\");
code:			return;
code:		}
code:		 /* XXX: remove individual scalars that are not persistent */
code:		$variables{'code-config-scalar'}{processed} ${mibName}_add(StorageTmp);
code:		(void) tmpsize;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_${mibName}(): stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		char line[SNMP_MAXBUF];
code:		char *cptr;
code:		size_t tmpsize;
code:		struct ${mibName}_data *StorageTmp;
code:		DEBUGMSGTL((\"$mibName\", \"store_$mibName: storing data...  \"));
code:		refresh_${mibName}(1);
code:		if ((StorageTmp = ${mibName}Storage) == NULL) {
code:			DEBUGMSGTL((\"$mibName\", \"error.\\n\"));
code:			return SNMPERR_GENERR;
code:		}
code:		(void) tmpsize;
code:		 /* XXX: comment entire section if no scalars are persistent */
code:		{
code:			memset(line,0,sizeof(line));
code:			strcat(line, \"$mibName \");
code:			cptr = line + strlen(line);
code:			(void) cptr;
code:			 /* XXX: remove individual scalars that are not persistent */
code:			$variables{$mibName}{'code-persistent-scalars'}{processed} snmpd_store_config(line);
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int check_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated
code:	 * \@param StorageOld the data previous to update
code:	 *
code:	 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
code:	 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
code:	 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
code:	 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
code:	 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
code:	 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
code:	 * made for setting values that were not in the varbinds.
code:	 */
code:	int
code:	check_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to check the scalars for consistency */
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn int update_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated.
code:	 * \@param StorageOld the data previous to update.
code:	 * \@brief perform the set operation (ACTION phase)
code:	 *
code:	 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
code:	 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
code:	 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
code:	 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
code:	 * consistency already checked (see check_${mibName}()).  This function can
code:	 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
code:	 * varbinds on the mib were applied: the values in StorageTmp are the new values.
code:	 */
code:	int
code:	update_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to update the row with the underlying device */
code:		${mibName}_refresh = 1;
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn revert_${mibName}(struct 
code:	 * \@fn void revert_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated.
code:	 * \@param StorageOld the data previous to update.
code:	 * \@brief perform the undo operation (UNDO phase)
code:	 */
code:	void
code:	revert_${mibName}(struct ${mibName}_data *StorageTmp, struct ${mibName}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to revert the row with the underlying device */
code:		update_${mibName}(StorageOld, NULL);
code:	}
code:	/**
code:	 * \@fn void refresh_$mibName(int force)
code:	 * \@param force forced refresh when non-zero.
code:	 * \@brief refresh the scalar values of $mibName.
code:	 *
code:	 * Normally the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
code:	 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
code:	 * time, or after a SIGPOLL has been received (and a scalar has been requested).
code:	 */
code:	void
code:	refresh_$mibName(int force)
code:	{
code:		if (${mibName}Storage == NULL) {
code:			struct ${mibName}_data *StorageNew;
code:			if ((StorageNew = ${mibName}_create()) == NULL)
code:				return;
code:			${mibName}Storage = StorageNew;
code:			${mibName}_refresh = 1;
code:		}
code:		if (!force && ${mibName}_refresh == 0)
code:			return;
code:		DEBUGMSGTL((\"$mibName\", \"refresh_$mibName: refreshing...  \"));
code:		 /* XXX: Update scalars as required here... */
code:		${mibName}_refresh = 0;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/**
code:	 * \@fn u_char * var_$mibName(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	 * \@param vp a pointer to the entry in the variables table for the requested variable.
code:	 * \@param name the object identifier for which to find.
code:	 * \@param length the length of the object identifier.
code:	 * \@param exact whether the name is exact.
code:	 * \@param var_len a pointer to the length of the representation of the object.
code:	 * \@param write_method a pointer to a write method for the object.
code:	 * \@brief locate variables in $mibName.
code:	 *
code:	 * This function returns a pointer to a memory area that is static across the request that contains
code:	 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
code:	 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
code:	 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
code:	 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
code:	 * writing.  Write-only objects can be effected in this way.
code:	 */
code:	u_char *
code:	var_$mibName(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:		struct ${mibName}_data *StorageTmp;
code:		u_char *rval;
code:		DEBUGMSGTL((\"$mibName\", \"var_$mibName: lookup up varbind...  \"));
code:		if (header_generic(vp,name,length,exact,var_len,write_method) == MATCH_FAILED)
code:			return NULL;
code:		 /* Refresh the MIB values if required. */
code:		refresh_$mibName(0);
code:		if ((StorageTmp = ${mibName}Storage) == NULL) {
code:			DEBUGMSGTL((\"$mibName\", \"no datastructure.\\n\"));
code:			return NULL;
code:		}
code:		*write_method = NULL;
code:		*var_len = 0;
code:		rval = NULL;
code:		 /* This is where we do the value assignments for the mib results. */
code:		switch(vp->magic) { $variables{$mibName}{'code-case-statements'}{processed}
code:		default:
code:			ERROR_MSG(\"\");
code:		}
code:		if (rval)
code:			DEBUGMSGTL((\"$mibName\", \"found.\\n\"));
code:		else
code:			DEBUGMSGTL((\"$mibName\", \"not found.\\n\"));
code:		return (rval);
code:	}
code:	$variables{'code-parser'}{processed}
code:	$variables{'code-create'}{processed}
code:	$variables{'code-var-table'}{processed}
code:	$variables{'code-write-func'}{processed}
code:	$variables{'code-write-scalar-func'}{processed}
code:	$variables{'code-write-consistent'}{processed}
code:	$variables{'code-write-rowstatus'}{processed}
code:	$variables{'code-trap-routines'}{processed}
code:	
code:	/**
code:	 * \@fn void ${mibName}_loop_handler(int dummy)
code:	 * \@param sig signal number
code:	 * \@brief handle event loop interation.
code:	 *
code:	 * This function is registered so that, when operating as a module, snmpd will call it one per event
code:	 * loop interation.  This function is called before the next requst is processed and after the
code:	 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
code:	 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
code:	 * closing each time, would be to restart a timer each time that a request is made (loop is
code:	 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
code:	 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
code:	 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
code:	 * request number but it is a temporally unique identifier for a request.
code:	 */
code:	void
code:	${mibName}_loop_handler(int sig)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_loop_handler: executing loop handler...  \"));
code:		 /* close files after each request */
code:		if (sa_fclose) {
code:			if (my_fd >= 0) {
code:				close(my_fd);
code:				my_fd = -1;
code:			}
code:		}
code:	#if defined MASTER
code:		 /* prepare for next request */
code:		sa_request++;
code:	#endif /* defined MASTER */
code:		if (external_signal_scheduled[sig] == 0)
code:			external_signal_scheduled[sig]--;
code:		if (${mibName}old_signal_handler != NULL)
code:			(*${mibName}old_signal_handler)(sig);
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	
code:	/**
code:	 * \@fn void ${mibName}_fd_handler(int fd, void *dummy)
code:	 * \@param fd file descriptor to read.
code:	 * \@param dummy client data passed to registration function (always NULL).
code:	 * \@brief handle read event on file descriptor.
code:	 *
code:	 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
code:	 * statistical collection interval events, alarm events, or other operational measurement events, by
code:	 * placing a message on the read queue of the \"event handling\" Stream.  Normally this routine
code:	 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
code:	 * events, first and interval events, and alarm indications.
code:	 */
code:	void
code:	${mibName}_fd_handler(int fd, void *dummy)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"${mibName}_fd_handler: executing fd handler...  \"));
code:		 /* XXX: place actions to handle my_fd here... */
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return;
code:	}

# include: mib2c.main.conf

############################################################################
# The .h file
############################################################################
type:	code-dot-h
code:	/*****************************************************************************
code:	
code:	 \@(#) src/snmp/${outputbase}.h
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
code:	 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
code:	 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock\@openss7.org>
code:	
code:	 All Rights Reserved.
code:	
code:	 This program is free software; you can redistribute it and/or modify it under
code:	 the terms of the GNU Affero General Public License as published by the Free
code:	 Software Foundation; version 3 of the License.
code:	
code:	 This program is distributed in the hope that it will be useful, but WITHOUT
code:	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
code:	 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
code:	 details.
code:	
code:	 You should have received a copy of the GNU Affero General Public License
code:	 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
code:	 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
code:	 02139, USA.
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
code:	 behalf of the U.S. Government (\"Government\"), the following provisions apply
code:	 to you.  If the Software is supplied by the Department of Defense (\"DoD\"), it
code:	 is classified as \"Commercial Computer Software\" under paragraph 252.227-7014
code:	 of the DoD Supplement to the Federal Acquisition Regulations (\"DFARS\") (or any
code:	 successor regulations) and the Government is acquiring only the license rights
code:	 granted herein (the license rights customarily provided to non-Government
code:	 users).  If the Software is supplied to any unit or agency of the Government
code:	 other than DoD, it is classified as \"Restricted Computer Software\" and the
code:	 Government's rights in the Software are defined in paragraph 52.227-19 of the
code:	 Federal Acquisition Regulations (\"FAR\") (or any successor regulations) or, in
code:	 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
code:	 (or any successor regulations).
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Commercial licensing and support of this software is available from OpenSS7
code:	 Corporation at a fee.  See http://www.openss7.com/
code:	
code:	 *****************************************************************************/
code:	
code:	#ifndef __LOCAL_${MIBNAME}_H__
code:	#define __LOCAL_${MIBNAME}_H__
code:	
code:	/*
code:	 * This file was generated by mib2c and is intended for use as a mib module
code:	 * for the ucd-snmp snmpd agent.
code:	 */
code:	
code:	extern const char sa_program[];
code:	extern int sa_fclose;			/* default close files between requests */
code:	extern int sa_changed;			/* indication to reread MIB configuration */
code:	extern int sa_stats_refresh;		/* indications that statistics, the mib or its tables need to be refreshed */
code:	extern int sa_request;			/* request number for per-request actions */
code:	/* our storage structure(s) */
code:	struct ${mibName}_data { struct ${mibName}_data *${mibName}_old; uint ${mibName}_rsvs; uint ${mibName}_tsts; uint ${mibName}_sets; uint ${mibName}_request; $variables{'code-structure-mib'}{processed} };
code:	$variables{'code-structure-per-table'}{processed}
code:	/* storage declarations */
code:	extern struct ${mibName}_data *${mibName}Storage;
code:	$variables{'code-structure-storage-declaration'}{processed}
code:	/* enum definitions from the covered mib sections */
code:	$variables{'code-enums'}{processed}
code:	/* notifications */
code:	$variables{'code-declarations-notifications'}{processed}
code:	/* scalars accessible only for notify */
code:	$variables{'code-declarations-parameters'}{processed}
code:	/* object id definitions */
code:	$variables{'code-declarations-oids'}{processed}
code:	/* function prototypes */
code:	/* trap function prototypes */
code:	$variables{'code-trap-declarations'}{processed}
code:	/* variable function prototypes */
code:	void   init_$mibName(void);
code:	void   deinit_$mibName(void);
code:	int term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg);
code:	FindVarMethod var_$mibName;
code:	struct ${mibName}_data *${mibName}_create(void);
code:	struct ${mibName}_data *${mibName}_duplicate(struct ${mibName}_data *);
code:	int ${mibName}_destroy(struct ${mibName}_data **);
code:	int ${mibName}_add(struct ${mibName}_data *);
code:	void parse_$mibName(const char *, char *);
code:	SNMPCallback store_$mibName;
code:	void refresh_$mibName(int);
code:	$variables{'code-var-table-decl'}{processed}
code:	$variables{'code-write-func-decl'}{processed}
code:	#endif /* __LOCAL_${MIBNAME}_H__ */

type:		code-definitions-oids
processoid:	code-definitions-oids
skipif:		$name eq $mibName || $mib->{type} eq "NOTIF"
code:		oid ${name}_oid[" . ($variables{$name}{oidlen}) . "] = { " .( dotstocomma $mib->{objectID} ). " };

type:		code-definitions-notifications
processoid:	code-definitions-notifications
skipif:		$mib->{type} ne "NOTIF"
code:		oid ${name}_oid[" . ($variables{$name}{oidlen}) . "] = { " .( dotstocomma $mib->{objectID} ). " };

type:		code-definitions-parameters
process:	code-definitions-parameters
skipif:		$vroutine ne $mibName || $mib->{access} ne "Notify" || $variables{$vroutine}{$i}{isanindex} == 1
code:		oid ${name}_oid[" . ($variables{$name}{oidlen}) . "] = { " .( dotstocomma $mib->{objectID} ). " };

type:		code-trap-routines
processoid:	code-trap-routines
skipif:		$mib->{type} ne "NOTIF"
code:	void
code:	send_${name}_v2trap(struct variable_list *vars)
code:	{
code:		struct variable_list trap;
code:		DEBUGMSGTL((\"$mibName\", \"send_${name}_v2trap: sending trap...  \"));
code:		trap.next_variable = vars;
code:		trap.name = snmpTrapOID_oid;
code:		trap.name_length = sizeof(snmpTrapOID_oid)/sizeof(oid);
code:		trap.type = ASN_OBJECT_ID;
code:		trap.val.objid = ${name}_oid;
code:		trap.val_len = sizeof(${name}_oid);
code:		trap.index = 0;
code:		send_v2trap(&trap);
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}

############################################################################
# var_ function for tables, which is handled specially and used above
#
#   Note: $vtable is set to the table name in the processtable loop.
############################################################################

#
# header file defs first
#
type:		code-var-table-decl
processtable:	code-var-table-decl
code:	FindVarMethod var_$vtable;
code:	struct ${vtable}_data *${vtable}_create(void);
code:	struct ${vtable}_data *${vtable}_duplicate(struct ${vtable}_data *);
code:	int ${vtable}_destroy(struct ${vtable}_data **);
code:	int ${vtable}_add(struct ${vtable}_data *);
code:	int ${vtable}_del(struct ${vtable}_data *);
code:	void parse_$vtable(const char *, char *);
code:	SNMPCallback store_$vtable;
code:	void refresh_$vtable(int);

#
# .conf Store Code per table
#
type:		code-store-registration
processtable:	code-store-registration
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
code:		store_$vtable, NULL);
#
# .conf Parser Code per table
#
type:		code-parser-registration
processtable:	code-parser-registration
code:		snmpd_register_config_handler(\"$vtable\", parse_$vtable, NULL, \"HELP STRING\");
#
# .conf Parser Code per table
#
type:		code-parser-deregistration
processtable:	code-parser-deregistration
code:	snmpd_unregister_config_handler(\"$vtable\");


type:		code-varlist-add
process:	code-varlist-add
skipif:		$variables{$vroutine}{$name}{isanindex} != 1
code:		 /* $name */
code:		snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{type}}{asnType}, (u_char *) $variables{$mib->{type}}{storageret}thedata->$name, $variables{$mib->{type}}{sizeofstart}thedata->$name$variables{$mib->{type}}{sizeofend});\n 

type:		code-create
processtable:	code-create
skipif:		!$variables{$vtable}{rowstatus}
code:	/**
code:	 * \@fn int activate_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	 * \@param StorageTmp the data row to activate
code:	 * \@brief commit activation of a row to the underlying device
code:	 *
code:	 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
code:	 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
code:	 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
code:	 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
code:	 */
code:	int
code:	activate_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:		 /* XXX: provide code to activate the row with the underlying device */
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn int deactivate_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	 * \@param StorageTmp the data row to deactivate
code:	 * \@brief commit deactivation of a row to the underlying device
code:	 *
code:	 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
code:	 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
code:	 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
code:	 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
code:	 */
code:	int
code:	deactivate_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:		 /* XXX: provide code to deactivate the row with the underlying device */
code:		return SNMP_ERR_NOERROR;
code:	}

type:		code-parser
processtable:	code-parser
code:	/**
code:	 * \@fn struct ${vtable}_data *${vtable}_create(void)
code:	 * \@brief create a fresh data structure representing a new row in the ${vtable} table.
code:	 *
code:	 * Creates a new ${vtable}_data structure by allocating dynamic memory for the structure and
code:	 * initializing the default values of columns in the table.  The row status object, if any, should
code:	 * be set to RS_NOTREADY.
code:	 */
code:	struct ${vtable}_data *
code:	${vtable}_create(void)
code:	{
code:		struct ${vtable}_data *StorageNew = SNMP_MALLOC_STRUCT(${vtable}_data);
code:		DEBUGMSGTL((\"$mibName\", \"${vtable}_create: creating row...  \"));
code:		if (StorageNew != NULL) {
code:			 /* XXX: fill in default row values here into StorageNew */
code:			$variables{$vtable}{'code-default-values'}{processed} ". eval { my $x; if ($variables{$vtable}{rowstatus}) { $x = "StorageNew->$variables{$vtable}{rowstatus} = RS_NOTREADY;"; } $x; } ." }
code:		done:
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return (StorageNew);
code:		goto nomem;
code:		nomem:
code:		${vtable}_destroy(&StorageNew);
code:		goto done;
code:	}
code:	/**
code:	 * \@fn struct ${vtable}_data *${vtable}_duplicate(struct ${vtable}_data *thedata)
code:	 * \@param thedata the row structure to duplicate.
code:	 * \@brief duplicate a row structure for a table.
code:	 *
code:	 * Duplicates the specified row structure \@param thedata and returns a pointer to the newly
code:	 * allocated row structure on success, or NULL on failure.
code:	 */
code:	struct ${vtable}_data *
code:	${vtable}_duplicate(struct ${vtable}_data *thedata)
code:	{
code:		struct ${vtable}_data *StorageNew = SNMP_MALLOC_STRUCT(${vtable}_data);
code:		DEBUGMSGTL((\"$mibName\", \"${vtable}_duplicate: duplicating row...  \"));
code:		if (StorageNew != NULL) {
code:			StorageNew->${vtable}_id = thedata->${vtable}_id; $variables{$vtable}{'code-duplicate-values'}{processed}
code:		}
code:		done:
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return (StorageNew);
code:		goto destroy;
code:		destroy:
code:		${vtable}_destroy(&StorageNew);
code:		goto done;
code:	}
code:	/**
code:	 * \@fn int ${vtable}_destroy(struct ${vtable}_data **thedata)
code:	 * \@param thedata pointer to the extracted or existing data structure in the table.
code:	 * \@brief delete a row structure from a table.
code:	 *
code:	 * Frees a table row that was previously removed from a table.  Note that the strings associated
code:	 * with octet strings, object identifiers and bit strings still attached to the structure will also
code:	 * be freed.  The pointer that was passed in \@param thedata will be set to NULL if it is not already
code:	 * NULL.
code:	 */
code:	int
code:	${vtable}_destroy(struct ${vtable}_data **thedata)
code:	{
code:		struct ${vtable}_data *StorageDel;
code:		DEBUGMSGTL((\"$mibName\", \"${vtable}_destroy: deleting row...  \"));
code:		if ((StorageDel = *thedata) != NULL) { $variables{$vtable}{'code-delete-values'}{processed}
code:			SNMP_FREE(StorageDel);
code:			*thedata = StorageDel;
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${vtable}_add(struct ${vtable}_data *thedata)
code:	 * \@param thedata the structure representing the new row in the table.
code:	 * \@brief adds a row to the ${vtable} table data set.
code:	 *
code:	 * Adds a table row structure to the ${vtable} table.  Note that this function is necessary even
code:	 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
code:	 * by the agent to create rows within the table autonomously.
code:	 */
code:	int
code:	${vtable}_add(struct ${vtable}_data *thedata)
code:	{
code:		struct variable_list *vars = NULL;
code:		DEBUGMSGTL((\"$mibName\", \"${vtable}_add: adding data...  \"));
code:		if (thedata) {
code:			 /* add the index variables to the varbind list, which is used by header_complex to index the data */
code:			$variables{$vtable}{'code-varlist-add'}{processed} header_complex_add_data(&${vtable}Storage, vars, thedata);
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"registered an entry.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${vtable}_del(struct ${vtable}_data *thedata)
code:	 * \@param thedata pointer to the extracted or existing data structure in the table.
code:	 * \@brief delete a row structure from a table.
code:	 *
code:	 * Deletes a table row structure from the ${vtable} table but does not free it.  Note that this
code:	 * function is necessary even when the table rows are not persistent.  This function can be used
code:	 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
code:	 * structure may either be already extracted from the data set, or the structure may still exist in
code:	 * the data set.  This function will extract the row from the table if it has not already been
code:	 * performed by the caller.
code:	 */
code:	int
code:	${vtable}_del(struct ${vtable}_data *thedata)
code:	{
code:		struct ${vtable}_data *StorageDel;
code:		DEBUGMSGTL((\"$mibName\", \"${vtable}_data: deleting data...  \"));
code:		if ((StorageDel = thedata) != NULL) {
code:			struct header_complex_index *hciptr;
code:			if ((hciptr = header_complex_find_entry(${vtable}Storage, StorageDel)) != NULL)
code:			    header_complex_extract_entry(&${vtable}Storage, hciptr);
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn void parse_$vtable(const char *token, char *line)
code:	 * \@param token token used within the configuration file.
code:	 * \@param line line from configuration file matching the token.
code:	 * \@brief parse configuration file for $vtable entries.
code:	 *
code:	 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
code:	 * file line for the registsred token (in this case ${vtable}).  This routine is invoked by UCD-SNMP
code:	 * to read the values of each row in the table from the configuration file.  Note that this
code:	 * procedure may exist regardless of the persistence of the table.  If there are no configured
code:	 * entries in the configuration table, this function will simply not be called.
code:	 */
code:	void
code:	parse_$vtable(const char *token, char *line)
code:	{
code:		size_t tmpsize;
code:		struct ${vtable}_data *StorageTmp = ${vtable}_create();
code:		DEBUGMSGTL((\"$mibName\", \"parse_$vtable: parsing config...  \"));
code:		if (StorageTmp == NULL) {
code:			config_perror(\"malloc failure\");
code:			return;
code:		}
code:		 /* XXX: remove individual columns if not persistent */
code:		$variables{$vtable}{'code-parser-sections'}{processed} ${vtable}_add(StorageTmp);
code:		(void) tmpsize;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_$vtable(): store configuraiton file for $vtable
code:	 * stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$vtable(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		char line[SNMP_MAXBUF];
code:		char *cptr;
code:		size_t tmpsize;
code:		struct ${vtable}_data *StorageTmp;
code:		struct header_complex_index *hcindex;
code:		DEBUGMSGTL((\"$mibName\", \"store_$vtable: storing data...  \"));
code:		refresh_${vtable}(1);
code:		(void) tmpsize;
code:		for(hcindex=${vtable}Storage; hcindex != NULL; hcindex = hcindex->next) {
code:			StorageTmp = (struct ${vtable}_data *) hcindex->data;
code:			 /* XXX: comment entire section if row not persistent */
code:			". eval { my $x; if ($variables{$vtable}{storagetype}) { $x = "if (StorageTmp->$variables{$vtable}{storagetype} == ST_NONVOLATILE)"; } $x; } ." {
code:				memset(line,0,sizeof(line));
code:				strcat(line, \"$vtable \");
code:				cptr = line + strlen(line);
code:				(void) cptr;
code:				 /* XXX: remove individual columns if not persistent */
code:				$variables{$vtable}{'code-persistent-sections'}{processed} snmpd_store_config(line);
code:			}
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}

# individual sections for the parser
type:		code-parser-sections
process:	code-parser-sections
skipif:		!$mib->{type} || $mib->{access} =~ /WriteOnly/
code:		" . eval ("\"$variables{$mib->{type}}{prefree}\"") . "line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{tmpsize}\"") ."); " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "

#
# .conf persistent save Code per table
#
type:		code-persistent-sections
process:	code-persistent-sections
skipif:		!$mib->{type} || $mib->{access} =~ /WriteOnly/
code:		cptr = read_config_store_data($variables{$mib->{type}}{asnType}, cptr, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{tmpsize}\"") .");

#
# Code code per table
#
type:		code-var-table
processtable:	code-var-table
code:	\n/**
code:	 * \@fn int check_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated.
code:	 * \@param StorageOld the data previous to update.
code:	 *
code:	 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
code:	 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
code:	 * when rows are created or destroyed.  This function is called for the first varbind in a row at
code:	 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
code:	 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
code:	 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
code:	 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
code:	 * permitted to change the values in StorageTmp to correct them; however, preference should be made
code:	 * for setting values where were not in the varbinds.
code:	 */
code:	int
code:	check_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to check the row for consistency */
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn int update_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated.
code:	 * \@param StorageOld the data previous to update.
code:	 * \@brief perform the set operation (ACTION phase) on a row
code:	 *
code:	 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
code:	 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
code:	 * when rows are created or destroyed.  This function is called for the first varbind in a row at
code:	 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
code:	 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
code:	 * arrives here with consistency already checked (see check_${vtable}_row()).  This function can
code:	 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
code:	 * varbinds on the row were applied: the values in StorageTmp are the new values.
code:	 */
code:	int
code:	update_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to update the row with the underlying device */
code:		${vtable}_refresh = 1;
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn int revert_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	 * \@param StorageTmp the data as updated.
code:	 * \@param StorageOld the data previous to update.
code:	 * \@brief perform the undo operation (UNDO phase) on a row
code:	 */
code:	void
code:	revert_${vtable}_row(struct ${vtable}_data *StorageTmp, struct ${vtable}_data *StorageOld)
code:	{
code:		 /* XXX: provide code to revert the row with the underlying device */
code:		update_${vtable}_row(StorageOld, NULL);
code:	}
code:	/**
code:	 * \@fn void refresh_${vtable}_row(struct ${vtable}_data *StorageTmp, int force)
code:	 * \@param StorageTmp the data row to refresh.
code:	 * \@param force force refresh if non-zero.
code:	 * \@brief refresh the contents of the $vtable row.
code:	 *
code:	 * Normally the values retrieved from the operating system are cached.  However, if a row contains
code:	 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
code:	 * may be necessary to refresh the row on some other basis, but normally only once per request.
code:	 */
code:	struct ${vtable}_data *
code:	refresh_${vtable}_row(struct ${vtable}_data *StorageTmp, int force)
code:	{
code:		if (!StorageTmp || (!force && StorageTmp->${vtable}_request == sa_request))
code:			return (StorageTmp);
code:		 /* XXX: update row; delete it and return NULL if the row has disappeared */
code:		StorageTmp->${vtable}_request = sa_request;
code:		return (StorageTmp);
code:	}
code:	/**
code:	 * \@fn void refresh_$vtable(int force)
code:	 * \@param force force refresh if non-zero.
code:	 * \@brief refresh the scalar values of the $vtable.
code:	 *
code:	 * Normally the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
code:	 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
code:	 * time, or after a SIGPOLL has been received (and a row or column has been requested).
code:	 */
code:	void
code:	refresh_$vtable(int force)
code:	{
code:		if (!force && ${vtable}_refresh == 0)
code:			return;
code:		 /* XXX: Here, update the table as required... */
code:		${vtable}_refresh = 0;
code:	}
code:	/**
code:	 * \@fn u_char *var_$vtable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	 * \@brief locate variables in $vtable.
code:	 *
code:	 * Handle this table separately from the scalar value case.  The workings of this are basically the
code:	 * same as for var_$mibName above.
code:	 */
code:	u_char *
code:	var_$vtable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:		struct ${vtable}_data *StorageTmp = NULL;
code:		u_char *rval;
code:		DEBUGMSGTL((\"$mibName\", \"var_$vtable: Entering...  \\n\"));
code:		 /* Make sure that the storage data does not need to be refreshed before checking the header. */
code:		refresh_$vtable(0);
code:		 /* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
code:		while ((StorageTmp = header_complex(${vtable}Storage, vp,name,length, exact, var_len,write_method)))
code:			if ((StorageTmp = refresh_${vtable}_row(StorageTmp, 0)) || exact)
code:				break;
code:		*write_method = NULL;
code:		*var_len = 0;
code:		rval = NULL;
code:		 /* This is where we do the value assignments for the mib results. */
code:		switch(vp->magic) { $variables{$vtable}{'code-case-statements'}{processed}
code:		default:
code:			ERROR_MSG(\"\");
code:		}
code:		return (rval);
code:	}

############################################################################
# case statement sections
############################################################################
type:		code-case-statements
process:	code-case-statements
skipif:		$mib->{access} =~ /NoAccess|Notify/ || $variables{$vroutine}{$name}{isanindex} == 1 || $variables{$vroutine}{$name}{ismyindex} == 1
code:		case (u_char) $NAME: /* $mib->{access} */
code:			" . (($mib->{access} =~ /ReadWrite|WriteOnly|Create/) ? "*write_method = write_$name;" : "") . " " . (($mib->{access} =~ /WriteOnly/) ? "break;" : "if (!StorageTmp) break; *var_len = $variables{$mib->{type}}{sizeofstart}StorageTmp->$name$variables{$mib->{type}}{sizeofend}; rval = (u_char *) $variables{$mib->{type}}{storageret}StorageTmp->$name; break;") . "

############################################################################
# storage structure information
############################################################################
type:		variable-structure-info
process:	variable-structure-info
skipif:		$mib->{access} =~ /NoAccess|Notify/ || $variables{$mibName}{$name}{isanindex} == 1 || $variables{$name}{myoid} != 1
code:		" . sprintf("#define   %-20s  $count", $NAME) . "
code:		" . sprintf("  { (u_char) %-20s, %-14s, %-6.6s, %s, %d, { %s } },", $NAME, $variables{$mib->{type}}{asnType}, $accessToUCD{$mib->{access}}, "var_$vroutine", $depth-1, $subid) . "

############################################################################
# write function definition, also appended to the end of the .c file.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-func-decl
process:	code-write-func-decl
skipif:		$mib->{access} !~ /Write|Create/
code:		WriteMethod write_$name;
#
#
#
type:		code-delete-scalar
process:	code-delete-scalar
skipif:		$vroutine ne $mibName
code:		$variables{$mib->{type}}{deletevar}
#
#
#
type:		code-config-scalar
process:	code-config-scalar
skipif:		$vroutine ne $mibName || $mib->{access} =~ /WriteOnly|NoAccess|Notify/ || $variables{$vroutine}{$name}{isanindex} == 1
code:		" . eval ("\"$variables{$mib->{type}}{prefree}\"") . "line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{tmpsize}\"") ."); " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "
#
#
#
type:		code-persistent-scalars
process:	code-persistent-scalars
skipif:		$vroutine ne $mibName || $mib->{access} =~ /WriteOnly|NoAccess|Notify/ || $variables{$vroutine}{$name}{isanindex} == 1
code:		cptr = read_config_store_data($variables{$mib->{type}}{asnType}, cptr, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{tmpsize}\"") .");
#
#
#
type:		code-write-length-check-string
process:	code-write-length-check-string
skipif:		$mib->{type} !~ /OCTETSTR|OBJECTID/
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . "\nif ($variables{$mib->{type}}{varlencheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "var_val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > var_val_len || var_val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . ") {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
#
#
type:		code-write-length-check-string-index
process:	code-write-length-check-string-index
skipif:		$mib->{type} !~ /OCTETSTR|OBJECTID/
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . "\nif ($variables{$mib->{type}}{varptrcheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "vp->val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > vp->val_len || vp->val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . ") {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad length\\n\");
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_INCONSISTENTNAME;
code:		}
#
# BITS are ASN.1 BitString.  The content passed to us by UCD-SNMP is the contents of the ASN.1
# BitString type which consists of one octet indicating the number of bits in the last octet that
# are unused (0..7) and then the octets containing bits themselves.  Therefore, the length cannot be
# less than two or there is an error.
#
type:		code-write-length-check-bits
process:	code-write-length-check-bits
skipif:		$mib->{type} ne "BITS"
code:		\nif (var_val_type == ASN_BIT_STR) {
code:			if (1 > var_val_len || $variables{$mib->{type}}{varlencheck} " .  eval { my ($i, $x, $n); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { if ($x < $mib->{enums}{$i}) { $x = $mib->{enums}{$i}; } } if ($x > 0) { $n = (($x + 7) >> 3) + 1; $x = "|| var_val_len != $n"; } $x; } ." ) {
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:				return SNMP_ERR_WRONGLENGTH;
code:			}
code:		}
code:		if (var_val_type == ASN_OCTET_STR) {
code:			" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = " /* Note: ranges $x */"; } $x; } . "if ($variables{$mib->{type}}{varlencheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "var_val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > var_val_len || var_val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . "" .  eval { my ($i, $x, $n); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { if ($x < $mib->{enums}{$i}) { $x = $mib->{enums}{$i}; } } if ($x > 0) { $n = ($x + 7) >> 3; $x = "|| var_val_len != $n"; } $x; } .") {
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:				return SNMP_ERR_WRONGLENGTH;
code:			}
code:		}
#
#
type:		code-write-length-check-bits-index
process:	code-write-length-check-bits-index
skipif:		$mib->{type} ne "BITS"
code:		\nif (vp->type == ASN_BIT_STR) {
code:			if (1 > vp->val_len || $variables{$mib->{type}}{varptrcheck} " .  eval { my ($i, $x, $n); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { if ($x < $mib->{enums}{$i}) { $x = $mib->{enums}{$i}; } } if ($x > 0) { $n = (($x + 7) >> 3) + 1; $x = "|| vp->val_len != $n"; } $x; } ." ) {
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad length\\n\");
code:				snmp_free_varbind(vars);
code:				return SNMP_ERR_INCONSISTENTNAME;
code:			}
code:		}
code:		if (vp->type == ASN_OCTET_STR) {
code:			" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = " /* Note: ranges $x */"; } $x; } . "if ($variables{$mib->{type}}{varptrcheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "vp->val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > vp->val_len || vp->val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . "" .  eval { my ($i, $x, $n); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { if ($x < $mib->{enums}{$i}) { $x = $mib->{enums}{$i}; } } if ($x > 0) { $n = ($x + 7) >> 3; $x = "|| vp->val_len != $n"; } $x; } .") {
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad length\\n\");
code:				snmp_free_varbind(vars);
code:				return SNMP_ERR_INCONSISTENTNAME;
code:			}
code:		}
#
type:		code-write-length-check-fixed
process:	code-write-length-check-fixed
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/
code:		\nif ($variables{$mib->{type}}{varlencheck}) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
#
type:		code-write-length-check-fixed-index
process:	code-write-length-check-fixed-index
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/
code:		\nif ($variables{$mib->{type}}{varptrcheck}) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad length\\n\");
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_INCONSISTENTNAME;
code:		}
#
type:		code-write-value-check-range
process:	code-write-value-check-range
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar @{$mib->{ranges}}
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "$variables{$mib->{type}}{varname} != $e->{low}"; } else { $x .= "($e->{low} > $variables{$mib->{type}}{varname} || $variables{$mib->{type}}{varname} > $e->{high})"; } $s = "&&"; } unless ($x eq "") { $x = "\nif ($x) { snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
#
type:		code-write-value-check-range-index
process:	code-write-value-check-range-index
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar @{$mib->{ranges}}
code:		\n" . eval{ my ($e, $x); foreach $e (@{$mib->{ranges}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = " /* Note: ranges $x */"; } $x; } . eval { my ($e, $x, $s); foreach $e (@{$mib->{ranges}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "$variables{$mib->{type}}{varlistval} != $e->{low}"; } else { $x .= "($e->{low} > $variables{$mib->{type}}{varlistval} || $variables{$mib->{type}}{varlistval} > $e->{high})"; } $s = "&&"; } unless ($x eq "") { $x = "\nif ($x) { snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad value\\n\"); snmp_free_varbind(vars); return SNMP_ERR_INCONSISTENTNAME; }"; } $x; } . "
#
type:		code-write-value-check-enum
process:	code-write-value-check-enum
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar keys(%{$mib->{enums}}) || $mib->{textualConvention} eq "RowStatus" || $mib->{textualConvention} eq "StorageType" || $mib->{textualConvention} eq "TruthValue"
code:		" . eval { my ($i, $x); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { $x .= sprintf("case %-40s:\n","${NAME}_" . uc($i)); } $x =~ s/-/_/g; unless ($x eq "") { $x = "\n switch($variables{$mib->{type}}{varname}) { $x break; default: snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
#
type:		code-write-value-check-enum-index
process:	code-write-value-check-enum-index
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar keys(%{$mib->{enums}}) || $mib->{textualConvention} eq "RowStatus" || $mib->{textualConvention} eq "StorageType" || $mib->{textualConvention} eq "TruthValue"
code:		" . eval { my ($i, $x); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { $x .= sprintf("case %-40s:\n","${NAME}_" . uc($i)); } $x =~ s/-/_/g; unless ($x eq "") { $x = "\n switch($variables{$mib->{type}}{varlistval}) { $x break; default: snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad value\\n\"); snmp_free_varbind(vars); return SNMP_ERR_INCONSISTENTNAME; }"; } $x; } . "
#
type:		code-write-value-check-rowstatus
process:	code-write-value-check-rowstatus
skipif:		$mib->{textualConvention} ne "RowStatus"
code:		\n /* check legal range, and notReady is reserved for us, not a user */
code:		if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
#
type:		code-write-value-check-rowstatus-index
process:	code-write-value-check-rowstatus-index
skipif:		$mib->{textualConvention} ne "RowStatus"
code:		 /* check legal range, and notReady is reserved for us, not a user */
code:		if ((ulong) *vp->val.integer < 1 || (ulong) *vp->val.integer > 6 || (ulong) *vp->val.integer == RS_NOTREADY) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad value\\n\");
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_INCONSISTENTNAME;
code:		}
#
type:		code-write-value-check-storagetype
process:	code-write-value-check-storagetype
skipif:		$mib->{textualConvention} ne "StorageType"
code:		switch (set_value) {
code:		case ST_OTHER:
code:		case ST_VOLATILE:
code:		case ST_NONVOLATILE:
code:		case ST_PERMANENT:
code:		case ST_READONLY:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
#
type:		code-write-value-check-storagetype-index
process:	code-write-value-check-storagetype-index
skipif:		$mib->{textualConvention} ne "StorageType"
code:		switch ((ulong) *vp->val.integer) {
code:		case ST_OTHER:
code:		case ST_VOLATILE:
code:		case ST_NONVOLATILE:
code:		case ST_PERMANENT:
code:		case ST_READONLY:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad value\\n\");
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_INCONSISTENTNAME;
code:		}
#
type:		code-write-value-check-truthvalue
process:	code-write-value-check-truthvalue
skipif:		$mib->{textualConvention} ne "TruthValue"
code:		switch (set_value) {
code:		case TV_TRUE:
code:		case TV_FALSE:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
#
type:		code-write-value-check-truthvalue-index
process:	code-write-value-check-truthvalue-index
skipif:		$mib->{textualConvention} ne "TruthValue"
code:		switch ((ulong) *vp->val.integer) {
code:		case TV_TRUE:
code:		case TV_FALSE:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"index $name: bad value\\n\");
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_INCONSISTENTNAME;
code:		}
#
#type:		code-write-value-check-bits
#process:	code-write-value-check-bits
#skipif:		$mib->{type} ne "BITS" || !scalar keys(%{$mib->{enums}})
#code:		". eval { my ($i, $x); foreach $i (sort {$mib->{enums}{$a} <=> $mib->{enums}{$b}} keys(%{$mib->{enums}})) { if ($x < $mib->{enums}{$i}) { $x = $mib->{enums}{$i}; } } if ($x > 0) { $x = "\n if (var_val_len < 1 || *var_val != (8 - ($x & 0x07))) { snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
# C code
#
type:		code-write-scalar-func
process:	code-write-scalar-func
skipif:		$vroutine ne $mibName || $mib->{access} !~ /Write|Create/
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Scalar write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
#code:		static $variables{$mib->{type}}{tmpvar} old_value;
code:		struct ${vroutine}_data *StorageTmp = NULL, *StorageOld = NULL;
code:		$variables{$mib->{type}}{varinit}
code:		int ret = SNMP_ERR_NOERROR;
code:		DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:		if ((StorageTmp = ${vroutine}Storage) == NULL)
code:			return SNMP_ERR_NOSUCHNAME;
code:		switch ( action ) {
code:		case RESERVE1:
code:			if ($variables{$mib->{type}}{vartypecheck}){
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{type}}{asnType}\\n\");
code:				return SNMP_ERR_WRONGTYPE;
code:			} " . $variables{$vroutine}{$name}{'code-write-length-check-string'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-bits'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{processed} . (defined $mib->{defaultValue} ? "\n /* Note: default value $mib->{defaultValue} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-storagetype'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-truthvalue'}{processed} . "
code:			 /* one allocation for whole mib */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				if (StorageTmp->${vroutine}_rsvs == 0)
code:					if ((StorageOld = StorageTmp->${vroutine}_old = ${vroutine}_duplicate(StorageTmp)) == NULL)
code:						return SNMP_ERR_RESOURCEUNAVAILABLE;
code:			if (StorageOld != NULL)
code:				StorageTmp->${vroutine}_rsvs++; ".eval ("\"$variables{$mib->{type}}{reserve1}\"")."
code:			 /* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
code:			break;
code:		case RESERVE2: /* memory reseveration, final preparation... */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				 /* one consistency check for the whole mib */
code:				if (StorageTmp->${vroutine}_tsts == 0)
code:					if ((ret = check_${vroutine}(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				StorageTmp->${vroutine}_tsts++; ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:			}
code:			break;
code:		case ACTION: /* The variable has been stored in StorageTmp->${name} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
code:			 /* XXX: insert code to set this particular varbind, if necessary */
code:			 /* one set action for the whole mib */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				 /* XXX: insert code to set this particular varbind, if necessary */
code:				if (StorageTmp->${vroutine}_sets == 0)
code:					if ((ret = update_${vroutine}(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				StorageTmp->${vroutine}_sets++; ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:			}
code:			break;
code:		case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{type}}{commit}\"")."
code:			 /* one commit for the whole mib */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:				StorageTmp->${vroutine}_rsvs = 0;
code:				StorageTmp->${vroutine}_tsts = 0;
code:				StorageTmp->${vroutine}_sets = 0;
code:			}
code:			break;
code:		case UNDO: /* Back out any changes made in the ACTION case */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				break; ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:			 /* XXX: insert code to undo any action performed on this particular varbind */
code:			if (--StorageTmp->${vroutine}_tsts == 0)
code:				revert_${vroutine}(StorageTmp, StorageOld);
code:			 /* fall through */
code:		case FREE: /* Release any resources that have been allocated */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				break; ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:			if (--StorageTmp->${vroutine}_rsvs == 0)
code:				${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
#
type:		code-write-value-reserve2
process:	code-write-value-reserve2
skipif:		!$variables{$vroutine}{rowstatus} || $vroutine eq $mibName || $mib->{textualConvention} eq "RowStatus" || $mib->{access} !~ /ReadWrite|Create/
code:		if (StorageTmp == NULL)
code:			break;
#code:		if (StorageTmp->${vroutine}_rsvs == 0 && StorageTmp->${vroutine}_old == NULL)
#code:			if ((StorageTmp->${vroutine}_old = ${vroutine}_duplicate(StorageTmp)) == NULL)
#code:				return SNMP_ERR_RESOURCEUNAVAILABLE;
#
type:		code-write-create-storage-check
process:	code-write-create-storage-check
skipif:		!$variables{$vroutine}{rowstatus} || $vroutine eq $mibName || $mib->{textualConvention} eq "RowStatus" || $mib->{access} !~ /ReadWrite|Create/
code:		if (StorageTmp == NULL)
code:			return SNMP_ERR_NOSUCHNAME;
#code:		StorageTmp->${vroutine}_rsvs++;
#code:		if (StorageTmp->${vroutine}_old != NULL)
#code:			break;
#
type:		code-write-nocreate-storage-check
process:	code-write-nocreate-storage-check
skipif:		$variables{$vroutine}{rowstatus} || $vroutine eq $mibName || $mib->{textualConvention} eq "RowStatus" || $mib->{access} !~ /ReadWrite|Create/
code:		if (StorageTmp == NULL)
code:			return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */
#
type:		code-write-rowstatus-check
process:	code-write-rowstatus-check
skipif:		!$variables{$vroutine}{rowstatus} || $vroutine eq $mibName || $mib->{textualConvention} eq "RowStatus" || $mib->{access} !~ /ReadWrite|Create/
code:		if (StorageTmp != NULL && statP == NULL) {
code:			 /* have row but no column */
code:			switch (StorageTmp->$variables{$vroutine}{rowstatus}) {
code:			case RS_ACTIVE:
code:				 /* cannot create non-existent column while active */
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: but column non-existent\\n\");
code:				return SNMP_ERR_INCONSISTENTVALUE;
code:			case RS_NOTINSERVICE:
code:			case RS_NOTREADY:
code:				 /* assume column can be created */
code:				break;
code:			}
code:		}
#
# C code
#
type:		code-write-func
process:	code-write-func
skipif:		$vroutine eq $mibName || $mib->{textualConvention} eq "RowStatus" || $mib->{access} !~ /Write|Create/
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Table row and column write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
#code:		static $variables{$mib->{type}}{tmpvar} old_value;
code:		struct ${vroutine}_data *StorageTmp = NULL, *StorageOld = NULL;
code:		size_t newlen=name_len - $variables{$name}{oidlen};
code:		$variables{$mib->{type}}{varinit}
code:		int ret = SNMP_ERR_NOERROR;
code:		DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:		if (StorageTmp == NULL)
code:			return SNMP_ERR_NOSUCHNAME;
code:		StorageTmp = header_complex(${vroutine}Storage, NULL, &name[$variables{$name}{oidlen}], &newlen, 1, NULL, NULL); $variables{$vroutine}{$name}{'code-write-nocreate-storage-check'}{processed}
code:		switch ( action ) {
code:		case RESERVE1: $variables{$vroutine}{$name}{'code-write-rowstatus-check'}{processed}
code:			if ($variables{$mib->{type}}{vartypecheck}){
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{type}}{asnType}\\n\");
code:				return SNMP_ERR_WRONGTYPE;
code:			} " . $variables{$vroutine}{$name}{'code-write-length-check-string'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-bits'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{processed} . (defined $mib->{defaultValue} ? "\n /* Note: default value $mib->{defaultValue} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-storagetype'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-truthvalue'}{processed} . "
code:			 /* one allocation for the whole row */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				if (StorageTmp->${vroutine}_rsvs == 0)
code:					if ((StorageOld = StorageTmp->${vroutine}_old = ${vroutine}_duplicate(StorageTmp)) == NULL)
code:						return SNMP_ERR_RESOURCEUNAVAILABLE;
code:			if (StorageOld != NULL)
code:				StorageTmp->${vroutine}_rsvs++; ".eval ("\"$variables{$mib->{type}}{reserve1}\"")."
code:			 /* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
code:			break;
code:		case RESERVE2: /* memory reseveration, final preparation... */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				 /* one consistency check for the whole row */
code:				if (StorageTmp->${vroutine}_tsts == 0)
code:					if ((ret = check_${vroutine}_row(StorageTmp,  StorageOld)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				StorageTmp->${vroutine}_tsts++; ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:			}
code:			break;
code:		case ACTION: /* The variable has been stored in StorageTmp->${name} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */ $variables{$vroutine}{$name}{'code-write-create-storage-check'}{processed}
code:			 /* XXX: insert code to set this particular varbind, if necessary */
code:			 /* one set action for the whole row */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				 /* XXX: insert code to set this particular varbind, if necessary */
code:				if (StorageTmp->${vroutine}_sets == 0)
code:					if ((ret = update_${vroutine}_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				StorageTmp->${vroutine}_sets++; ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:			}
code:			break;
code:		case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{type}}{commit}\"")."
code:			 /* one commit for the whole mib */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:				${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:				StorageTmp->${vroutine}_rsvs = 0;
code:				StorageTmp->${vroutine}_tsts = 0;
code:				StorageTmp->${vroutine}_sets = 0;
code:			}
code:			break;
code:		case UNDO: /* Back out any changes made in the ACTION case */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				break; ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:			 /* XXX: insert code to undo any action performed on this particular varbind */
code:			if (--StorageTmp->${vroutine}_sets == 0)
code:				revert_${vroutine}_row(StorageTmp, StorageOld);
code:			 /* fall through */
code:		case FREE: /* Release any resources that have been allocated */
code:			if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:				break; ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:			if (--StorageTmp->${vroutine}_rsvs == 0)
code:				${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
############################################################################
# check syntax of varlist
############################################################################
type:		code-varlist-check
process:	code-varlist-check
skipif:		$variables{$vroutine}{$name}{isanindex} != 1
code:		\n /* $name */" . $variables{$vroutine}{$name}{'code-write-length-check-string-index'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-bits-index'}{processed} . $variables{$vroutine}{$name}{'code-write-length-check-fixed-index'}{processed} . (defined $mib->{defaultValue} ? "\n /* Note: default value $mib->{defaultValue} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range-index'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-enum-index'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-rowstatus-index'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-storagetype-index'}{processed} . $variables{$vroutine}{$name}{'code-write-value-check-truthvalue-index'}{processed} . "
code:		vp = vp->next_variable;
############################################################################
# copy memory from varlist
############################################################################
type:		code-varlist-copy
process:	code-varlist-copy
skipif:		$variables{$vroutine}{$name}{isanindex} != 1
code:		".eval("\"$variables{$mib->{type}}{action2}\"")."
code:		vp = vp->next_variable;
############################################################################
# fill out default values in mib
############################################################################
type:		code-default-scalars
process:	code-default-scalars
skipif:		$vroutine ne $mibName || $mib->{access} =~ /NoAccess|Notify/
code:		". ( defval $mib ). "
#code:		".eval("\"$variables{$mib->{type}}{action3}\"")."
############################################################################
# fill out default values in row
############################################################################
type:		code-default-values
process:	code-default-values
skipif:		defined $variables{$vroutine}{$name}{ismyindex}
code:		". ( defval $mib ). "
#code:		".eval("\"$variables{$mib->{type}}{action3}\"")."
############################################################################
# duplicate values in row
############################################################################
type:		code-duplicate-values
process:	code-duplicate-values
code:		".eval("\"$variables{$mib->{type}}{action4}\"")."
############################################################################
# duplicate values in mib
############################################################################
type:		code-duplicate-scalars
process:	code-duplicate-scalars
skipif:		$mib->{access} =~ /NoAccess|Notify/
code:		".eval("\"$variables{$mib->{type}}{action4}\"")."
############################################################################
# delete values from mib
############################################################################
type:		code-delete-scalars
process:	code-delete-scalars
skipif:		$vroutine ne $mibName || $mib->{access} =~ /NoAccess|Notify/ || !($mib->{type} eq "OCTETSTR" || $mib->{type} eq "OBJECTID" || $mib->{type} eq "BITS")
code:		".eval("\"$variables{$mib->{type}}{deletevar}\"")."
############################################################################
# delete values from a row
############################################################################
type:		code-delete-values
process:	code-delete-values
skipif:		!($mib->{type} eq "OCTETSTR" || $mib->{type} eq "OBJECTID" || $mib->{type} eq "BITS")
code:		".eval("\"$variables{$mib->{type}}{deletevar}\"")."
############################################################################
# add null pointers to a varlist; value to be parsed later
############################################################################
type:		code-varlist-add-null
process:	code-varlist-add-null
skipif:		$variables{$vroutine}{$name}{isanindex} != 1
code:		 /* $name */
code:		if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{type}}{asnType}, NULL, 0)) == NULL) {
code:			snmp_free_varbind(vars);
code:			return SNMP_ERR_RESOURCEUNAVAILABLE;
code:		}\n 
############################################################################
# write function definition for a RowStatus object,
#   - allows for creation/deletion.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-rowstatus-decl
process:	code-write-rowstatus-decl
skipif:		$mib->{textualConvention} ne "RowStatus"
code:		WriteMethod write_$name;
#
#
#
type:		code-write-rowstatus-oid
process:	code-write-rowstatus-oid
skipif:		$mib->{textualConvention} ne "RowStatus"
code:		oid ${vroutine}_variables_oid[" . ($variables{$name}{oidlen}-1) . "] = { " .( stripone dotstocomma $mib->{objectID} ). " };
#
#
#
type:		code-write-consistent
processtable:	code-write-consistent
skipif:		!defined $variables{$vtable}{rowstatus}
code:	\n/**
code:	 * \@fn int can_act_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	 * \@param StorageTmp the data (as updated)
code:	 * \@brief check whether an inactive table row can be activated
code:	 *
code:	 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
code:	 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
code:	 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
code:	 * the commit phase will succeed.
code:	 */
code:	int
code:	can_act_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:		 /* XXX: provide code to check whether the new or inactive table row can be activated */
code:		return SNMP_ERR_NOERROR;
code:	}
code:	/**
code:	 * \@fn int can_deact_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	 * \@param StorageTmp the data (as updated)
code:	 * \@brief check whether an active table row can be deactivated
code:	 *
code:	 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
code:	 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
code:	 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
code:	 * the commit phase will succeed.
code:	 */
code:	int
code:	can_deact_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:		 /* XXX: provide code to check whether the active table row can be deactivated */
code:		return SNMP_ERR_NOERROR;
code:	}
#
# code
#
type:		code-write-rowstatus
process:	code-write-rowstatus
skipif:		$mib->{textualConvention} ne "RowStatus"
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Row status write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:		struct ${vroutine}_data *StorageTmp = NULL, *StorageOld = NULL;
code:		static struct ${vroutine}_data *StorageNew, *StorageDel;
code:		size_t newlen=name_len - $variables{$name}{oidlen};
#code:		static int old_value;
code:		int set_value, ret;
code:		static struct variable_list *vars, *vp;
code:		DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:		StorageTmp = header_complex(${vroutine}Storage, NULL, &name[$variables{$name}{oidlen}], &newlen, 1, NULL, NULL);
code:		if ($variables{$mib->{type}}{vartypecheck} || var_val == NULL) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not ASN_INTEGER\\n\");
code:			return SNMP_ERR_WRONGTYPE;
code:		}
code:		set_value = *((long *) var_val); $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{processed}
code:		switch ( action ) {
code:		case RESERVE1:
code:			 /* stage one: test validity */
code:			StorageNew = StorageDel = NULL;
code:			vars = vp = NULL;
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				if (StorageTmp != NULL)
code:					 /* cannot create existing row */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* creation */
code:				vars = NULL;
code:				$variables{$vroutine}{'code-varlist-add-null'}{processed} if (header_complex_parse_oid(&(name[$variables{$name}{oidlen}]), newlen, vars) != SNMPERR_SUCCESS) {
code:					snmp_free_varbind(vars);
code:					return SNMP_ERR_INCONSISTENTNAME;
code:				}
code:				vp = vars; $variables{$vroutine}{'code-varlist-check'}{processed}
code:				if ((StorageNew = ${vroutine}_create()) == NULL) {
code:					snmp_free_varbind(vars);
code:					return SNMP_ERR_RESOURCEUNAVAILABLE;
code:				}
code:				StorageNew->${vroutine}_rsvs = 1;
code:				vp = vars; $variables{$vroutine}{'code-varlist-copy'}{processed}
code:				header_complex_add_data(&${vroutine}Storage, vars, StorageNew); /* frees vars */
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				if (StorageTmp == NULL)
code:					 /* cannot change state of non-existent row */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				if (StorageTmp->$name == RS_NOTREADY)
code:					 /* cannot change state of row that is not ready */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* XXX: interaction with row storage type needed */
code:				if (set_value == RS_NOTINSERVICE && StorageTmp->${vroutine}_refs > 0)
code:					 /* row is busy and cannot be moved to the RS_NOTINSERVICE state */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* activate or deactivate */
code:				if (StorageTmp == NULL)
code:					return SNMP_ERR_NOSUCHNAME;
code:				 /* one allocation for the whole row */
code:				if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:					if (StorageTmp->${vroutine}_rsvs == 0)
code:						if ((StorageOld = StorageTmp->${vroutine}_old = ${vroutine}_duplicate(StorageTmp)) == NULL)
code:							return SNMP_ERR_RESOURCEUNAVAILABLE;
code:				if (StorageOld != NULL)
code:					StorageTmp->${vroutine}_rsvs++;
code:				break;
code:			case RS_DESTROY:
code:				if (StorageTmp == NULL)
code:					 /* cannot destroy non-existent row */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* XXX: interaction with row storage type needed */
code:				if (StorageTmp->${vroutine}_refs > 0)
code:					 /* row is busy and cannot be deleted */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* destroy */
code:				if (StorageTmp != NULL) {
code:					 /* exists, extract it for now */
code:					StorageDel = StorageTmp;
code:					${vroutine}_del(StorageDel);
code:				} else {
code:					StorageDel = NULL;
code:				}
code:				break;
code:			case RS_NOTREADY:
code:				 /* management station cannot set this, only agent can */
code:			default:
code:				return SNMP_ERR_INCONSISTENTVALUE;
code:			}
code:			break;
code:		case RESERVE2:
code:			 /* memory reseveration, final preparation... */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:				 /* check that activation is possible */
code:				if ((ret = can_act_${vroutine}_row(StorageNew)) != SNMP_ERR_NOERROR)
code:					return (ret);
code:				break;
code:			case RS_CREATEANDWAIT:
code:				break;
code:			case RS_ACTIVE:
code:				 /* check that activation is possible */
code:				if (StorageTmp->$name != RS_ACTIVE)
code:					if ((ret = can_act_${vroutine}_row(StorageTmp)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				break;
code:			case RS_NOTINSERVICE:
code:				 /* check that deactivation is possible */
code:				if (StorageTmp->$name != RS_NOTINSERVICE)
code:					if ((ret = can_deact_${vroutine}_row(StorageTmp)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				break;
code:			case RS_DESTROY:
code:				 /* check that deactivation is possible */
code:				if (StorageTmp->$name != RS_NOTINSERVICE)
code:					if ((ret = can_deact_${vroutine}_row(StorageTmp)) != SNMP_ERR_NOERROR)
code:						return (ret);
code:				break;
code:			default:
code:				return SNMP_ERR_WRONGVALUE;
code:			}
code:			break;
code:		case ACTION:
code:			 /* The variable has been stored in StorageTmp->$name for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:				 /* activate with underlying device */
code:				if (activate_${vroutine}_row(StorageNew) != SNMP_ERR_NOERROR)
code:					return SNMP_ERR_COMMITFAILED;
code:				break;
code:			case RS_CREATEANDWAIT:
code:				break;
code:			case RS_ACTIVE:
code:				 /* state change already performed */
code:				if (StorageTmp->$name != RS_ACTIVE) {
code:					 /* activate with underlying device */
code:					if (activate_${vroutine}_row(StorageTmp) != SNMP_ERR_NOERROR)
code:						return SNMP_ERR_COMMITFAILED;
code:				}
code:				break;
code:			case RS_NOTINSERVICE:
code:				 /* state change already performed */
code:				if (StorageTmp->$name != RS_NOTINSERVICE) {
code:					 /* deactivate with underlying device */
code:					if (deactivate_${vroutine}_row(StorageTmp) != SNMP_ERR_NOERROR)
code:						return SNMP_ERR_COMMITFAILED;
code:				}
code:				break;
code:			case RS_DESTROY:
code:				 /* commit destrution to underlying device */
code:				if (StorageDel == NULL)
code:					break;
code:				 /* deactivate with underlying device */
code:				if (deactivate_${vroutine}_row(StorageDel) != SNMP_ERR_NOERROR)
code:					return SNMP_ERR_COMMITFAILED;
code:				break;
code:			default:
code:				return SNMP_ERR_WRONGVALUE;
code:			}
code:			break;
code:		case COMMIT:
code:			 /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:				StorageNew->$name = RS_ACTIVE;
code:				break;
code:			case RS_CREATEANDWAIT:
code:				StorageNew->$name = RS_NOTINSERVICE;
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				StorageNew->$name = set_value;
code:				if ((StorageOld = StorageTmp->${vroutine}_old) != NULL) {
code:					${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:					StorageTmp->${vroutine}_rsvs = 0;
code:					StorageTmp->${vroutine}_tsts = 0;
code:					StorageTmp->${vroutine}_sets = 0;
code:				}
code:				break;
code:			case RS_DESTROY:
code:				${vroutine}_destroy(&StorageDel);
code:				break;
code:			}
code:			break;
code:		case UNDO:
code:			 /* Back out any changes made in the ACTION case */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:				 /* deactivate with underlying device */
code:				deactivate_${vroutine}_row(StorageNew);
code:				break;
code:			case RS_CREATEANDWAIT:
code:				break;
code:			case RS_ACTIVE:
code:				if (StorageTmp->$name == RS_NOTINSERVICE)
code:					 /* deactivate with underlying device */
code:					deactivate_${vroutine}_row(StorageTmp);
code:				break;
code:			case RS_NOTINSERVICE:
code:				if (StorageTmp->$name == RS_ACTIVE)
code:					 /* activate with underlying device */
code:					activate_${vroutine}_row(StorageTmp);
code:				break;
code:			case RS_DESTROY:
code:				break;
code:			}
code:			 /* fall through */
code:		case FREE:
code:			 /* Release any resources that have been allocated */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				 /* creation */
code:				if (StorageNew) {
code:					${vroutine}_del(StorageNew);
code:					${vroutine}_destroy(&StorageNew);
code:				}
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				if ((StorageOld = StorageTmp->${vroutine}_old) == NULL)
code:					break;
code:				if (--StorageTmp->${vroutine}_rsvs == 0)
code:					${vroutine}_destroy(&StorageTmp->${vroutine}_old);
code:				break;
code:			case RS_DESTROY:
code:				 /* row deletion, so add it again */
code:				if (StorageDel)
code:					${vroutine}_add(StorageDel);
code:				break;
code:			}
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
