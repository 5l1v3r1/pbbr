/*****************************************************************************

 @(#) src/snmp/lldpmib.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/lldpmib.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "lldpMIB.h"
#define MASTER 1
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "lldpMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int lldpMIB_refresh = 1;
volatile int lldpPortConfigTable_refresh = 1;
volatile int lldpConfigManAddrTable_refresh = 1;
volatile int lldpStatsTxPortTable_refresh = 1;
volatile int lldpStatsRxPortTable_refresh = 1;
volatile int lldpLocPortTable_refresh = 1;
volatile int lldpLocManAddrTable_refresh = 1;
volatile int lldpRemTable_refresh = 1;
volatile int lldpRemManAddrTable_refresh = 1;
volatile int lldpRemUnknownTLVTable_refresh = 1;
volatile int lldpRemOrgDefInfoTable_refresh = 1;

/*
 * lldpMIB_variables_oid: object identifier for lldpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid lldpMIB_variables_oid[6] = { 1, 0, 8802, 1, 1, 2 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid lldpRemTablesChange_oid[9] = { 1, 0, 8802, 1, 1, 2, 0, 0, 1 };

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid lldpCompliance_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 1, 1 };
oid lldpConfigGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 1 };
oid lldpConfigRxGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 2 };
oid lldpConfigTxGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 3 };
oid lldpStatsRxGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 4 };
oid lldpStatsTxGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 5 };
oid lldpLocSysGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 6 };
oid lldpRemSysGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 7 };
oid lldpNotificationsGroup_oid[9] = { 1, 0, 8802, 1, 1, 2, 2, 2, 8 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 lldpMIB_variables: tree for lldpMIB
 * This variable defines function callbacks and type return information for the lldpMIB mib section
 */
struct variable7 lldpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   LLDPMESSAGETXINTERVAL  1
	{(u_char) LLDPMESSAGETXINTERVAL, ASN_INTEGER, RWRITE, var_lldpMIB, 3, {1, 1, 1}},
#define   LLDPMESSAGETXHOLDMULTIPLIER  2
	{(u_char) LLDPMESSAGETXHOLDMULTIPLIER, ASN_INTEGER, RWRITE, var_lldpMIB, 3, {1, 1, 2}},
#define   LLDPREINITDELAY       3
	{(u_char) LLDPREINITDELAY, ASN_INTEGER, RWRITE, var_lldpMIB, 3, {1, 1, 3}},
#define   LLDPTXDELAY           4
	{(u_char) LLDPTXDELAY, ASN_INTEGER, RWRITE, var_lldpMIB, 3, {1, 1, 4}},
#define   LLDPNOTIFICATIONINTERVAL  5
	{(u_char) LLDPNOTIFICATIONINTERVAL, ASN_INTEGER, RWRITE, var_lldpMIB, 3, {1, 1, 5}},
#define   LLDPPORTCONFIGADMINSTATUS  6
	{(u_char) LLDPPORTCONFIGADMINSTATUS, ASN_INTEGER, RWRITE, var_lldpPortConfigTable, 5, {1, 1, 6, 1, 2}},
#define   LLDPPORTCONFIGNOTIFICATIONENABLE  7
	{(u_char) LLDPPORTCONFIGNOTIFICATIONENABLE, ASN_INTEGER, RWRITE, var_lldpPortConfigTable, 5, {1, 1, 6, 1, 3}},
#define   LLDPPORTCONFIGTLVSTXENABLE  8
	{(u_char) LLDPPORTCONFIGTLVSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpPortConfigTable, 5, {1, 1, 6, 1, 4}},
#define   LLDPCONFIGMANADDRPORTSTXENABLE  9
	{(u_char) LLDPCONFIGMANADDRPORTSTXENABLE, ASN_OCTET_STR, RWRITE, var_lldpConfigManAddrTable, 5, {1, 1, 7, 1, 1}},
#define   LLDPSTATSREMTABLESLASTCHANGETIME  10
	{(u_char) LLDPSTATSREMTABLESLASTCHANGETIME, ASN_TIMETICKS, RONLY, var_lldpMIB, 3, {1, 2, 1}},
#define   LLDPSTATSREMTABLESINSERTS  11
	{(u_char) LLDPSTATSREMTABLESINSERTS, ASN_GAUGE, RONLY, var_lldpMIB, 3, {1, 2, 2}},
#define   LLDPSTATSREMTABLESDELETES  12
	{(u_char) LLDPSTATSREMTABLESDELETES, ASN_GAUGE, RONLY, var_lldpMIB, 3, {1, 2, 3}},
#define   LLDPSTATSREMTABLESDROPS  13
	{(u_char) LLDPSTATSREMTABLESDROPS, ASN_GAUGE, RONLY, var_lldpMIB, 3, {1, 2, 4}},
#define   LLDPSTATSREMTABLESAGEOUTS  14
	{(u_char) LLDPSTATSREMTABLESAGEOUTS, ASN_GAUGE, RONLY, var_lldpMIB, 3, {1, 2, 5}},
#define   LLDPSTATSTXPORTFRAMESTOTAL  15
	{(u_char) LLDPSTATSTXPORTFRAMESTOTAL, ASN_COUNTER, RONLY, var_lldpStatsTxPortTable, 5, {1, 2, 6, 1, 2}},
#define   LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL  16
	{(u_char) LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 2}},
#define   LLDPSTATSRXPORTFRAMESERRORS  17
	{(u_char) LLDPSTATSRXPORTFRAMESERRORS, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 3}},
#define   LLDPSTATSRXPORTFRAMESTOTAL  18
	{(u_char) LLDPSTATSRXPORTFRAMESTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 4}},
#define   LLDPSTATSRXPORTTLVSDISCARDEDTOTAL  19
	{(u_char) LLDPSTATSRXPORTTLVSDISCARDEDTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 5}},
#define   LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL  20
	{(u_char) LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL, ASN_COUNTER, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 6}},
#define   LLDPSTATSRXPORTAGEOUTSTOTAL  21
	{(u_char) LLDPSTATSRXPORTAGEOUTSTOTAL, ASN_GAUGE, RONLY, var_lldpStatsRxPortTable, 5, {1, 2, 7, 1, 7}},
#define   LLDPLOCCHASSISIDSUBTYPE  22
	{(u_char) LLDPLOCCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpMIB, 3, {1, 3, 1}},
#define   LLDPLOCCHASSISID      23
	{(u_char) LLDPLOCCHASSISID, ASN_OCTET_STR, RONLY, var_lldpMIB, 3, {1, 3, 2}},
#define   LLDPLOCSYSNAME        24
	{(u_char) LLDPLOCSYSNAME, ASN_OCTET_STR, RONLY, var_lldpMIB, 3, {1, 3, 3}},
#define   LLDPLOCSYSDESC        25
	{(u_char) LLDPLOCSYSDESC, ASN_OCTET_STR, RONLY, var_lldpMIB, 3, {1, 3, 4}},
#define   LLDPLOCSYSCAPSUPPORTED  26
	{(u_char) LLDPLOCSYSCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpMIB, 3, {1, 3, 5}},
#define   LLDPLOCSYSCAPENABLED  27
	{(u_char) LLDPLOCSYSCAPENABLED, ASN_OCTET_STR, RONLY, var_lldpMIB, 3, {1, 3, 6}},
#define   LLDPLOCPORTIDSUBTYPE  28
	{(u_char) LLDPLOCPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocPortTable, 5, {1, 3, 7, 1, 2}},
#define   LLDPLOCPORTID         29
	{(u_char) LLDPLOCPORTID, ASN_OCTET_STR, RONLY, var_lldpLocPortTable, 5, {1, 3, 7, 1, 3}},
#define   LLDPLOCPORTDESC       30
	{(u_char) LLDPLOCPORTDESC, ASN_OCTET_STR, RONLY, var_lldpLocPortTable, 5, {1, 3, 7, 1, 4}},
#define   LLDPLOCMANADDRLEN     31
	{(u_char) LLDPLOCMANADDRLEN, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 5, {1, 3, 8, 1, 3}},
#define   LLDPLOCMANADDRIFSUBTYPE  32
	{(u_char) LLDPLOCMANADDRIFSUBTYPE, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 5, {1, 3, 8, 1, 4}},
#define   LLDPLOCMANADDRIFID    33
	{(u_char) LLDPLOCMANADDRIFID, ASN_INTEGER, RONLY, var_lldpLocManAddrTable, 5, {1, 3, 8, 1, 5}},
#define   LLDPLOCMANADDROID     34
	{(u_char) LLDPLOCMANADDROID, ASN_OBJECT_ID, RONLY, var_lldpLocManAddrTable, 5, {1, 3, 8, 1, 6}},
#define   LLDPREMCHASSISIDSUBTYPE  35
	{(u_char) LLDPREMCHASSISIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 4}},
#define   LLDPREMCHASSISID      36
	{(u_char) LLDPREMCHASSISID, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 5}},
#define   LLDPREMPORTIDSUBTYPE  37
	{(u_char) LLDPREMPORTIDSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 6}},
#define   LLDPREMPORTID         38
	{(u_char) LLDPREMPORTID, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 7}},
#define   LLDPREMPORTDESC       39
	{(u_char) LLDPREMPORTDESC, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 8}},
#define   LLDPREMSYSNAME        40
	{(u_char) LLDPREMSYSNAME, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 9}},
#define   LLDPREMSYSDESC        41
	{(u_char) LLDPREMSYSDESC, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 10}},
#define   LLDPREMSYSCAPSUPPORTED  42
	{(u_char) LLDPREMSYSCAPSUPPORTED, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 11}},
#define   LLDPREMSYSCAPENABLED  43
	{(u_char) LLDPREMSYSCAPENABLED, ASN_OCTET_STR, RONLY, var_lldpRemTable, 5, {1, 4, 1, 1, 12}},
#define   LLDPREMMANADDRIFSUBTYPE  44
	{(u_char) LLDPREMMANADDRIFSUBTYPE, ASN_INTEGER, RONLY, var_lldpRemManAddrTable, 5, {1, 4, 2, 1, 3}},
#define   LLDPREMMANADDRIFID    45
	{(u_char) LLDPREMMANADDRIFID, ASN_INTEGER, RONLY, var_lldpRemManAddrTable, 5, {1, 4, 2, 1, 4}},
#define   LLDPREMMANADDROID     46
	{(u_char) LLDPREMMANADDROID, ASN_OBJECT_ID, RONLY, var_lldpRemManAddrTable, 5, {1, 4, 2, 1, 5}},
#define   LLDPREMUNKNOWNTLVINFO  47
	{(u_char) LLDPREMUNKNOWNTLVINFO, ASN_OCTET_STR, RONLY, var_lldpRemUnknownTLVTable, 5, {1, 4, 3, 1, 2}},
#define   LLDPREMORGDEFINFO     48
	{(u_char) LLDPREMORGDEFINFO, ASN_OCTET_STR, RONLY, var_lldpRemOrgDefInfoTable, 5, {1, 4, 4, 1, 4}},
};

/* (L = length of the oidsuffix) */
struct lldpMIB_data *lldpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *lldpPortConfigTableStorage = NULL;
struct header_complex_index *lldpConfigManAddrTableStorage = NULL;
struct header_complex_index *lldpStatsTxPortTableStorage = NULL;
struct header_complex_index *lldpStatsRxPortTableStorage = NULL;
struct header_complex_index *lldpLocPortTableStorage = NULL;
struct header_complex_index *lldpLocManAddrTableStorage = NULL;
struct header_complex_index *lldpRemTableStorage = NULL;
struct header_complex_index *lldpRemManAddrTableStorage = NULL;
struct header_complex_index *lldpRemUnknownTLVTableStorage = NULL;
struct header_complex_index *lldpRemOrgDefInfoTableStorage = NULL;

void (*lldpMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void lldpMIB_loop_handler(int);
void lldpMIB_fd_handler(int, void *);

/**
 * @fn void init_lldpMIB(void)
 * @brief lldpMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (lldpMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_lldpMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("lldpMIB", "init_lldpMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("lldpMIB", lldpMIB_variables, variable7, lldpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_lldpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("lldpMIB", parse_lldpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpPortConfigTable", parse_lldpPortConfigTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpConfigManAddrTable", parse_lldpConfigManAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpStatsTxPortTable", parse_lldpStatsTxPortTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpStatsRxPortTable", parse_lldpStatsRxPortTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpLocPortTable", parse_lldpLocPortTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpLocManAddrTable", parse_lldpLocManAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpRemTable", parse_lldpRemTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpRemManAddrTable", parse_lldpRemManAddrTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpRemUnknownTLVTable", parse_lldpRemUnknownTLVTable, NULL, "HELP STRING");
	snmpd_register_config_handler("lldpRemOrgDefInfoTable", parse_lldpRemOrgDefInfoTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpPortConfigTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpConfigManAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpStatsTxPortTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpStatsRxPortTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpLocPortTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpLocManAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpRemTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpRemManAddrTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpRemUnknownTLVTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_lldpRemOrgDefInfoTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, lldpMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, lldpMIB_fd_handler, (void *) 1);
	}
	lldpMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &lldpMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/**
 * @fn void deinit_lldpMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (lldpMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_lldpMIB(void)
{
	DEBUGMSGTL(("lldpMIB", "deinit_lldpMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = lldpMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(lldpMIB_variables_oid, sizeof(lldpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("lldpMIB");
	snmpd_unregister_config_handler("lldpPortConfigTable");
	snmpd_unregister_config_handler("lldpConfigManAddrTable");
	snmpd_unregister_config_handler("lldpStatsTxPortTable");
	snmpd_unregister_config_handler("lldpStatsRxPortTable");
	snmpd_unregister_config_handler("lldpLocPortTable");
	snmpd_unregister_config_handler("lldpLocManAddrTable");
	snmpd_unregister_config_handler("lldpRemTable");
	snmpd_unregister_config_handler("lldpRemManAddrTable");
	snmpd_unregister_config_handler("lldpRemUnknownTLVTable");
	snmpd_unregister_config_handler("lldpRemOrgDefInfoTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

int
term_lldpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("lldpMIB", "term_lldpMIB: terminating...  "));
	deinit_lldpMIB();
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct lldpMIB_data *lldpMIB_create(void)
 * @brief create a fresh data structure representing scalars in lldpMIB.
 *
 * Creates a new lldpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in lldpMIB.
 */
struct lldpMIB_data *
lldpMIB_create(void)
{
	struct lldpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(lldpMIB_data);

	DEBUGMSGTL(("lldpMIB", "lldpMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->lldpMessageTxInterval = 30;
		StorageNew->lldpMessageTxHoldMultiplier = 4;
		StorageNew->lldpReinitDelay = 2;
		StorageNew->lldpTxDelay = 2;
		StorageNew->lldpNotificationInterval = 5;
		StorageNew->lldpStatsRemTablesLastChangeTime = 0;
		StorageNew->lldpStatsRemTablesInserts = 0;
		StorageNew->lldpStatsRemTablesDeletes = 0;
		StorageNew->lldpStatsRemTablesDrops = 0;
		StorageNew->lldpStatsRemTablesAgeouts = 0;
		StorageNew->lldpLocChassisIdSubtype = 0;
		if ((StorageNew->lldpLocChassisId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocChassisIdLen = 0;
		StorageNew->lldpLocChassisId[StorageNew->lldpLocChassisIdLen] = 0;
		if ((StorageNew->lldpLocSysName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocSysNameLen = 0;
		StorageNew->lldpLocSysName[StorageNew->lldpLocSysNameLen] = 0;
		if ((StorageNew->lldpLocSysDesc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocSysDescLen = 0;
		StorageNew->lldpLocSysDesc[StorageNew->lldpLocSysDescLen] = 0;
		if (memdup((u_char **) &StorageNew->lldpLocSysCapSupported, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->lldpLocSysCapSupportedLen = 1;
		if (memdup((u_char **) &StorageNew->lldpLocSysCapEnabled, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->lldpLocSysCapEnabledLen = 1;

	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpMIB_data *lldpMIB_duplicate(struct lldpMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct lldpMIB_data *
lldpMIB_duplicate(struct lldpMIB_data *thedata)
{
	struct lldpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(lldpMIB_data);

	DEBUGMSGTL(("lldpMIB", "lldpMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		StorageNew->lldpMessageTxInterval = thedata->lldpMessageTxInterval;
		StorageNew->lldpMessageTxHoldMultiplier = thedata->lldpMessageTxHoldMultiplier;
		StorageNew->lldpReinitDelay = thedata->lldpReinitDelay;
		StorageNew->lldpTxDelay = thedata->lldpTxDelay;
		StorageNew->lldpNotificationInterval = thedata->lldpNotificationInterval;
		StorageNew->lldpStatsRemTablesLastChangeTime = thedata->lldpStatsRemTablesLastChangeTime;
		StorageNew->lldpStatsRemTablesInserts = thedata->lldpStatsRemTablesInserts;
		StorageNew->lldpStatsRemTablesDeletes = thedata->lldpStatsRemTablesDeletes;
		StorageNew->lldpStatsRemTablesDrops = thedata->lldpStatsRemTablesDrops;
		StorageNew->lldpStatsRemTablesAgeouts = thedata->lldpStatsRemTablesAgeouts;
		StorageNew->lldpLocChassisIdSubtype = thedata->lldpLocChassisIdSubtype;
		if (!(StorageNew->lldpLocChassisId = malloc(thedata->lldpLocChassisIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocChassisId, thedata->lldpLocChassisId, thedata->lldpLocChassisIdLen);
		StorageNew->lldpLocChassisIdLen = thedata->lldpLocChassisIdLen;
		StorageNew->lldpLocChassisId[StorageNew->lldpLocChassisIdLen] = 0;
		if (!(StorageNew->lldpLocSysName = malloc(thedata->lldpLocSysNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocSysName, thedata->lldpLocSysName, thedata->lldpLocSysNameLen);
		StorageNew->lldpLocSysNameLen = thedata->lldpLocSysNameLen;
		StorageNew->lldpLocSysName[StorageNew->lldpLocSysNameLen] = 0;
		if (!(StorageNew->lldpLocSysDesc = malloc(thedata->lldpLocSysDescLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocSysDesc, thedata->lldpLocSysDesc, thedata->lldpLocSysDescLen);
		StorageNew->lldpLocSysDescLen = thedata->lldpLocSysDescLen;
		StorageNew->lldpLocSysDesc[StorageNew->lldpLocSysDescLen] = 0;
		if (!(StorageNew->lldpLocSysCapSupported = malloc(thedata->lldpLocSysCapSupportedLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocSysCapSupported, thedata->lldpLocSysCapSupported, thedata->lldpLocSysCapSupportedLen);
		StorageNew->lldpLocSysCapSupportedLen = thedata->lldpLocSysCapSupportedLen;
		StorageNew->lldpLocSysCapSupported[StorageNew->lldpLocSysCapSupportedLen] = 0;
		if (!(StorageNew->lldpLocSysCapEnabled = malloc(thedata->lldpLocSysCapEnabledLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocSysCapEnabled, thedata->lldpLocSysCapEnabled, thedata->lldpLocSysCapEnabledLen);
		StorageNew->lldpLocSysCapEnabledLen = thedata->lldpLocSysCapEnabledLen;
		StorageNew->lldpLocSysCapEnabled[StorageNew->lldpLocSysCapEnabledLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpMIB_destroy(struct lldpMIB_data **thedata)
 * @param thedata pointer to the data structure in lldpMIB.
 * @brief delete a scalars structure from lldpMIB.
 *
 * Frees scalars that were previously removed from lldpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpMIB_destroy(struct lldpMIB_data **thedata)
{
	struct lldpMIB_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpLocChassisId);
		StorageDel->lldpLocChassisIdLen = 0;
		SNMP_FREE(StorageDel->lldpLocSysName);
		StorageDel->lldpLocSysNameLen = 0;
		SNMP_FREE(StorageDel->lldpLocSysDesc);
		StorageDel->lldpLocSysDescLen = 0;
		SNMP_FREE(StorageDel->lldpLocSysCapSupported);
		StorageDel->lldpLocSysCapSupportedLen = 0;
		SNMP_FREE(StorageDel->lldpLocSysCapEnabled);
		StorageDel->lldpLocSysCapEnabledLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpMIB_add(struct lldpMIB_data *thedata)
 * @param thedata the structure representing lldpMIB scalars.
 * @brief adds node to the lldpMIB scalar data set.
 *
 * Adds a scalar structure to the lldpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
lldpMIB_add(struct lldpMIB_data *thedata)
{
	DEBUGMSGTL(("lldpMIB", "lldpMIB_add: adding data...  "));
	if (thedata)
		lldpMIBStorage = thedata;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_lldpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpMIB_data *StorageTmp = lldpMIB_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpMessageTxInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpMessageTxHoldMultiplier, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpReinitDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpTxDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpNotificationInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lldpStatsRemTablesLastChangeTime, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lldpStatsRemTablesInserts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lldpStatsRemTablesDeletes, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lldpStatsRemTablesDrops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lldpStatsRemTablesAgeouts, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocChassisIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpLocChassisId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocChassisId, &StorageTmp->lldpLocChassisIdLen);
	if (StorageTmp->lldpLocChassisId == NULL) {
		config_perror("invalid specification for lldpLocChassisId");
		return;
	}
	SNMP_FREE(StorageTmp->lldpLocSysName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocSysName, &StorageTmp->lldpLocSysNameLen);
	if (StorageTmp->lldpLocSysName == NULL) {
		config_perror("invalid specification for lldpLocSysName");
		return;
	}
	SNMP_FREE(StorageTmp->lldpLocSysDesc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocSysDesc, &StorageTmp->lldpLocSysDescLen);
	if (StorageTmp->lldpLocSysDesc == NULL) {
		config_perror("invalid specification for lldpLocSysDesc");
		return;
	}
	SNMP_FREE(StorageTmp->lldpLocSysCapSupported);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocSysCapSupported, &StorageTmp->lldpLocSysCapSupportedLen);
	if (StorageTmp->lldpLocSysCapSupported == NULL) {
		config_perror("invalid specification for lldpLocSysCapSupported");
		return;
	}
	SNMP_FREE(StorageTmp->lldpLocSysCapEnabled);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocSysCapEnabled, &StorageTmp->lldpLocSysCapEnabledLen);
	if (StorageTmp->lldpLocSysCapEnabled == NULL) {
		config_perror("invalid specification for lldpLocSysCapEnabled");
		return;
	}
	lldpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_lldpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpMIB_data *StorageTmp;

	DEBUGMSGTL(("lldpMIB", "store_lldpMIB: storing data...  "));
	refresh_lldpMIB(1);
	if ((StorageTmp = lldpMIBStorage) == NULL) {
		DEBUGMSGTL(("lldpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "lldpMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpMessageTxInterval, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpMessageTxHoldMultiplier, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpReinitDelay, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpTxDelay, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpNotificationInterval, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lldpStatsRemTablesLastChangeTime, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lldpStatsRemTablesInserts, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lldpStatsRemTablesDeletes, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lldpStatsRemTablesDrops, &tmpsize);
		cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lldpStatsRemTablesAgeouts, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocChassisIdSubtype, &tmpsize);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocChassisId, &StorageTmp->lldpLocChassisIdLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocSysName, &StorageTmp->lldpLocSysNameLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocSysDesc, &StorageTmp->lldpLocSysDescLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocSysCapSupported, &StorageTmp->lldpLocSysCapSupportedLen);
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocSysCapEnabled, &StorageTmp->lldpLocSysCapEnabledLen);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_lldpMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_lldpMIB(struct 
 * @fn void revert_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_lldpMIB(struct lldpMIB_data *StorageTmp, struct lldpMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of lldpMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_lldpMIB(int force)
{
	if (lldpMIBStorage == NULL) {
		struct lldpMIB_data *StorageNew;

		if ((StorageNew = lldpMIB_create()) == NULL)
			return;
		lldpMIBStorage = StorageNew;
		lldpMIB_refresh = 1;
	}
	if (!force && lldpMIB_refresh == 0)
		return;
	DEBUGMSGTL(("lldpMIB", "refresh_lldpMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	lldpMIB_refresh = 0;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/**
 * @fn u_char * var_lldpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in lldpMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_lldpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_lldpMIB(0);
	if ((StorageTmp = lldpMIBStorage) == NULL) {
		DEBUGMSGTL(("lldpMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPMESSAGETXINTERVAL:	/* ReadWrite */
		*write_method = write_lldpMessageTxInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpMessageTxInterval);
		rval = (u_char *) &StorageTmp->lldpMessageTxInterval;
		break;
	case (u_char) LLDPMESSAGETXHOLDMULTIPLIER:	/* ReadWrite */
		*write_method = write_lldpMessageTxHoldMultiplier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpMessageTxHoldMultiplier);
		rval = (u_char *) &StorageTmp->lldpMessageTxHoldMultiplier;
		break;
	case (u_char) LLDPREINITDELAY:	/* ReadWrite */
		*write_method = write_lldpReinitDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpReinitDelay);
		rval = (u_char *) &StorageTmp->lldpReinitDelay;
		break;
	case (u_char) LLDPTXDELAY:	/* ReadWrite */
		*write_method = write_lldpTxDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpTxDelay);
		rval = (u_char *) &StorageTmp->lldpTxDelay;
		break;
	case (u_char) LLDPNOTIFICATIONINTERVAL:	/* ReadWrite */
		*write_method = write_lldpNotificationInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpNotificationInterval);
		rval = (u_char *) &StorageTmp->lldpNotificationInterval;
		break;
	case (u_char) LLDPSTATSREMTABLESLASTCHANGETIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRemTablesLastChangeTime);
		rval = (u_char *) &StorageTmp->lldpStatsRemTablesLastChangeTime;
		break;
	case (u_char) LLDPSTATSREMTABLESINSERTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRemTablesInserts);
		rval = (u_char *) &StorageTmp->lldpStatsRemTablesInserts;
		break;
	case (u_char) LLDPSTATSREMTABLESDELETES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRemTablesDeletes);
		rval = (u_char *) &StorageTmp->lldpStatsRemTablesDeletes;
		break;
	case (u_char) LLDPSTATSREMTABLESDROPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRemTablesDrops);
		rval = (u_char *) &StorageTmp->lldpStatsRemTablesDrops;
		break;
	case (u_char) LLDPSTATSREMTABLESAGEOUTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRemTablesAgeouts);
		rval = (u_char *) &StorageTmp->lldpStatsRemTablesAgeouts;
		break;
	case (u_char) LLDPLOCCHASSISIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpLocChassisIdSubtype);
		rval = (u_char *) &StorageTmp->lldpLocChassisIdSubtype;
		break;
	case (u_char) LLDPLOCCHASSISID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocChassisIdLen;
		rval = (u_char *) StorageTmp->lldpLocChassisId;
		break;
	case (u_char) LLDPLOCSYSNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocSysNameLen;
		rval = (u_char *) StorageTmp->lldpLocSysName;
		break;
	case (u_char) LLDPLOCSYSDESC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocSysDescLen;
		rval = (u_char *) StorageTmp->lldpLocSysDesc;
		break;
	case (u_char) LLDPLOCSYSCAPSUPPORTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocSysCapSupportedLen;
		rval = (u_char *) StorageTmp->lldpLocSysCapSupported;
		break;
	case (u_char) LLDPLOCSYSCAPENABLED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocSysCapEnabledLen;
		rval = (u_char *) StorageTmp->lldpLocSysCapEnabled;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("lldpMIB", "found.\n"));
	else
		DEBUGMSGTL(("lldpMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct lldpPortConfigTable_data *lldpPortConfigTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpPortConfigTable table.
 *
 * Creates a new lldpPortConfigTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpPortConfigTable_data *
lldpPortConfigTable_create(void)
{
	struct lldpPortConfigTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpPortConfigTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpPortConfigTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpPortConfigAdminStatus = LLDPPORTCONFIGADMINSTATUS_TXANDRX;
		StorageNew->lldpPortConfigNotificationEnable = TV_FALSE;
		if (memdup((u_char **) &StorageNew->lldpPortConfigTLVsTxEnable, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->lldpPortConfigTLVsTxEnableLen = 1;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpPortConfigTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpPortConfigTable_data *lldpPortConfigTable_duplicate(struct lldpPortConfigTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpPortConfigTable_data *
lldpPortConfigTable_duplicate(struct lldpPortConfigTable_data *thedata)
{
	struct lldpPortConfigTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpPortConfigTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpPortConfigTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpPortConfigTable_id = thedata->lldpPortConfigTable_id;
		StorageNew->lldpPortConfigPortNum = thedata->lldpPortConfigPortNum;
		StorageNew->lldpPortConfigAdminStatus = thedata->lldpPortConfigAdminStatus;
		StorageNew->lldpPortConfigNotificationEnable = thedata->lldpPortConfigNotificationEnable;
		if (!(StorageNew->lldpPortConfigTLVsTxEnable = malloc(thedata->lldpPortConfigTLVsTxEnableLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpPortConfigTLVsTxEnable, thedata->lldpPortConfigTLVsTxEnable, thedata->lldpPortConfigTLVsTxEnableLen);
		StorageNew->lldpPortConfigTLVsTxEnableLen = thedata->lldpPortConfigTLVsTxEnableLen;
		StorageNew->lldpPortConfigTLVsTxEnable[StorageNew->lldpPortConfigTLVsTxEnableLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpPortConfigTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpPortConfigTable_destroy(struct lldpPortConfigTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpPortConfigTable_destroy(struct lldpPortConfigTable_data **thedata)
{
	struct lldpPortConfigTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpPortConfigTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpPortConfigTLVsTxEnable);
		StorageDel->lldpPortConfigTLVsTxEnableLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpPortConfigTable_add(struct lldpPortConfigTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpPortConfigTable table data set.
 *
 * Adds a table row structure to the lldpPortConfigTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpPortConfigTable_add(struct lldpPortConfigTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpPortConfigTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpPortConfigPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpPortConfigPortNum, sizeof(thedata->lldpPortConfigPortNum));
		header_complex_add_data(&lldpPortConfigTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpPortConfigTable_del(struct lldpPortConfigTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpPortConfigTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpPortConfigTable_del(struct lldpPortConfigTable_data *thedata)
{
	struct lldpPortConfigTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpPortConfigTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpPortConfigTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpPortConfigTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpPortConfigTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpPortConfigTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpPortConfigTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpPortConfigTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpPortConfigTable_data *StorageTmp = lldpPortConfigTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpPortConfigTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpPortConfigPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpPortConfigAdminStatus, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpPortConfigNotificationEnable, &tmpsize);
	SNMP_FREE(StorageTmp->lldpPortConfigTLVsTxEnable);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpPortConfigTLVsTxEnable, &StorageTmp->lldpPortConfigTLVsTxEnableLen);
	if (StorageTmp->lldpPortConfigTLVsTxEnable == NULL) {
		config_perror("invalid specification for lldpPortConfigTLVsTxEnable");
		return;
	}
	lldpPortConfigTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpPortConfigTable(): store configuraiton file for lldpPortConfigTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpPortConfigTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpPortConfigTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpPortConfigTable: storing data...  "));
	refresh_lldpPortConfigTable(1);
	(void) tmpsize;
	for (hcindex = lldpPortConfigTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpPortConfigTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpPortConfigTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpPortConfigPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpPortConfigAdminStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpPortConfigNotificationEnable, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpPortConfigTLVsTxEnable, &StorageTmp->lldpPortConfigTLVsTxEnableLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpConfigManAddrTable_data *lldpConfigManAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpConfigManAddrTable table.
 *
 * Creates a new lldpConfigManAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpConfigManAddrTable_data *
lldpConfigManAddrTable_create(void)
{
	struct lldpConfigManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpConfigManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpConfigManAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpLocManAddrSubtype = 0;
		if ((StorageNew->lldpLocManAddr = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocManAddrLen = 0;
		StorageNew->lldpLocManAddr[StorageNew->lldpLocManAddrLen] = 0;
		if ((StorageNew->lldpConfigManAddrPortsTxEnable = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->lldpConfigManAddrPortsTxEnableLen = strlen("");
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpConfigManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpConfigManAddrTable_data *lldpConfigManAddrTable_duplicate(struct lldpConfigManAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpConfigManAddrTable_data *
lldpConfigManAddrTable_duplicate(struct lldpConfigManAddrTable_data *thedata)
{
	struct lldpConfigManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpConfigManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpConfigManAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpConfigManAddrTable_id = thedata->lldpConfigManAddrTable_id;
		StorageNew->lldpLocManAddrSubtype = thedata->lldpLocManAddrSubtype;
		if (!(StorageNew->lldpLocManAddr = malloc(thedata->lldpLocManAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocManAddr, thedata->lldpLocManAddr, thedata->lldpLocManAddrLen);
		StorageNew->lldpLocManAddrLen = thedata->lldpLocManAddrLen;
		StorageNew->lldpLocManAddr[StorageNew->lldpLocManAddrLen] = 0;
		if (!(StorageNew->lldpConfigManAddrPortsTxEnable = malloc(thedata->lldpConfigManAddrPortsTxEnableLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpConfigManAddrPortsTxEnable, thedata->lldpConfigManAddrPortsTxEnable, thedata->lldpConfigManAddrPortsTxEnableLen);
		StorageNew->lldpConfigManAddrPortsTxEnableLen = thedata->lldpConfigManAddrPortsTxEnableLen;
		StorageNew->lldpConfigManAddrPortsTxEnable[StorageNew->lldpConfigManAddrPortsTxEnableLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpConfigManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpConfigManAddrTable_destroy(struct lldpConfigManAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpConfigManAddrTable_destroy(struct lldpConfigManAddrTable_data **thedata)
{
	struct lldpConfigManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpConfigManAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpLocManAddr);
		StorageDel->lldpLocManAddrLen = 0;
		SNMP_FREE(StorageDel->lldpConfigManAddrPortsTxEnable);
		StorageDel->lldpConfigManAddrPortsTxEnableLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpConfigManAddrTable_add(struct lldpConfigManAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpConfigManAddrTable table data set.
 *
 * Adds a table row structure to the lldpConfigManAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpConfigManAddrTable_add(struct lldpConfigManAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpConfigManAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpLocManAddrSubtype */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpLocManAddrSubtype, sizeof(thedata->lldpLocManAddrSubtype));
		/* lldpLocManAddr */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lldpLocManAddr, thedata->lldpLocManAddrLen);
		header_complex_add_data(&lldpConfigManAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpConfigManAddrTable_del(struct lldpConfigManAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpConfigManAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpConfigManAddrTable_del(struct lldpConfigManAddrTable_data *thedata)
{
	struct lldpConfigManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpConfigManAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpConfigManAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpConfigManAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpConfigManAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpConfigManAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpConfigManAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpConfigManAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpConfigManAddrTable_data *StorageTmp = lldpConfigManAddrTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpConfigManAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocManAddrSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpLocManAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocManAddr, &StorageTmp->lldpLocManAddrLen);
	if (StorageTmp->lldpLocManAddr == NULL) {
		config_perror("invalid specification for lldpLocManAddr");
		return;
	}
	SNMP_FREE(StorageTmp->lldpConfigManAddrPortsTxEnable);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpConfigManAddrPortsTxEnable, &StorageTmp->lldpConfigManAddrPortsTxEnableLen);
	if (StorageTmp->lldpConfigManAddrPortsTxEnable == NULL) {
		config_perror("invalid specification for lldpConfigManAddrPortsTxEnable");
		return;
	}
	lldpConfigManAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpConfigManAddrTable(): store configuraiton file for lldpConfigManAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpConfigManAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpConfigManAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpConfigManAddrTable: storing data...  "));
	refresh_lldpConfigManAddrTable(1);
	(void) tmpsize;
	for (hcindex = lldpConfigManAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpConfigManAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpConfigManAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocManAddrSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocManAddr, &StorageTmp->lldpLocManAddrLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpConfigManAddrPortsTxEnable, &StorageTmp->lldpConfigManAddrPortsTxEnableLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpStatsTxPortTable_data *lldpStatsTxPortTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpStatsTxPortTable table.
 *
 * Creates a new lldpStatsTxPortTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpStatsTxPortTable_data *
lldpStatsTxPortTable_create(void)
{
	struct lldpStatsTxPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpStatsTxPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpStatsTxPortTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpStatsTxPortFramesTotal = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpStatsTxPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpStatsTxPortTable_data *lldpStatsTxPortTable_duplicate(struct lldpStatsTxPortTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpStatsTxPortTable_data *
lldpStatsTxPortTable_duplicate(struct lldpStatsTxPortTable_data *thedata)
{
	struct lldpStatsTxPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpStatsTxPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpStatsTxPortTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpStatsTxPortTable_id = thedata->lldpStatsTxPortTable_id;
		StorageNew->lldpStatsTxPortNum = thedata->lldpStatsTxPortNum;
		StorageNew->lldpStatsTxPortFramesTotal = thedata->lldpStatsTxPortFramesTotal;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpStatsTxPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpStatsTxPortTable_destroy(struct lldpStatsTxPortTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpStatsTxPortTable_destroy(struct lldpStatsTxPortTable_data **thedata)
{
	struct lldpStatsTxPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpStatsTxPortTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpStatsTxPortTable_add(struct lldpStatsTxPortTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpStatsTxPortTable table data set.
 *
 * Adds a table row structure to the lldpStatsTxPortTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpStatsTxPortTable_add(struct lldpStatsTxPortTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpStatsTxPortTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpStatsTxPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpStatsTxPortNum, sizeof(thedata->lldpStatsTxPortNum));
		header_complex_add_data(&lldpStatsTxPortTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpStatsTxPortTable_del(struct lldpStatsTxPortTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpStatsTxPortTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpStatsTxPortTable_del(struct lldpStatsTxPortTable_data *thedata)
{
	struct lldpStatsTxPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpStatsTxPortTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpStatsTxPortTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpStatsTxPortTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpStatsTxPortTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpStatsTxPortTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpStatsTxPortTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpStatsTxPortTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpStatsTxPortTable_data *StorageTmp = lldpStatsTxPortTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpStatsTxPortTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpStatsTxPortNum, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsTxPortFramesTotal, &tmpsize);
	lldpStatsTxPortTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpStatsTxPortTable(): store configuraiton file for lldpStatsTxPortTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpStatsTxPortTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpStatsTxPortTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpStatsTxPortTable: storing data...  "));
	refresh_lldpStatsTxPortTable(1);
	(void) tmpsize;
	for (hcindex = lldpStatsTxPortTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpStatsTxPortTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpStatsTxPortTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpStatsTxPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsTxPortFramesTotal, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpStatsRxPortTable_data *lldpStatsRxPortTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpStatsRxPortTable table.
 *
 * Creates a new lldpStatsRxPortTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpStatsRxPortTable_data *
lldpStatsRxPortTable_create(void)
{
	struct lldpStatsRxPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpStatsRxPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpStatsRxPortTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpStatsRxPortFramesDiscardedTotal = 0;
		StorageNew->lldpStatsRxPortFramesErrors = 0;
		StorageNew->lldpStatsRxPortFramesTotal = 0;
		StorageNew->lldpStatsRxPortTLVsDiscardedTotal = 0;
		StorageNew->lldpStatsRxPortTLVsUnrecognizedTotal = 0;
		StorageNew->lldpStatsRxPortAgeoutsTotal = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpStatsRxPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpStatsRxPortTable_data *lldpStatsRxPortTable_duplicate(struct lldpStatsRxPortTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpStatsRxPortTable_data *
lldpStatsRxPortTable_duplicate(struct lldpStatsRxPortTable_data *thedata)
{
	struct lldpStatsRxPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpStatsRxPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpStatsRxPortTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpStatsRxPortTable_id = thedata->lldpStatsRxPortTable_id;
		StorageNew->lldpStatsRxPortNum = thedata->lldpStatsRxPortNum;
		StorageNew->lldpStatsRxPortFramesDiscardedTotal = thedata->lldpStatsRxPortFramesDiscardedTotal;
		StorageNew->lldpStatsRxPortFramesErrors = thedata->lldpStatsRxPortFramesErrors;
		StorageNew->lldpStatsRxPortFramesTotal = thedata->lldpStatsRxPortFramesTotal;
		StorageNew->lldpStatsRxPortTLVsDiscardedTotal = thedata->lldpStatsRxPortTLVsDiscardedTotal;
		StorageNew->lldpStatsRxPortTLVsUnrecognizedTotal = thedata->lldpStatsRxPortTLVsUnrecognizedTotal;
		StorageNew->lldpStatsRxPortAgeoutsTotal = thedata->lldpStatsRxPortAgeoutsTotal;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpStatsRxPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpStatsRxPortTable_destroy(struct lldpStatsRxPortTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpStatsRxPortTable_destroy(struct lldpStatsRxPortTable_data **thedata)
{
	struct lldpStatsRxPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpStatsRxPortTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpStatsRxPortTable_add(struct lldpStatsRxPortTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpStatsRxPortTable table data set.
 *
 * Adds a table row structure to the lldpStatsRxPortTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpStatsRxPortTable_add(struct lldpStatsRxPortTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpStatsRxPortTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpStatsRxPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpStatsRxPortNum, sizeof(thedata->lldpStatsRxPortNum));
		header_complex_add_data(&lldpStatsRxPortTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpStatsRxPortTable_del(struct lldpStatsRxPortTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpStatsRxPortTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpStatsRxPortTable_del(struct lldpStatsRxPortTable_data *thedata)
{
	struct lldpStatsRxPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpStatsRxPortTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpStatsRxPortTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpStatsRxPortTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpStatsRxPortTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpStatsRxPortTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpStatsRxPortTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpStatsRxPortTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpStatsRxPortTable_data *StorageTmp = lldpStatsRxPortTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpStatsRxPortTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpStatsRxPortNum, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsRxPortFramesDiscardedTotal, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsRxPortFramesErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsRxPortFramesTotal, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsRxPortTLVsDiscardedTotal, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->lldpStatsRxPortTLVsUnrecognizedTotal, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->lldpStatsRxPortAgeoutsTotal, &tmpsize);
	lldpStatsRxPortTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpStatsRxPortTable(): store configuraiton file for lldpStatsRxPortTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpStatsRxPortTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpStatsRxPortTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpStatsRxPortTable: storing data...  "));
	refresh_lldpStatsRxPortTable(1);
	(void) tmpsize;
	for (hcindex = lldpStatsRxPortTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpStatsRxPortTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpStatsRxPortTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpStatsRxPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsRxPortFramesDiscardedTotal, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsRxPortFramesErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsRxPortFramesTotal, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsRxPortTLVsDiscardedTotal, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->lldpStatsRxPortTLVsUnrecognizedTotal, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->lldpStatsRxPortAgeoutsTotal, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpLocPortTable_data *lldpLocPortTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpLocPortTable table.
 *
 * Creates a new lldpLocPortTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpLocPortTable_data *
lldpLocPortTable_create(void)
{
	struct lldpLocPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpLocPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpLocPortTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpLocPortIdSubtype = 0;
		if ((StorageNew->lldpLocPortId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocPortIdLen = 0;
		StorageNew->lldpLocPortId[StorageNew->lldpLocPortIdLen] = 0;
		if ((StorageNew->lldpLocPortDesc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpLocPortDescLen = 0;
		StorageNew->lldpLocPortDesc[StorageNew->lldpLocPortDescLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpLocPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpLocPortTable_data *lldpLocPortTable_duplicate(struct lldpLocPortTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpLocPortTable_data *
lldpLocPortTable_duplicate(struct lldpLocPortTable_data *thedata)
{
	struct lldpLocPortTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpLocPortTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpLocPortTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpLocPortTable_id = thedata->lldpLocPortTable_id;
		StorageNew->lldpLocPortNum = thedata->lldpLocPortNum;
		StorageNew->lldpLocPortIdSubtype = thedata->lldpLocPortIdSubtype;
		if (!(StorageNew->lldpLocPortId = malloc(thedata->lldpLocPortIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocPortId, thedata->lldpLocPortId, thedata->lldpLocPortIdLen);
		StorageNew->lldpLocPortIdLen = thedata->lldpLocPortIdLen;
		StorageNew->lldpLocPortId[StorageNew->lldpLocPortIdLen] = 0;
		if (!(StorageNew->lldpLocPortDesc = malloc(thedata->lldpLocPortDescLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocPortDesc, thedata->lldpLocPortDesc, thedata->lldpLocPortDescLen);
		StorageNew->lldpLocPortDescLen = thedata->lldpLocPortDescLen;
		StorageNew->lldpLocPortDesc[StorageNew->lldpLocPortDescLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpLocPortTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpLocPortTable_destroy(struct lldpLocPortTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpLocPortTable_destroy(struct lldpLocPortTable_data **thedata)
{
	struct lldpLocPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpLocPortTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpLocPortId);
		StorageDel->lldpLocPortIdLen = 0;
		SNMP_FREE(StorageDel->lldpLocPortDesc);
		StorageDel->lldpLocPortDescLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpLocPortTable_add(struct lldpLocPortTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpLocPortTable table data set.
 *
 * Adds a table row structure to the lldpLocPortTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpLocPortTable_add(struct lldpLocPortTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpLocPortTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpLocPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpLocPortNum, sizeof(thedata->lldpLocPortNum));
		header_complex_add_data(&lldpLocPortTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpLocPortTable_del(struct lldpLocPortTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpLocPortTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpLocPortTable_del(struct lldpLocPortTable_data *thedata)
{
	struct lldpLocPortTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpLocPortTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpLocPortTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpLocPortTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpLocPortTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpLocPortTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpLocPortTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpLocPortTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpLocPortTable_data *StorageTmp = lldpLocPortTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpLocPortTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocPortIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpLocPortId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocPortId, &StorageTmp->lldpLocPortIdLen);
	if (StorageTmp->lldpLocPortId == NULL) {
		config_perror("invalid specification for lldpLocPortId");
		return;
	}
	SNMP_FREE(StorageTmp->lldpLocPortDesc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocPortDesc, &StorageTmp->lldpLocPortDescLen);
	if (StorageTmp->lldpLocPortDesc == NULL) {
		config_perror("invalid specification for lldpLocPortDesc");
		return;
	}
	lldpLocPortTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpLocPortTable(): store configuraiton file for lldpLocPortTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpLocPortTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpLocPortTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpLocPortTable: storing data...  "));
	refresh_lldpLocPortTable(1);
	(void) tmpsize;
	for (hcindex = lldpLocPortTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpLocPortTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpLocPortTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocPortIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocPortId, &StorageTmp->lldpLocPortIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocPortDesc, &StorageTmp->lldpLocPortDescLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpLocManAddrTable_data *lldpLocManAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpLocManAddrTable table.
 *
 * Creates a new lldpLocManAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpLocManAddrTable_data *
lldpLocManAddrTable_create(void)
{
	struct lldpLocManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpLocManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpLocManAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpLocManAddrLen = 0;
		StorageNew->lldpLocManAddrIfSubtype = 0;
		StorageNew->lldpLocManAddrIfId = 0;
		if ((StorageNew->lldpLocManAddrOID = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->lldpLocManAddrOIDLen = 2;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpLocManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpLocManAddrTable_data *lldpLocManAddrTable_duplicate(struct lldpLocManAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpLocManAddrTable_data *
lldpLocManAddrTable_duplicate(struct lldpLocManAddrTable_data *thedata)
{
	struct lldpLocManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpLocManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpLocManAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpLocManAddrTable_id = thedata->lldpLocManAddrTable_id;
		StorageNew->lldpLocManAddrSubtype = thedata->lldpLocManAddrSubtype;
		if (!(StorageNew->lldpLocManAddr = malloc(thedata->lldpLocManAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpLocManAddr, thedata->lldpLocManAddr, thedata->lldpLocManAddrLen);
		StorageNew->lldpLocManAddrLen = thedata->lldpLocManAddrLen;
		StorageNew->lldpLocManAddr[StorageNew->lldpLocManAddrLen] = 0;
		StorageNew->lldpLocManAddrLen = thedata->lldpLocManAddrLen;
		StorageNew->lldpLocManAddrIfSubtype = thedata->lldpLocManAddrIfSubtype;
		StorageNew->lldpLocManAddrIfId = thedata->lldpLocManAddrIfId;
		if (!(StorageNew->lldpLocManAddrOID = snmp_duplicate_objid(thedata->lldpLocManAddrOID, thedata->lldpLocManAddrOIDLen / sizeof(oid))))
			goto destroy;
		StorageNew->lldpLocManAddrOIDLen = thedata->lldpLocManAddrOIDLen;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpLocManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpLocManAddrTable_destroy(struct lldpLocManAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpLocManAddrTable_destroy(struct lldpLocManAddrTable_data **thedata)
{
	struct lldpLocManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpLocManAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpLocManAddr);
		StorageDel->lldpLocManAddrLen = 0;
		SNMP_FREE(StorageDel->lldpLocManAddrOID);
		StorageDel->lldpLocManAddrOIDLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpLocManAddrTable_add(struct lldpLocManAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpLocManAddrTable table data set.
 *
 * Adds a table row structure to the lldpLocManAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpLocManAddrTable_add(struct lldpLocManAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpLocManAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpLocManAddrSubtype */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpLocManAddrSubtype, sizeof(thedata->lldpLocManAddrSubtype));
		/* lldpLocManAddr */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lldpLocManAddr, thedata->lldpLocManAddrLen);
		header_complex_add_data(&lldpLocManAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpLocManAddrTable_del(struct lldpLocManAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpLocManAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpLocManAddrTable_del(struct lldpLocManAddrTable_data *thedata)
{
	struct lldpLocManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpLocManAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpLocManAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpLocManAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpLocManAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpLocManAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpLocManAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpLocManAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpLocManAddrTable_data *StorageTmp = lldpLocManAddrTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpLocManAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocManAddrSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpLocManAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpLocManAddr, &StorageTmp->lldpLocManAddrLen);
	if (StorageTmp->lldpLocManAddr == NULL) {
		config_perror("invalid specification for lldpLocManAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocManAddrLen, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocManAddrIfSubtype, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpLocManAddrIfId, &tmpsize);
	SNMP_FREE(StorageTmp->lldpLocManAddrOID);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lldpLocManAddrOID, &StorageTmp->lldpLocManAddrOIDLen);
	if (StorageTmp->lldpLocManAddrOID == NULL) {
		config_perror("invalid specification for lldpLocManAddrOID");
		return;
	}
	lldpLocManAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpLocManAddrTable(): store configuraiton file for lldpLocManAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpLocManAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpLocManAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpLocManAddrTable: storing data...  "));
	refresh_lldpLocManAddrTable(1);
	(void) tmpsize;
	for (hcindex = lldpLocManAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpLocManAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpLocManAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocManAddrSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpLocManAddr, &StorageTmp->lldpLocManAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocManAddrLen, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocManAddrIfSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpLocManAddrIfId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->lldpLocManAddrOID, &StorageTmp->lldpLocManAddrOIDLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpRemTable_data *lldpRemTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpRemTable table.
 *
 * Creates a new lldpRemTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpRemTable_data *
lldpRemTable_create(void)
{
	struct lldpRemTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpRemChassisIdSubtype = 0;
		if ((StorageNew->lldpRemChassisId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemChassisIdLen = 0;
		StorageNew->lldpRemChassisId[StorageNew->lldpRemChassisIdLen] = 0;
		StorageNew->lldpRemPortIdSubtype = 0;
		if ((StorageNew->lldpRemPortId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemPortIdLen = 0;
		StorageNew->lldpRemPortId[StorageNew->lldpRemPortIdLen] = 0;
		if ((StorageNew->lldpRemPortDesc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemPortDescLen = 0;
		StorageNew->lldpRemPortDesc[StorageNew->lldpRemPortDescLen] = 0;
		if ((StorageNew->lldpRemSysName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemSysNameLen = 0;
		StorageNew->lldpRemSysName[StorageNew->lldpRemSysNameLen] = 0;
		if ((StorageNew->lldpRemSysDesc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemSysDescLen = 0;
		StorageNew->lldpRemSysDesc[StorageNew->lldpRemSysDescLen] = 0;
		if (memdup((u_char **) &StorageNew->lldpRemSysCapSupported, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->lldpRemSysCapSupportedLen = 1;
		if (memdup((u_char **) &StorageNew->lldpRemSysCapEnabled, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->lldpRemSysCapEnabledLen = 1;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpRemTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpRemTable_data *lldpRemTable_duplicate(struct lldpRemTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpRemTable_data *
lldpRemTable_duplicate(struct lldpRemTable_data *thedata)
{
	struct lldpRemTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpRemTable_id = thedata->lldpRemTable_id;
		StorageNew->lldpRemTimeMark = thedata->lldpRemTimeMark;
		StorageNew->lldpRemLocalPortNum = thedata->lldpRemLocalPortNum;
		StorageNew->lldpRemIndex = thedata->lldpRemIndex;
		StorageNew->lldpRemChassisIdSubtype = thedata->lldpRemChassisIdSubtype;
		if (!(StorageNew->lldpRemChassisId = malloc(thedata->lldpRemChassisIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemChassisId, thedata->lldpRemChassisId, thedata->lldpRemChassisIdLen);
		StorageNew->lldpRemChassisIdLen = thedata->lldpRemChassisIdLen;
		StorageNew->lldpRemChassisId[StorageNew->lldpRemChassisIdLen] = 0;
		StorageNew->lldpRemPortIdSubtype = thedata->lldpRemPortIdSubtype;
		if (!(StorageNew->lldpRemPortId = malloc(thedata->lldpRemPortIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemPortId, thedata->lldpRemPortId, thedata->lldpRemPortIdLen);
		StorageNew->lldpRemPortIdLen = thedata->lldpRemPortIdLen;
		StorageNew->lldpRemPortId[StorageNew->lldpRemPortIdLen] = 0;
		if (!(StorageNew->lldpRemPortDesc = malloc(thedata->lldpRemPortDescLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemPortDesc, thedata->lldpRemPortDesc, thedata->lldpRemPortDescLen);
		StorageNew->lldpRemPortDescLen = thedata->lldpRemPortDescLen;
		StorageNew->lldpRemPortDesc[StorageNew->lldpRemPortDescLen] = 0;
		if (!(StorageNew->lldpRemSysName = malloc(thedata->lldpRemSysNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemSysName, thedata->lldpRemSysName, thedata->lldpRemSysNameLen);
		StorageNew->lldpRemSysNameLen = thedata->lldpRemSysNameLen;
		StorageNew->lldpRemSysName[StorageNew->lldpRemSysNameLen] = 0;
		if (!(StorageNew->lldpRemSysDesc = malloc(thedata->lldpRemSysDescLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemSysDesc, thedata->lldpRemSysDesc, thedata->lldpRemSysDescLen);
		StorageNew->lldpRemSysDescLen = thedata->lldpRemSysDescLen;
		StorageNew->lldpRemSysDesc[StorageNew->lldpRemSysDescLen] = 0;
		if (!(StorageNew->lldpRemSysCapSupported = malloc(thedata->lldpRemSysCapSupportedLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemSysCapSupported, thedata->lldpRemSysCapSupported, thedata->lldpRemSysCapSupportedLen);
		StorageNew->lldpRemSysCapSupportedLen = thedata->lldpRemSysCapSupportedLen;
		StorageNew->lldpRemSysCapSupported[StorageNew->lldpRemSysCapSupportedLen] = 0;
		if (!(StorageNew->lldpRemSysCapEnabled = malloc(thedata->lldpRemSysCapEnabledLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemSysCapEnabled, thedata->lldpRemSysCapEnabled, thedata->lldpRemSysCapEnabledLen);
		StorageNew->lldpRemSysCapEnabledLen = thedata->lldpRemSysCapEnabledLen;
		StorageNew->lldpRemSysCapEnabled[StorageNew->lldpRemSysCapEnabledLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpRemTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpRemTable_destroy(struct lldpRemTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpRemTable_destroy(struct lldpRemTable_data **thedata)
{
	struct lldpRemTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpRemChassisId);
		StorageDel->lldpRemChassisIdLen = 0;
		SNMP_FREE(StorageDel->lldpRemPortId);
		StorageDel->lldpRemPortIdLen = 0;
		SNMP_FREE(StorageDel->lldpRemPortDesc);
		StorageDel->lldpRemPortDescLen = 0;
		SNMP_FREE(StorageDel->lldpRemSysName);
		StorageDel->lldpRemSysNameLen = 0;
		SNMP_FREE(StorageDel->lldpRemSysDesc);
		StorageDel->lldpRemSysDescLen = 0;
		SNMP_FREE(StorageDel->lldpRemSysCapSupported);
		StorageDel->lldpRemSysCapSupportedLen = 0;
		SNMP_FREE(StorageDel->lldpRemSysCapEnabled);
		StorageDel->lldpRemSysCapEnabledLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemTable_add(struct lldpRemTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpRemTable table data set.
 *
 * Adds a table row structure to the lldpRemTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpRemTable_add(struct lldpRemTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpRemTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpRemTimeMark */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->lldpRemTimeMark, sizeof(thedata->lldpRemTimeMark));
		/* lldpRemLocalPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemLocalPortNum, sizeof(thedata->lldpRemLocalPortNum));
		/* lldpRemIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemIndex, sizeof(thedata->lldpRemIndex));
		header_complex_add_data(&lldpRemTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemTable_del(struct lldpRemTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpRemTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpRemTable_del(struct lldpRemTable_data *thedata)
{
	struct lldpRemTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpRemTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpRemTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpRemTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpRemTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpRemTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpRemTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpRemTable_data *StorageTmp = lldpRemTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpRemTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lldpRemTimeMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemChassisIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemChassisId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemChassisId, &StorageTmp->lldpRemChassisIdLen);
	if (StorageTmp->lldpRemChassisId == NULL) {
		config_perror("invalid specification for lldpRemChassisId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemPortIdSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemPortId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemPortId, &StorageTmp->lldpRemPortIdLen);
	if (StorageTmp->lldpRemPortId == NULL) {
		config_perror("invalid specification for lldpRemPortId");
		return;
	}
	SNMP_FREE(StorageTmp->lldpRemPortDesc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemPortDesc, &StorageTmp->lldpRemPortDescLen);
	if (StorageTmp->lldpRemPortDesc == NULL) {
		config_perror("invalid specification for lldpRemPortDesc");
		return;
	}
	SNMP_FREE(StorageTmp->lldpRemSysName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemSysName, &StorageTmp->lldpRemSysNameLen);
	if (StorageTmp->lldpRemSysName == NULL) {
		config_perror("invalid specification for lldpRemSysName");
		return;
	}
	SNMP_FREE(StorageTmp->lldpRemSysDesc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemSysDesc, &StorageTmp->lldpRemSysDescLen);
	if (StorageTmp->lldpRemSysDesc == NULL) {
		config_perror("invalid specification for lldpRemSysDesc");
		return;
	}
	SNMP_FREE(StorageTmp->lldpRemSysCapSupported);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemSysCapSupported, &StorageTmp->lldpRemSysCapSupportedLen);
	if (StorageTmp->lldpRemSysCapSupported == NULL) {
		config_perror("invalid specification for lldpRemSysCapSupported");
		return;
	}
	SNMP_FREE(StorageTmp->lldpRemSysCapEnabled);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemSysCapEnabled, &StorageTmp->lldpRemSysCapEnabledLen);
	if (StorageTmp->lldpRemSysCapEnabled == NULL) {
		config_perror("invalid specification for lldpRemSysCapEnabled");
		return;
	}
	lldpRemTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpRemTable(): store configuraiton file for lldpRemTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpRemTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpRemTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpRemTable: storing data...  "));
	refresh_lldpRemTable(1);
	(void) tmpsize;
	for (hcindex = lldpRemTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpRemTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpRemTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lldpRemTimeMark, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemChassisIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemChassisId, &StorageTmp->lldpRemChassisIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemPortIdSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemPortId, &StorageTmp->lldpRemPortIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemPortDesc, &StorageTmp->lldpRemPortDescLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemSysName, &StorageTmp->lldpRemSysNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemSysDesc, &StorageTmp->lldpRemSysDescLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemSysCapSupported, &StorageTmp->lldpRemSysCapSupportedLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemSysCapEnabled, &StorageTmp->lldpRemSysCapEnabledLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpRemManAddrTable_data *lldpRemManAddrTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpRemManAddrTable table.
 *
 * Creates a new lldpRemManAddrTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpRemManAddrTable_data *
lldpRemManAddrTable_create(void)
{
	struct lldpRemManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemManAddrTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpRemTimeMark = 0;
		StorageNew->lldpRemLocalPortNum = 0;
		StorageNew->lldpRemIndex = 0;
		StorageNew->lldpRemManAddrIfSubtype = 0;
		StorageNew->lldpRemManAddrIfId = 0;
		if ((StorageNew->lldpRemManAddrOID = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->lldpRemManAddrOIDLen = 2;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpRemManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpRemManAddrTable_data *lldpRemManAddrTable_duplicate(struct lldpRemManAddrTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpRemManAddrTable_data *
lldpRemManAddrTable_duplicate(struct lldpRemManAddrTable_data *thedata)
{
	struct lldpRemManAddrTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemManAddrTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemManAddrTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpRemManAddrTable_id = thedata->lldpRemManAddrTable_id;
		StorageNew->lldpRemTimeMark = thedata->lldpRemTimeMark;
		StorageNew->lldpRemLocalPortNum = thedata->lldpRemLocalPortNum;
		StorageNew->lldpRemIndex = thedata->lldpRemIndex;
		StorageNew->lldpRemManAddrSubtype = thedata->lldpRemManAddrSubtype;
		if (!(StorageNew->lldpRemManAddr = malloc(thedata->lldpRemManAddrLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemManAddr, thedata->lldpRemManAddr, thedata->lldpRemManAddrLen);
		StorageNew->lldpRemManAddrLen = thedata->lldpRemManAddrLen;
		StorageNew->lldpRemManAddr[StorageNew->lldpRemManAddrLen] = 0;
		StorageNew->lldpRemManAddrIfSubtype = thedata->lldpRemManAddrIfSubtype;
		StorageNew->lldpRemManAddrIfId = thedata->lldpRemManAddrIfId;
		if (!(StorageNew->lldpRemManAddrOID = snmp_duplicate_objid(thedata->lldpRemManAddrOID, thedata->lldpRemManAddrOIDLen / sizeof(oid))))
			goto destroy;
		StorageNew->lldpRemManAddrOIDLen = thedata->lldpRemManAddrOIDLen;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpRemManAddrTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpRemManAddrTable_destroy(struct lldpRemManAddrTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpRemManAddrTable_destroy(struct lldpRemManAddrTable_data **thedata)
{
	struct lldpRemManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemManAddrTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpRemManAddr);
		StorageDel->lldpRemManAddrLen = 0;
		SNMP_FREE(StorageDel->lldpRemManAddrOID);
		StorageDel->lldpRemManAddrOIDLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemManAddrTable_add(struct lldpRemManAddrTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpRemManAddrTable table data set.
 *
 * Adds a table row structure to the lldpRemManAddrTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpRemManAddrTable_add(struct lldpRemManAddrTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpRemManAddrTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpRemTimeMark */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->lldpRemTimeMark, sizeof(thedata->lldpRemTimeMark));
		/* lldpRemLocalPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemLocalPortNum, sizeof(thedata->lldpRemLocalPortNum));
		/* lldpRemIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemIndex, sizeof(thedata->lldpRemIndex));
		/* lldpRemManAddrSubtype */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemManAddrSubtype, sizeof(thedata->lldpRemManAddrSubtype));
		/* lldpRemManAddr */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lldpRemManAddr, thedata->lldpRemManAddrLen);
		header_complex_add_data(&lldpRemManAddrTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemManAddrTable_del(struct lldpRemManAddrTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpRemManAddrTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpRemManAddrTable_del(struct lldpRemManAddrTable_data *thedata)
{
	struct lldpRemManAddrTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemManAddrTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpRemManAddrTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpRemManAddrTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpRemManAddrTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpRemManAddrTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpRemManAddrTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpRemManAddrTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpRemManAddrTable_data *StorageTmp = lldpRemManAddrTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpRemManAddrTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lldpRemTimeMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemManAddrSubtype, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemManAddr);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemManAddr, &StorageTmp->lldpRemManAddrLen);
	if (StorageTmp->lldpRemManAddr == NULL) {
		config_perror("invalid specification for lldpRemManAddr");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemManAddrIfSubtype, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemManAddrIfId, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemManAddrOID);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->lldpRemManAddrOID, &StorageTmp->lldpRemManAddrOIDLen);
	if (StorageTmp->lldpRemManAddrOID == NULL) {
		config_perror("invalid specification for lldpRemManAddrOID");
		return;
	}
	lldpRemManAddrTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpRemManAddrTable(): store configuraiton file for lldpRemManAddrTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpRemManAddrTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpRemManAddrTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpRemManAddrTable: storing data...  "));
	refresh_lldpRemManAddrTable(1);
	(void) tmpsize;
	for (hcindex = lldpRemManAddrTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpRemManAddrTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpRemManAddrTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lldpRemTimeMark, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemManAddrSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemManAddr, &StorageTmp->lldpRemManAddrLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemManAddrIfSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemManAddrIfId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->lldpRemManAddrOID, &StorageTmp->lldpRemManAddrOIDLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpRemUnknownTLVTable_data *lldpRemUnknownTLVTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpRemUnknownTLVTable table.
 *
 * Creates a new lldpRemUnknownTLVTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpRemUnknownTLVTable_data *
lldpRemUnknownTLVTable_create(void)
{
	struct lldpRemUnknownTLVTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemUnknownTLVTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemUnknownTLVTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpRemTimeMark = 0;
		StorageNew->lldpRemLocalPortNum = 0;
		StorageNew->lldpRemIndex = 0;
		if ((StorageNew->lldpRemUnknownTLVInfo = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemUnknownTLVInfoLen = 0;
		StorageNew->lldpRemUnknownTLVInfo[StorageNew->lldpRemUnknownTLVInfoLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpRemUnknownTLVTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpRemUnknownTLVTable_data *lldpRemUnknownTLVTable_duplicate(struct lldpRemUnknownTLVTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpRemUnknownTLVTable_data *
lldpRemUnknownTLVTable_duplicate(struct lldpRemUnknownTLVTable_data *thedata)
{
	struct lldpRemUnknownTLVTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemUnknownTLVTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemUnknownTLVTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpRemUnknownTLVTable_id = thedata->lldpRemUnknownTLVTable_id;
		StorageNew->lldpRemTimeMark = thedata->lldpRemTimeMark;
		StorageNew->lldpRemLocalPortNum = thedata->lldpRemLocalPortNum;
		StorageNew->lldpRemIndex = thedata->lldpRemIndex;
		StorageNew->lldpRemUnknownTLVType = thedata->lldpRemUnknownTLVType;
		if (!(StorageNew->lldpRemUnknownTLVInfo = malloc(thedata->lldpRemUnknownTLVInfoLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemUnknownTLVInfo, thedata->lldpRemUnknownTLVInfo, thedata->lldpRemUnknownTLVInfoLen);
		StorageNew->lldpRemUnknownTLVInfoLen = thedata->lldpRemUnknownTLVInfoLen;
		StorageNew->lldpRemUnknownTLVInfo[StorageNew->lldpRemUnknownTLVInfoLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpRemUnknownTLVTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpRemUnknownTLVTable_destroy(struct lldpRemUnknownTLVTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpRemUnknownTLVTable_destroy(struct lldpRemUnknownTLVTable_data **thedata)
{
	struct lldpRemUnknownTLVTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemUnknownTLVTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpRemUnknownTLVInfo);
		StorageDel->lldpRemUnknownTLVInfoLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemUnknownTLVTable_add(struct lldpRemUnknownTLVTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpRemUnknownTLVTable table data set.
 *
 * Adds a table row structure to the lldpRemUnknownTLVTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpRemUnknownTLVTable_add(struct lldpRemUnknownTLVTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpRemUnknownTLVTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpRemTimeMark */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->lldpRemTimeMark, sizeof(thedata->lldpRemTimeMark));
		/* lldpRemLocalPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemLocalPortNum, sizeof(thedata->lldpRemLocalPortNum));
		/* lldpRemIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemIndex, sizeof(thedata->lldpRemIndex));
		/* lldpRemUnknownTLVType */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemUnknownTLVType, sizeof(thedata->lldpRemUnknownTLVType));
		header_complex_add_data(&lldpRemUnknownTLVTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemUnknownTLVTable_del(struct lldpRemUnknownTLVTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpRemUnknownTLVTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpRemUnknownTLVTable_del(struct lldpRemUnknownTLVTable_data *thedata)
{
	struct lldpRemUnknownTLVTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemUnknownTLVTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpRemUnknownTLVTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpRemUnknownTLVTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpRemUnknownTLVTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpRemUnknownTLVTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpRemUnknownTLVTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpRemUnknownTLVTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpRemUnknownTLVTable_data *StorageTmp = lldpRemUnknownTLVTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpRemUnknownTLVTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lldpRemTimeMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemUnknownTLVType, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemUnknownTLVInfo);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemUnknownTLVInfo, &StorageTmp->lldpRemUnknownTLVInfoLen);
	if (StorageTmp->lldpRemUnknownTLVInfo == NULL) {
		config_perror("invalid specification for lldpRemUnknownTLVInfo");
		return;
	}
	lldpRemUnknownTLVTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpRemUnknownTLVTable(): store configuraiton file for lldpRemUnknownTLVTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpRemUnknownTLVTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpRemUnknownTLVTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpRemUnknownTLVTable: storing data...  "));
	refresh_lldpRemUnknownTLVTable(1);
	(void) tmpsize;
	for (hcindex = lldpRemUnknownTLVTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpRemUnknownTLVTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpRemUnknownTLVTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lldpRemTimeMark, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemUnknownTLVType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemUnknownTLVInfo, &StorageTmp->lldpRemUnknownTLVInfoLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct lldpRemOrgDefInfoTable_data *lldpRemOrgDefInfoTable_create(void)
 * @brief create a fresh data structure representing a new row in the lldpRemOrgDefInfoTable table.
 *
 * Creates a new lldpRemOrgDefInfoTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct lldpRemOrgDefInfoTable_data *
lldpRemOrgDefInfoTable_create(void)
{
	struct lldpRemOrgDefInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemOrgDefInfoTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemOrgDefInfoTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->lldpRemTimeMark = 0;
		StorageNew->lldpRemLocalPortNum = 0;
		StorageNew->lldpRemIndex = 0;
		if ((StorageNew->lldpRemOrgDefInfo = malloc(1)) == NULL)
			goto nomem;
		StorageNew->lldpRemOrgDefInfoLen = 0;
		StorageNew->lldpRemOrgDefInfo[StorageNew->lldpRemOrgDefInfoLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	lldpRemOrgDefInfoTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct lldpRemOrgDefInfoTable_data *lldpRemOrgDefInfoTable_duplicate(struct lldpRemOrgDefInfoTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct lldpRemOrgDefInfoTable_data *
lldpRemOrgDefInfoTable_duplicate(struct lldpRemOrgDefInfoTable_data *thedata)
{
	struct lldpRemOrgDefInfoTable_data *StorageNew = SNMP_MALLOC_STRUCT(lldpRemOrgDefInfoTable_data);

	DEBUGMSGTL(("lldpMIB", "lldpRemOrgDefInfoTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->lldpRemOrgDefInfoTable_id = thedata->lldpRemOrgDefInfoTable_id;
		StorageNew->lldpRemTimeMark = thedata->lldpRemTimeMark;
		StorageNew->lldpRemLocalPortNum = thedata->lldpRemLocalPortNum;
		StorageNew->lldpRemIndex = thedata->lldpRemIndex;
		if (!(StorageNew->lldpRemOrgDefInfoOUI = malloc(thedata->lldpRemOrgDefInfoOUILen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemOrgDefInfoOUI, thedata->lldpRemOrgDefInfoOUI, thedata->lldpRemOrgDefInfoOUILen);
		StorageNew->lldpRemOrgDefInfoOUILen = thedata->lldpRemOrgDefInfoOUILen;
		StorageNew->lldpRemOrgDefInfoOUI[StorageNew->lldpRemOrgDefInfoOUILen] = 0;
		StorageNew->lldpRemOrgDefInfoSubtype = thedata->lldpRemOrgDefInfoSubtype;
		StorageNew->lldpRemOrgDefInfoIndex = thedata->lldpRemOrgDefInfoIndex;
		if (!(StorageNew->lldpRemOrgDefInfo = malloc(thedata->lldpRemOrgDefInfoLen + 1)))
			goto destroy;
		memcpy(StorageNew->lldpRemOrgDefInfo, thedata->lldpRemOrgDefInfo, thedata->lldpRemOrgDefInfoLen);
		StorageNew->lldpRemOrgDefInfoLen = thedata->lldpRemOrgDefInfoLen;
		StorageNew->lldpRemOrgDefInfo[StorageNew->lldpRemOrgDefInfoLen] = 0;
	}
      done:
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	lldpRemOrgDefInfoTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int lldpRemOrgDefInfoTable_destroy(struct lldpRemOrgDefInfoTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
lldpRemOrgDefInfoTable_destroy(struct lldpRemOrgDefInfoTable_data **thedata)
{
	struct lldpRemOrgDefInfoTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemOrgDefInfoTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->lldpRemOrgDefInfoOUI);
		StorageDel->lldpRemOrgDefInfoOUILen = 0;
		SNMP_FREE(StorageDel->lldpRemOrgDefInfo);
		StorageDel->lldpRemOrgDefInfoLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemOrgDefInfoTable_add(struct lldpRemOrgDefInfoTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the lldpRemOrgDefInfoTable table data set.
 *
 * Adds a table row structure to the lldpRemOrgDefInfoTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
lldpRemOrgDefInfoTable_add(struct lldpRemOrgDefInfoTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("lldpMIB", "lldpRemOrgDefInfoTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* lldpRemTimeMark */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_TIMETICKS, (u_char *) &thedata->lldpRemTimeMark, sizeof(thedata->lldpRemTimeMark));
		/* lldpRemLocalPortNum */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemLocalPortNum, sizeof(thedata->lldpRemLocalPortNum));
		/* lldpRemIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemIndex, sizeof(thedata->lldpRemIndex));
		/* lldpRemOrgDefInfoOUI */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->lldpRemOrgDefInfoOUI, thedata->lldpRemOrgDefInfoOUILen);
		/* lldpRemOrgDefInfoSubtype */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemOrgDefInfoSubtype, sizeof(thedata->lldpRemOrgDefInfoSubtype));
		/* lldpRemOrgDefInfoIndex */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->lldpRemOrgDefInfoIndex, sizeof(thedata->lldpRemOrgDefInfoIndex));
		header_complex_add_data(&lldpRemOrgDefInfoTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("lldpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int lldpRemOrgDefInfoTable_del(struct lldpRemOrgDefInfoTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the lldpRemOrgDefInfoTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
lldpRemOrgDefInfoTable_del(struct lldpRemOrgDefInfoTable_data *thedata)
{
	struct lldpRemOrgDefInfoTable_data *StorageDel;

	DEBUGMSGTL(("lldpMIB", "lldpRemOrgDefInfoTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(lldpRemOrgDefInfoTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&lldpRemOrgDefInfoTableStorage, hciptr);
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_lldpRemOrgDefInfoTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for lldpRemOrgDefInfoTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case lldpRemOrgDefInfoTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_lldpRemOrgDefInfoTable(const char *token, char *line)
{
	size_t tmpsize;
	struct lldpRemOrgDefInfoTable_data *StorageTmp = lldpRemOrgDefInfoTable_create();

	DEBUGMSGTL(("lldpMIB", "parse_lldpRemOrgDefInfoTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->lldpRemTimeMark, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemIndex, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemOrgDefInfoOUI);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemOrgDefInfoOUI, &StorageTmp->lldpRemOrgDefInfoOUILen);
	if (StorageTmp->lldpRemOrgDefInfoOUI == NULL) {
		config_perror("invalid specification for lldpRemOrgDefInfoOUI");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemOrgDefInfoSubtype, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->lldpRemOrgDefInfoIndex, &tmpsize);
	SNMP_FREE(StorageTmp->lldpRemOrgDefInfo);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->lldpRemOrgDefInfo, &StorageTmp->lldpRemOrgDefInfoLen);
	if (StorageTmp->lldpRemOrgDefInfo == NULL) {
		config_perror("invalid specification for lldpRemOrgDefInfo");
		return;
	}
	lldpRemOrgDefInfoTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/*
 * store_lldpRemOrgDefInfoTable(): store configuraiton file for lldpRemOrgDefInfoTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_lldpRemOrgDefInfoTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct lldpRemOrgDefInfoTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("lldpMIB", "store_lldpRemOrgDefInfoTable: storing data...  "));
	refresh_lldpRemOrgDefInfoTable(1);
	(void) tmpsize;
	for (hcindex = lldpRemOrgDefInfoTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct lldpRemOrgDefInfoTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "lldpRemOrgDefInfoTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->lldpRemTimeMark, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemLocalPortNum, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemOrgDefInfoOUI, &StorageTmp->lldpRemOrgDefInfoOUILen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemOrgDefInfoSubtype, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->lldpRemOrgDefInfoIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->lldpRemOrgDefInfo, &StorageTmp->lldpRemOrgDefInfoLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpPortConfigTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpPortConfigTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, struct lldpPortConfigTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpPortConfigTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpPortConfigTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpPortConfigTable_data *
refresh_lldpPortConfigTable_row(struct lldpPortConfigTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpPortConfigTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpPortConfigTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpPortConfigTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpPortConfigTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpPortConfigTable(int force)
{
	if (!force && lldpPortConfigTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpPortConfigTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpPortConfigTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpPortConfigTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpPortConfigTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpPortConfigTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpPortConfigTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpPortConfigTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpPortConfigTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpPortConfigTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPPORTCONFIGADMINSTATUS:	/* ReadWrite */
		*write_method = write_lldpPortConfigAdminStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpPortConfigAdminStatus);
		rval = (u_char *) &StorageTmp->lldpPortConfigAdminStatus;
		break;
	case (u_char) LLDPPORTCONFIGNOTIFICATIONENABLE:	/* ReadWrite */
		*write_method = write_lldpPortConfigNotificationEnable;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpPortConfigNotificationEnable);
		rval = (u_char *) &StorageTmp->lldpPortConfigNotificationEnable;
		break;
	case (u_char) LLDPPORTCONFIGTLVSTXENABLE:	/* ReadWrite */
		*write_method = write_lldpPortConfigTLVsTxEnable;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpPortConfigTLVsTxEnableLen;
		rval = (u_char *) StorageTmp->lldpPortConfigTLVsTxEnable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpConfigManAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpConfigManAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, struct lldpConfigManAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpConfigManAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpConfigManAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpConfigManAddrTable_data *
refresh_lldpConfigManAddrTable_row(struct lldpConfigManAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpConfigManAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpConfigManAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpConfigManAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpConfigManAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpConfigManAddrTable(int force)
{
	if (!force && lldpConfigManAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpConfigManAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpConfigManAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpConfigManAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpConfigManAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpConfigManAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpConfigManAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpConfigManAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpConfigManAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpConfigManAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPCONFIGMANADDRPORTSTXENABLE:	/* ReadWrite */
		*write_method = write_lldpConfigManAddrPortsTxEnable;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpConfigManAddrPortsTxEnableLen;
		rval = (u_char *) StorageTmp->lldpConfigManAddrPortsTxEnable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpStatsTxPortTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpStatsTxPortTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, struct lldpStatsTxPortTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpStatsTxPortTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpStatsTxPortTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpStatsTxPortTable_data *
refresh_lldpStatsTxPortTable_row(struct lldpStatsTxPortTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpStatsTxPortTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpStatsTxPortTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpStatsTxPortTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpStatsTxPortTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpStatsTxPortTable(int force)
{
	if (!force && lldpStatsTxPortTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpStatsTxPortTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpStatsTxPortTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpStatsTxPortTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpStatsTxPortTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpStatsTxPortTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpStatsTxPortTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpStatsTxPortTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpStatsTxPortTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpStatsTxPortTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPSTATSTXPORTFRAMESTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsTxPortFramesTotal);
		rval = (u_char *) &StorageTmp->lldpStatsTxPortFramesTotal;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpStatsRxPortTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpStatsRxPortTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, struct lldpStatsRxPortTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpStatsRxPortTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpStatsRxPortTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpStatsRxPortTable_data *
refresh_lldpStatsRxPortTable_row(struct lldpStatsRxPortTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpStatsRxPortTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpStatsRxPortTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpStatsRxPortTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpStatsRxPortTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpStatsRxPortTable(int force)
{
	if (!force && lldpStatsRxPortTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpStatsRxPortTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpStatsRxPortTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpStatsRxPortTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpStatsRxPortTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpStatsRxPortTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpStatsRxPortTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpStatsRxPortTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpStatsRxPortTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpStatsRxPortTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortFramesDiscardedTotal);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortFramesDiscardedTotal;
		break;
	case (u_char) LLDPSTATSRXPORTFRAMESERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortFramesErrors);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortFramesErrors;
		break;
	case (u_char) LLDPSTATSRXPORTFRAMESTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortFramesTotal);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortFramesTotal;
		break;
	case (u_char) LLDPSTATSRXPORTTLVSDISCARDEDTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortTLVsDiscardedTotal);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortTLVsDiscardedTotal;
		break;
	case (u_char) LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortTLVsUnrecognizedTotal);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortTLVsUnrecognizedTotal;
		break;
	case (u_char) LLDPSTATSRXPORTAGEOUTSTOTAL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpStatsRxPortAgeoutsTotal);
		rval = (u_char *) &StorageTmp->lldpStatsRxPortAgeoutsTotal;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpLocPortTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpLocPortTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, struct lldpLocPortTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpLocPortTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpLocPortTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpLocPortTable_data *
refresh_lldpLocPortTable_row(struct lldpLocPortTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpLocPortTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpLocPortTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpLocPortTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpLocPortTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpLocPortTable(int force)
{
	if (!force && lldpLocPortTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpLocPortTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpLocPortTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpLocPortTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpLocPortTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpLocPortTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpLocPortTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpLocPortTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpLocPortTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpLocPortTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPLOCPORTIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpLocPortIdSubtype);
		rval = (u_char *) &StorageTmp->lldpLocPortIdSubtype;
		break;
	case (u_char) LLDPLOCPORTID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocPortIdLen;
		rval = (u_char *) StorageTmp->lldpLocPortId;
		break;
	case (u_char) LLDPLOCPORTDESC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocPortDescLen;
		rval = (u_char *) StorageTmp->lldpLocPortDesc;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpLocManAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpLocManAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, struct lldpLocManAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpLocManAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpLocManAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpLocManAddrTable_data *
refresh_lldpLocManAddrTable_row(struct lldpLocManAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpLocManAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpLocManAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpLocManAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpLocManAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpLocManAddrTable(int force)
{
	if (!force && lldpLocManAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpLocManAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpLocManAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpLocManAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpLocManAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpLocManAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpLocManAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpLocManAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpLocManAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpLocManAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPLOCMANADDRLEN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpLocManAddrLen);
		rval = (u_char *) &StorageTmp->lldpLocManAddrLen;
		break;
	case (u_char) LLDPLOCMANADDRIFSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpLocManAddrIfSubtype);
		rval = (u_char *) &StorageTmp->lldpLocManAddrIfSubtype;
		break;
	case (u_char) LLDPLOCMANADDRIFID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpLocManAddrIfId);
		rval = (u_char *) &StorageTmp->lldpLocManAddrIfId;
		break;
	case (u_char) LLDPLOCMANADDROID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpLocManAddrOIDLen * sizeof(oid);
		rval = (u_char *) StorageTmp->lldpLocManAddrOID;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpRemTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpRemTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, struct lldpRemTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpRemTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpRemTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpRemTable_data *
refresh_lldpRemTable_row(struct lldpRemTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpRemTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpRemTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpRemTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpRemTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpRemTable(int force)
{
	if (!force && lldpRemTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpRemTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpRemTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpRemTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpRemTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpRemTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpRemTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpRemTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpRemTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpRemTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPREMCHASSISIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpRemChassisIdSubtype);
		rval = (u_char *) &StorageTmp->lldpRemChassisIdSubtype;
		break;
	case (u_char) LLDPREMCHASSISID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemChassisIdLen;
		rval = (u_char *) StorageTmp->lldpRemChassisId;
		break;
	case (u_char) LLDPREMPORTIDSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpRemPortIdSubtype);
		rval = (u_char *) &StorageTmp->lldpRemPortIdSubtype;
		break;
	case (u_char) LLDPREMPORTID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemPortIdLen;
		rval = (u_char *) StorageTmp->lldpRemPortId;
		break;
	case (u_char) LLDPREMPORTDESC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemPortDescLen;
		rval = (u_char *) StorageTmp->lldpRemPortDesc;
		break;
	case (u_char) LLDPREMSYSNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemSysNameLen;
		rval = (u_char *) StorageTmp->lldpRemSysName;
		break;
	case (u_char) LLDPREMSYSDESC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemSysDescLen;
		rval = (u_char *) StorageTmp->lldpRemSysDesc;
		break;
	case (u_char) LLDPREMSYSCAPSUPPORTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemSysCapSupportedLen;
		rval = (u_char *) StorageTmp->lldpRemSysCapSupported;
		break;
	case (u_char) LLDPREMSYSCAPENABLED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemSysCapEnabledLen;
		rval = (u_char *) StorageTmp->lldpRemSysCapEnabled;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpRemManAddrTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpRemManAddrTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, struct lldpRemManAddrTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpRemManAddrTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpRemManAddrTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpRemManAddrTable_data *
refresh_lldpRemManAddrTable_row(struct lldpRemManAddrTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpRemManAddrTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpRemManAddrTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpRemManAddrTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpRemManAddrTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpRemManAddrTable(int force)
{
	if (!force && lldpRemManAddrTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpRemManAddrTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpRemManAddrTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpRemManAddrTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpRemManAddrTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpRemManAddrTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpRemManAddrTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpRemManAddrTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpRemManAddrTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpRemManAddrTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPREMMANADDRIFSUBTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpRemManAddrIfSubtype);
		rval = (u_char *) &StorageTmp->lldpRemManAddrIfSubtype;
		break;
	case (u_char) LLDPREMMANADDRIFID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->lldpRemManAddrIfId);
		rval = (u_char *) &StorageTmp->lldpRemManAddrIfId;
		break;
	case (u_char) LLDPREMMANADDROID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemManAddrOIDLen * sizeof(oid);
		rval = (u_char *) StorageTmp->lldpRemManAddrOID;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpRemUnknownTLVTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpRemUnknownTLVTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, struct lldpRemUnknownTLVTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpRemUnknownTLVTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpRemUnknownTLVTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpRemUnknownTLVTable_data *
refresh_lldpRemUnknownTLVTable_row(struct lldpRemUnknownTLVTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpRemUnknownTLVTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpRemUnknownTLVTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpRemUnknownTLVTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpRemUnknownTLVTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpRemUnknownTLVTable(int force)
{
	if (!force && lldpRemUnknownTLVTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpRemUnknownTLVTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpRemUnknownTLVTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpRemUnknownTLVTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpRemUnknownTLVTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpRemUnknownTLVTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpRemUnknownTLVTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpRemUnknownTLVTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpRemUnknownTLVTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpRemUnknownTLVTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPREMUNKNOWNTLVINFO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemUnknownTLVInfoLen;
		rval = (u_char *) StorageTmp->lldpRemUnknownTLVInfo;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_lldpRemOrgDefInfoTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	lldpRemOrgDefInfoTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, struct lldpRemOrgDefInfoTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_lldpRemOrgDefInfoTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the lldpRemOrgDefInfoTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct lldpRemOrgDefInfoTable_data *
refresh_lldpRemOrgDefInfoTable_row(struct lldpRemOrgDefInfoTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->lldpRemOrgDefInfoTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->lldpRemOrgDefInfoTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_lldpRemOrgDefInfoTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the lldpRemOrgDefInfoTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_lldpRemOrgDefInfoTable(int force)
{
	if (!force && lldpRemOrgDefInfoTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	lldpRemOrgDefInfoTable_refresh = 0;
}

/**
 * @fn u_char *var_lldpRemOrgDefInfoTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in lldpRemOrgDefInfoTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_lldpMIB above.
 */
u_char *
var_lldpRemOrgDefInfoTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct lldpRemOrgDefInfoTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("lldpMIB", "var_lldpRemOrgDefInfoTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_lldpRemOrgDefInfoTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(lldpRemOrgDefInfoTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_lldpRemOrgDefInfoTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) LLDPREMORGDEFINFO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->lldpRemOrgDefInfoLen;
		rval = (u_char *) StorageTmp->lldpRemOrgDefInfo;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_lldpPortConfigAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lldpPortConfigAdminStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpPortConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 11;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpPortConfigAdminStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(lldpPortConfigTableStorage, NULL, &name[11], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigAdminStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigAdminStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value txAndRx */
		switch (set_value) {
		case LLDPPORTCONFIGADMINSTATUS_TXONLY:
		case LLDPPORTCONFIGADMINSTATUS_RXONLY:
		case LLDPPORTCONFIGADMINSTATUS_TXANDRX:
		case LLDPPORTCONFIGADMINSTATUS_DISABLED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigAdminStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			if (StorageTmp->lldpPortConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpPortConfigTable_old = lldpPortConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpPortConfigTable_rsvs++;
		StorageTmp->lldpPortConfigAdminStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->lldpPortConfigTable_tsts == 0)
				if ((ret = check_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpPortConfigAdminStatus for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpPortConfigTable_sets == 0)
				if ((ret = update_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
			StorageTmp->lldpPortConfigTable_rsvs = 0;
			StorageTmp->lldpPortConfigTable_tsts = 0;
			StorageTmp->lldpPortConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpPortConfigTable_sets == 0)
			revert_lldpPortConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		StorageTmp->lldpPortConfigAdminStatus = StorageOld->lldpPortConfigAdminStatus;
		if (--StorageTmp->lldpPortConfigTable_rsvs == 0)
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpPortConfigNotificationEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lldpPortConfigNotificationEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpPortConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 11;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpPortConfigNotificationEnable entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(lldpPortConfigTableStorage, NULL, &name[11], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigNotificationEnable not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigNotificationEnable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigNotificationEnable: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			if (StorageTmp->lldpPortConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpPortConfigTable_old = lldpPortConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpPortConfigTable_rsvs++;
		StorageTmp->lldpPortConfigNotificationEnable = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->lldpPortConfigTable_tsts == 0)
				if ((ret = check_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpPortConfigNotificationEnable for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpPortConfigTable_sets == 0)
				if ((ret = update_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
			StorageTmp->lldpPortConfigTable_rsvs = 0;
			StorageTmp->lldpPortConfigTable_tsts = 0;
			StorageTmp->lldpPortConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpPortConfigTable_sets == 0)
			revert_lldpPortConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		StorageTmp->lldpPortConfigNotificationEnable = StorageOld->lldpPortConfigNotificationEnable;
		if (--StorageTmp->lldpPortConfigTable_rsvs == 0)
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpPortConfigTLVsTxEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lldpPortConfigTLVsTxEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpPortConfigTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 11;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpPortConfigTLVsTxEnable entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(lldpPortConfigTableStorage, NULL, &name[11], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigTLVsTxEnable not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigTLVsTxEnable: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpPortConfigTLVsTxEnable: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			if (StorageTmp->lldpPortConfigTable_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpPortConfigTable_old = lldpPortConfigTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpPortConfigTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->lldpPortConfigTLVsTxEnable);
		StorageTmp->lldpPortConfigTLVsTxEnable = string;
		StorageTmp->lldpPortConfigTLVsTxEnableLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->lldpPortConfigTable_tsts == 0)
				if ((ret = check_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpPortConfigTLVsTxEnable for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpPortConfigTable_sets == 0)
				if ((ret = update_lldpPortConfigTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpPortConfigTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) != NULL) {
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
			StorageTmp->lldpPortConfigTable_rsvs = 0;
			StorageTmp->lldpPortConfigTable_tsts = 0;
			StorageTmp->lldpPortConfigTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpPortConfigTable_sets == 0)
			revert_lldpPortConfigTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpPortConfigTable_old) == NULL)
			break;
		if (StorageOld->lldpPortConfigTLVsTxEnable != NULL) {
			SNMP_FREE(StorageTmp->lldpPortConfigTLVsTxEnable);
			StorageTmp->lldpPortConfigTLVsTxEnable = StorageOld->lldpPortConfigTLVsTxEnable;
			StorageTmp->lldpPortConfigTLVsTxEnableLen = StorageOld->lldpPortConfigTLVsTxEnableLen;
			StorageOld->lldpPortConfigTLVsTxEnable = NULL;
			StorageOld->lldpPortConfigTLVsTxEnableLen = 0;
		}
		if (--StorageTmp->lldpPortConfigTable_rsvs == 0)
			lldpPortConfigTable_destroy(&StorageTmp->lldpPortConfigTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpConfigManAddrPortsTxEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_lldpConfigManAddrPortsTxEnable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpConfigManAddrTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 11;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpConfigManAddrPortsTxEnable entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(lldpConfigManAddrTableStorage, NULL, &name[11], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpConfigManAddrPortsTxEnable not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..512 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 512))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpConfigManAddrPortsTxEnable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) == NULL)
			if (StorageTmp->lldpConfigManAddrTable_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old = lldpConfigManAddrTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpConfigManAddrTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->lldpConfigManAddrPortsTxEnable);
		StorageTmp->lldpConfigManAddrPortsTxEnable = string;
		StorageTmp->lldpConfigManAddrPortsTxEnableLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->lldpConfigManAddrTable_tsts == 0)
				if ((ret = check_lldpConfigManAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpConfigManAddrTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpConfigManAddrPortsTxEnable for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpConfigManAddrTable_sets == 0)
				if ((ret = update_lldpConfigManAddrTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpConfigManAddrTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) != NULL) {
			lldpConfigManAddrTable_destroy(&StorageTmp->lldpConfigManAddrTable_old);
			StorageTmp->lldpConfigManAddrTable_rsvs = 0;
			StorageTmp->lldpConfigManAddrTable_tsts = 0;
			StorageTmp->lldpConfigManAddrTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpConfigManAddrTable_sets == 0)
			revert_lldpConfigManAddrTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpConfigManAddrTable_old) == NULL)
			break;
		if (StorageOld->lldpConfigManAddrPortsTxEnable != NULL) {
			SNMP_FREE(StorageTmp->lldpConfigManAddrPortsTxEnable);
			StorageTmp->lldpConfigManAddrPortsTxEnable = StorageOld->lldpConfigManAddrPortsTxEnable;
			StorageTmp->lldpConfigManAddrPortsTxEnableLen = StorageOld->lldpConfigManAddrPortsTxEnableLen;
			StorageOld->lldpConfigManAddrPortsTxEnable = NULL;
			StorageOld->lldpConfigManAddrPortsTxEnableLen = 0;
		}
		if (--StorageTmp->lldpConfigManAddrTable_rsvs == 0)
			lldpConfigManAddrTable_destroy(&StorageTmp->lldpConfigManAddrTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpMessageTxInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lldpMessageTxInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpMessageTxInterval entering action=%d...  \n", action));
	if ((StorageTmp = lldpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 30 */
		/* Note: ranges 5..32768 */
		if ((5 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			if (StorageTmp->lldpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpMIB_old = lldpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpMIB_rsvs++;
		StorageTmp->lldpMessageTxInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->lldpMIB_tsts == 0)
				if ((ret = check_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpMessageTxInterval for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpMIB_sets == 0)
				if ((ret = update_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
			StorageTmp->lldpMIB_rsvs = 0;
			StorageTmp->lldpMIB_tsts = 0;
			StorageTmp->lldpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpMIB_tsts == 0)
			revert_lldpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		StorageTmp->lldpMessageTxInterval = StorageOld->lldpMessageTxInterval;
		if (--StorageTmp->lldpMIB_rsvs == 0)
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpMessageTxHoldMultiplier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lldpMessageTxHoldMultiplier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpMessageTxHoldMultiplier entering action=%d...  \n", action));
	if ((StorageTmp = lldpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxHoldMultiplier not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxHoldMultiplier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges 2..10 */
		if ((2 > set_value || set_value > 10)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpMessageTxHoldMultiplier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			if (StorageTmp->lldpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpMIB_old = lldpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpMIB_rsvs++;
		StorageTmp->lldpMessageTxHoldMultiplier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->lldpMIB_tsts == 0)
				if ((ret = check_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpMessageTxHoldMultiplier for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpMIB_sets == 0)
				if ((ret = update_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
			StorageTmp->lldpMIB_rsvs = 0;
			StorageTmp->lldpMIB_tsts = 0;
			StorageTmp->lldpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpMIB_tsts == 0)
			revert_lldpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		StorageTmp->lldpMessageTxHoldMultiplier = StorageOld->lldpMessageTxHoldMultiplier;
		if (--StorageTmp->lldpMIB_rsvs == 0)
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpReinitDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lldpReinitDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpReinitDelay entering action=%d...  \n", action));
	if ((StorageTmp = lldpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpReinitDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpReinitDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 1..10 */
		if ((1 > set_value || set_value > 10)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpReinitDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			if (StorageTmp->lldpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpMIB_old = lldpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpMIB_rsvs++;
		StorageTmp->lldpReinitDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->lldpMIB_tsts == 0)
				if ((ret = check_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpReinitDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpMIB_sets == 0)
				if ((ret = update_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
			StorageTmp->lldpMIB_rsvs = 0;
			StorageTmp->lldpMIB_tsts = 0;
			StorageTmp->lldpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpMIB_tsts == 0)
			revert_lldpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		StorageTmp->lldpReinitDelay = StorageOld->lldpReinitDelay;
		if (--StorageTmp->lldpMIB_rsvs == 0)
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpTxDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lldpTxDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpTxDelay entering action=%d...  \n", action));
	if ((StorageTmp = lldpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpTxDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpTxDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 1..8192 */
		if ((1 > set_value || set_value > 8192)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpTxDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			if (StorageTmp->lldpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpMIB_old = lldpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpMIB_rsvs++;
		StorageTmp->lldpTxDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->lldpMIB_tsts == 0)
				if ((ret = check_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpTxDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpMIB_sets == 0)
				if ((ret = update_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
			StorageTmp->lldpMIB_rsvs = 0;
			StorageTmp->lldpMIB_tsts = 0;
			StorageTmp->lldpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpMIB_tsts == 0)
			revert_lldpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		StorageTmp->lldpTxDelay = StorageOld->lldpTxDelay;
		if (--StorageTmp->lldpMIB_rsvs == 0)
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_lldpNotificationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_lldpNotificationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct lldpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("lldpMIB", "write_lldpNotificationInterval entering action=%d...  \n", action));
	if ((StorageTmp = lldpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpNotificationInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpNotificationInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges 5..3600 */
		if ((5 > set_value || set_value > 3600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to lldpNotificationInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			if (StorageTmp->lldpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->lldpMIB_old = lldpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->lldpMIB_rsvs++;
		StorageTmp->lldpNotificationInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->lldpMIB_tsts == 0)
				if ((ret = check_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->lldpNotificationInterval for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->lldpMIB_sets == 0)
				if ((ret = update_lldpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->lldpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->lldpMIB_old) != NULL) {
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
			StorageTmp->lldpMIB_rsvs = 0;
			StorageTmp->lldpMIB_tsts = 0;
			StorageTmp->lldpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->lldpMIB_tsts == 0)
			revert_lldpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->lldpMIB_old) == NULL)
			break;
		StorageTmp->lldpNotificationInterval = StorageOld->lldpNotificationInterval;
		if (--StorageTmp->lldpMIB_rsvs == 0)
			lldpMIB_destroy(&StorageTmp->lldpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_lldpRemTablesChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("lldpMIB", "send_lldpRemTablesChange_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lldpRemTablesChange_oid;
	trap.val_len = sizeof(lldpRemTablesChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/**
 * @fn void lldpMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
lldpMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("lldpMIB", "lldpMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (lldpMIBold_signal_handler != NULL)
		(*lldpMIBold_signal_handler) (sig);
	DEBUGMSGTL(("lldpMIB", "done.\n"));
}

/**
 * @fn void lldpMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
lldpMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("lldpMIB", "lldpMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("lldpMIB", "done.\n"));
	return;
}
